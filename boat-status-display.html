<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orange USV Status Display System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow-x: auto;
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 5px;
            background: linear-gradient(45deg, #00bfff, #b19cd9);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Main Display Controls */
        .display-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            align-items: center;
        }

        .display-controls label {
            font-weight: bold;
            color: #00bfff;
        }

        .display-controls select {
            padding: 5px 10px;
            background: #333;
            border: 1px solid #555;
            color: #fff;
            border-radius: 3px;
            cursor: pointer;
        }

        .display-controls button {
            padding: 5px 15px;
            background: linear-gradient(45deg, #00bfff, #b19cd9);
            border: none;
            border-radius: 3px;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .display-controls button:hover {
            transform: scale(1.05);
        }

        /* Main display area */
        .main-display {
            position: relative;
            background: #2a2a2a;
            border: 2px solid #444;
            border-radius: 10px;
            min-height: 600px;
            height: 600px;
            margin-bottom: 20px;
            overflow: hidden;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            cursor: default;
        }

        .main-display.draggable-area {
            cursor: crosshair;
        }

        /* Small status boxes */
        .status-boxes {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 20px;
        }

        .status-box {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid #444;
            border-radius: 10px;
            padding: 10px;
            min-width: 200px;
            max-width: 250px;
            flex: 1;
            position: relative;
        }

        .status-box.drag-over {
            border-color: #00bfff;
            background: rgba(0, 191, 255, 0.1);
        }

        .status-box h3 {
            color: #00bfff;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-align: center;
        }

        .status-box-content {
            min-height: 80px;
            overflow: visible;
            position: relative;
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            padding: 5px;
        }

        /* Pod styles */
        .pod {
            display: inline-flex;
            flex-wrap: wrap;
            gap: 3px;
            padding: 3px;
            margin: 2px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px dashed #666;
            border-radius: 5px;
            position: relative;
            cursor: move;
        }

        .pod.selected {
            background: rgba(0, 191, 255, 0.2);
            border-color: #00bfff;
        }

        .pod.in-small-box {
            cursor: grab;
        }

        /* Legend */
        .legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            font-size: 0.85em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* Boat wrapper styles */
        .legend-boat-wrapper {
            width: 16px;
            height: 32px;
            position: relative;
            padding: 2px;
            background: #fff;
            clip-path: polygon(50% 0%, 85% 15%, 95% 35%, 95% 65%, 85% 85%, 75% 100%, 25% 100%, 15% 85%, 5% 65%, 5% 35%, 15% 15%);
            display: inline-block;
        }

        .legend-boat-wrapper.user-leg {
            background: #b19cd9;
        }

        .legend-boat-wrapper.user-lat {
            background: #00bfff;
        }

        .legend-boat {
            width: 12px;
            height: 28px;
            position: relative;
            overflow: visible;
            clip-path: polygon(50% 0%, 85% 15%, 95% 35%, 95% 65%, 85% 85%, 75% 100%, 25% 100%, 15% 85%, 5% 65%, 5% 35%, 15% 15%);
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #ff0000;
        }

        /* Status colors - Complete states */
        .legend-boat.status-none { background-color: #ff0000 !important; }
        .legend-boat.status-platform { background-color: #ff8c00 !important; }
        .legend-boat.status-pierside { background-color: #ffff00 !important; }
        .legend-boat.status-pretow { 
            background: repeating-linear-gradient(
                45deg,
                #ffffff,
                #ffffff 2px,
                #00ff00 2px,
                #00ff00 4px
            ) !important;
        }
        .legend-boat.status-operational { background-color: #00ff00 !important; }
        
        /* Status colors - Start states (with grey hatching) */
        .legend-boat.status-platform-start { 
            background: repeating-linear-gradient(
                135deg,
                #ff8c00,
                #ff8c00 3px,
                #808080 3px,
                #808080 6px
            ) !important;
        }
        .legend-boat.status-pierside-start { 
            background: repeating-linear-gradient(
                135deg,
                #ffff00,
                #ffff00 3px,
                #808080 3px,
                #808080 6px
            ) !important;
        }
        .legend-boat.status-pretow-start { 
            background: repeating-linear-gradient(
                135deg,
                #00ff00,
                #00ff00 3px,
                #808080 3px,
                #808080 6px
            ) !important;
        }
        .legend-boat.status-operational-start { 
            background: repeating-linear-gradient(
                135deg,
                #00ff00,
                #00ff00 3px,
                #808080 3px,
                #808080 6px
            ) !important;
        }
        
        /* Trouble status */
        .legend-boat.status-trouble { 
            background: repeating-linear-gradient(
                45deg,
                #ff0000,
                #ff0000 3px,
                #ff8c00 3px,
                #ff8c00 6px
            ) !important;
        }

        /* User indicators */
        .legend-boat-wrapper .user-indicator {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 6px;
            font-weight: bold;
            color: #fff;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        .legend-boat-wrapper.user-leg .user-indicator {
            background-color: #b19cd9;
        }

        .legend-boat-wrapper.user-lat .user-indicator {
            background-color: #00bfff;
        }

        /* Boat number */
        .legend-boat .boat-number {
            background: rgba(255, 255, 255, 0.9);
            color: #000;
            padding: 1px 2px;
            border-radius: 2px;
            font-size: 8px;
            font-weight: bold;
            z-index: 2;
            white-space: nowrap;
        }

        /* Boat styles */
        .boat {
            position: absolute;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            transition: all 0.3s ease;
            overflow: visible;
            clip-path: polygon(50% 0%, 85% 15%, 95% 35%, 95% 65%, 85% 85%, 75% 100%, 25% 100%, 15% 85%, 5% 65%, 5% 35%, 15% 15%);
            background-color: #ff0000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .boat:active {
            cursor: grabbing;
        }

        /* Boat wrapper */
        .boat-wrapper {
            position: absolute;
            background: transparent;
            display: inline-block;
            cursor: grab;
        }

        .boat-wrapper:active {
            cursor: grabbing;
        }

        .boat-wrapper.in-small-box {
            position: relative !important;
            display: inline-block;
            margin: 2px;
            cursor: grab;
        }
        
        /* Ghost image for dragging */
        .boat-wrapper.dragging {
            opacity: 0.7;
            cursor: grabbing;
        }

        .boat-outline {
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: #fff;
            clip-path: polygon(50% 0%, 85% 15%, 95% 35%, 95% 65%, 85% 85%, 75% 100%, 25% 100%, 15% 85%, 5% 65%, 5% 35%, 15% 15%);
            z-index: 0;
        }

        .boat-wrapper.user-leg .boat-outline {
            background: #b19cd9;
        }

        .boat-wrapper.user-lat .boat-outline {
            background: #00bfff;
        }

        /* Rotation handle */
        .rotation-handle {
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            width: 12px;
            height: 12px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #333;
            border-radius: 50%;
            cursor: grab;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 10;
            pointer-events: all;
        }

        .boat-wrapper:hover .rotation-handle {
            opacity: 1;
        }

        .rotation-handle:hover {
            background: #fff;
            transform: translateX(-50%) scale(1.2);
        }

        .rotation-handle:active {
            cursor: grabbing;
        }

        .boat-wrapper.in-small-box .rotation-handle {
            display: none;
        }

        /* Boat sizes */
        .boat-type-1 {
            width: 30px;
            height: 60px;
        }

        .boat-type-2 {
            width: 26px;
            height: 44px;
        }

        .boat:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .boat-number {
            background: rgba(255, 255, 255, 0.9);
            color: #000;
            padding: 2px 3px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            z-index: 2;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            white-space: nowrap;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .boat-type-2 .boat-number {
            font-size: 9px;
            padding: 1px 2px;
        }

        .user-indicator {
            position: absolute;
            bottom: 3px;
            right: 3px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: bold;
            color: #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            z-index: 3;
        }

        /* Boat Status Colors - Complete */
        .status-none { background-color: #ff0000 !important; }
        .status-platform { background-color: #ff8c00 !important; }
        .status-pierside { background-color: #ffff00 !important; }
        .status-pretow { 
            background: repeating-linear-gradient(
                45deg,
                #ffffff,
                #ffffff 3px,
                #00ff00 3px,
                #00ff00 6px
            ) !important;
        }
        .status-operational { background-color: #00ff00 !important; }
        
        /* Boat Status Colors - Start */
        .status-platform-start { 
            background: repeating-linear-gradient(
                135deg,
                #ff8c00,
                #ff8c00 3px,
                #808080 3px,
                #808080 6px
            ) !important;
        }
        .status-pierside-start { 
            background: repeating-linear-gradient(
                135deg,
                #ffff00,
                #ffff00 3px,
                #808080 3px,
                #808080 6px
            ) !important;
        }
        .status-pretow-start { 
            background: repeating-linear-gradient(
                135deg,
                #00ff00,
                #00ff00 3px,
                #808080 3px,
                #808080 6px
            ) !important;
        }
        .status-operational-start { 
            background: repeating-linear-gradient(
                135deg,
                #00ff00,
                #00ff00 3px,
                #808080 3px,
                #808080 6px
            ) !important;
        }
        
        /* Trouble status */
        .status-trouble { 
            background: repeating-linear-gradient(
                45deg,
                #ff0000,
                #ff0000 3px,
                #ff8c00 3px,
                #ff8c00 6px
            ) !important;
        }

        .user-leg .user-indicator {
            background-color: #b19cd9;
        }

        .user-lat .user-indicator {
            background-color: #00bfff;
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background: #2a2a2a;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 5px 0;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            max-height: 400px;
            overflow-y: auto;
        }

        .context-menu-item {
            padding: 8px 20px;
            cursor: pointer;
            color: #fff;
            font-size: 0.9em;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .context-menu-item:hover {
            background: rgba(0, 191, 255, 0.2);
        }
        
        .context-menu-item.has-submenu {
            padding-right: 30px;
            position: relative;
        }
        
        .context-menu-item.has-submenu::after {
            content: '▶';
            position: absolute;
            right: 10px;
            opacity: 0.6;
        }

        .context-menu-separator {
            height: 1px;
            background: #444;
            margin: 5px 0;
        }

        .status-indicator-menu {
            width: 10px;
            height: 10px;
            border-radius: 2px;
            display: inline-block;
        }

        /* Status Table */
.status-tracker {
    margin-top: 30px;
    padding: 20px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
}

.status-tracker h2 {
    color: #00bfff;
    margin-bottom: 20px;
    text-align: center;
}

.table-container {
    overflow-x: auto;
    margin-bottom: 20px;
    max-height: 400px;
    overflow-y: auto;
    position: relative;
}

table {
    width: 100%;
    border-collapse: collapse;
    background: rgba(0, 0, 0, 0.3);
}

thead {
    position: sticky;
    top: 0;
    z-index: 10;
    background: #1a1a1a;
}

th {
    padding: 8px;
    border: 1px solid #444;
    text-align: center;
    background: rgba(0, 191, 255, 0.2);
    color: #00bfff;
    position: sticky;
    top: 0;
    z-index: 10;
    white-space: nowrap;
}

td {
    padding: 8px;
    border: 1px solid #444;
    text-align: center;
    color: #000 !important;
    font-size: 0.85em;
    line-height: 1.2;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
}

/* Split cells for start/complete */
td.split-cell {
    padding: 0;
    position: relative;
    border: 1px solid #444;
}

.split-cell-top, .split-cell-bottom {
    padding: 4px;
    min-height: 25px;
    border: 1px solid #444;
}

.split-cell-top {
    border-bottom: 1px solid #444;
}

            td small {
            display: block;
            font-size: 0.7em;
            color: #333 !important;
            margin-top: 1px;
            font-weight: normal;
            text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.5);
        }

        /* Status cell colors */
        td.status-none, .split-cell-top.status-none, .split-cell-bottom.status-none { 
            background-color: rgba(255, 0, 0, 0.7);
        }
        td.status-platform, .split-cell-bottom.status-platform { 
            background-color: rgba(255, 140, 0, 0.7);
        }
        td.status-pierside, .split-cell-bottom.status-pierside { 
            background-color: rgba(255, 255, 0, 0.7);
        }
        td.status-pretow, .split-cell-bottom.status-pretow { 
            background: repeating-linear-gradient(
                45deg,
                rgba(255, 255, 255, 0.7),
                rgba(255, 255, 255, 0.7) 5px,
                rgba(0, 255, 0, 0.7) 5px,
                rgba(0, 255, 0, 0.7) 10px
            );
        }
        td.status-operational, .split-cell-bottom.status-operational { 
            background-color: rgba(0, 255, 0, 0.7);
        }
        
        /* Start status cells */
        .split-cell-top.status-platform-start {
            background: repeating-linear-gradient(
                135deg,
                rgba(255, 140, 0, 0.7),
                rgba(255, 140, 0, 0.7) 3px,
                rgba(128, 128, 128, 0.7) 3px,
                rgba(128, 128, 128, 0.7) 6px
            );
        }
        .split-cell-top.status-pierside-start {
            background: repeating-linear-gradient(
                135deg,
                rgba(255, 255, 0, 0.7),
                rgba(255, 255, 0, 0.7) 3px,
                rgba(128, 128, 128, 0.7) 3px,
                rgba(128, 128, 128, 0.7) 6px
            );
        }
        .split-cell-top.status-pretow-start {
            background: repeating-linear-gradient(
                135deg,
                rgba(0, 255, 0, 0.7),
                rgba(0, 255, 0, 0.7) 3px,
                rgba(128, 128, 128, 0.7) 3px,
                rgba(128, 128, 128, 0.7) 6px
            );
        }
        .split-cell-top.status-operational-start {
            background: repeating-linear-gradient(
                135deg,
                rgba(0, 255, 0, 0.7),
                rgba(0, 255, 0, 0.7) 3px,
                rgba(128, 128, 128, 0.7) 3px,
                rgba(128, 128, 128, 0.7) 6px
            );
        }
        
        /* Trouble status cells */
        td.status-trouble, .split-cell-top.status-trouble, .split-cell-bottom.status-trouble {
            background: repeating-linear-gradient(
                45deg,
                rgba(255, 0, 0, 0.7),
                rgba(255, 0, 0, 0.7) 3px,
                rgba(255, 140, 0, 0.7) 3px,
                rgba(255, 140, 0, 0.7) 6px
            );
        }

	/* Fixed button positioning */
.table-controls {
    display: flex;
    gap: 10px;
    margin-top: 10px;
    align-items: center;
}

.table-controls button {
    padding: 10px 20px;
    background: linear-gradient(45deg, #00bfff, #b19cd9);
    border: none;
    border-radius: 5px;
    color: #fff;
    font-weight: bold;
    cursor: pointer;
    transition: transform 0.2s;
    white-space: nowrap;
}

.table-controls button:hover {
    transform: scale(1.05);
}

.google-sheets-info {
    flex: 1;
    padding: 15px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 5px;
    margin-left: 20px;
}

.google-sheets-info p {
    margin-bottom: 10px;
    color: #00bfff;
    font-weight: bold;
}

.google-sheets-info input {
    width: 100%;
    padding: 8px;
    margin-bottom: 10px;
    background: #333;
    border: 1px solid #555;
    border-radius: 5px;
    color: #fff;
}

        .controls {
            margin-top: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .controls button {
            padding: 10px 20px;
            background: linear-gradient(45deg, #00bfff, #b19cd9);
            border: none;
            border-radius: 5px;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .controls button:hover {
            transform: scale(1.05);
        }

        .boat-count {
            margin-left: auto;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        @media (max-width: 1200px) {
            .status-boxes {
                flex-direction: column;
                align-items: center;
            }
            
            .status-box {
                max-width: 100%;
                width: 100%;
            }
        }

        /* View-only mode */
        .view-only-indicator {
            background: rgba(255, 165, 0, 0.2);
            border: 2px solid orange;
            padding: 10px;
            margin-top: 10px;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Boat Status Display System v7</h1>
            <p>Enhanced with Start/Complete times and Trouble status</p>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-boat-wrapper">
                    <div class="legend-boat status-none">
                        <span class="boat-number">C</span>
                    </div>
                </div>
                <span>C Boat</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper">
                    <div class="legend-boat status-none">
                        <span class="boat-number">G</span>
                    </div>
                </div>
                <span>G Boat</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper">
                    <div class="legend-boat status-none"></div>
                </div>
                <span>No Check</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper">
                    <div class="legend-boat status-platform-start"></div>
                </div>
                <span>Platform Start</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper">
                    <div class="legend-boat status-platform"></div>
                </div>
                <span>Platform Complete</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper">
                    <div class="legend-boat status-pierside-start"></div>
                </div>
                <span>Pierside Start</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper">
                    <div class="legend-boat status-pierside"></div>
                </div>
                <span>Pierside Complete</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper">
                    <div class="legend-boat status-pretow-start"></div>
                </div>
                <span>Pre-Tow Start</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper">
                    <div class="legend-boat status-pretow"></div>
                </div>
                <span>Pre-Tow Complete</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper">
                    <div class="legend-boat status-operational-start"></div>
                </div>
                <span>Post-Tow Start</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper">
                    <div class="legend-boat status-operational"></div>
                </div>
                <span>Post-Tow Complete</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper">
                    <div class="legend-boat status-trouble"></div>
                </div>
                <span>Trouble</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper user-leg">
                    <div class="legend-boat"></div>
                    <div class="user-indicator">Leg</div>
                </div>
                <span>Leg</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper user-lat">
                    <div class="legend-boat"></div>
                    <div class="user-indicator">Lat</div>
                </div>
                <span>Lat</span>
            </div>
            <div class="legend-item">
                <div class="pod" style="position: relative; display: inline-block; padding: 2px;">
                    <div style="width: 10px; height: 20px; background: #666; margin: 1px;"></div>
                    <div style="width: 10px; height: 20px; background: #666; margin: 1px;"></div>
                </div>
                <span>Pod (grouped boats)</span>
            </div>
        </div>

        <!-- Main Display Controls -->
        <div class="display-controls">
            <label>Main Display:</label>
            <select id="mainDisplaySelect">
                <option value="pier">Pier Area</option>
                <option value="tow">Being Towed</option>
                <option value="transit">In Transit</option>
                <option value="operational-area">Operational Area</option>
            </select>
            <input type="file" id="bgImageInput" accept="image/*" style="display: none;">
            <button onclick="document.getElementById('bgImageInput').click()">Set Background for This Display</button>
            <button onclick="clearBackground()">Clear Background</button>
        </div>

        <!-- Main Display Area -->
        <div class="main-display draggable-area" id="mainDisplay">
            <!-- Boats will be dynamically displayed here -->
        </div>

        <!-- Small Status Boxes -->
        <div class="status-boxes">
            <div class="status-box" data-area="pier">
                <h3>At Pier</h3>
                <div class="status-box-content" id="pierSmallBox"></div>
            </div>
            <div class="status-box" data-area="tow">
                <h3>Being Towed</h3>
                <div class="status-box-content" id="towSmallBox"></div>
            </div>
            <div class="status-box" data-area="transit">
                <h3>In Transit</h3>
                <div class="status-box-content" id="transitSmallBox"></div>
            </div>
            <div class="status-box" data-area="operational-area">
                <h3>Operational Area</h3>
                <div class="status-box-content" id="operationalAreaSmallBox"></div>
            </div>
        </div>

        <div class="controls">
            <button onclick="saveAllLayouts()">Save All</button>
            <button onclick="loadAllLayouts()">Load All</button>
            <button onclick="exportToCSV()">Export Status Log</button>
            <button onclick="generateViewOnlyLink()">Generate View-Only Link</button>
            <button onclick="window.resetStatusDisplay()" style="background: linear-gradient(45deg, #ff6b6b, #ff5252);">Reset Display</button>
            <div class="boat-count">
                Total Boats: <span id="boatCount">0</span> | 
                Total Pods: <span id="podCount">0</span>
            </div>
        </div>

        <div class="status-tracker">
            <h2>Status Tracking</h2>
            <div class="table-container">
                <table id="statusTable">
                    <thead>
                        <tr>
                            <th rowspan="2">Boat</th>
                            <th rowspan="2">Group</th>
                            <th rowspan="2">No Check</th>
                            <th colspan="2">Platform</th>
                            <th colspan="2">Pierside</th>
                            <th colspan="2">Pre-Tow</th>
                            <th colspan="2">Post-Tow</th>
                            <th rowspan="2">Trouble</th>
                            <th rowspan="2">Towed</th>
                            <th rowspan="2">Transit</th>
                            <th rowspan="2">Op Area</th>
                            <th rowspan="2">Return</th>
                        </tr>
                        <tr>
                            <th>Start</th>
                            <th>Done</th>
                            <th>Start</th>
                            <th>Done</th>
                            <th>Start</th>
                            <th>Done</th>
                            <th>Start</th>
                            <th>Done</th>
                        </tr>
                    </thead>
                    <tbody id="statusTableBody">
                    </tbody>
                </table>
            </div>
            <div class="table-controls" style="display: flex; gap: 10px; margin-top: 10px;">
                <button onclick="exportToCSV()">Export to CSV</button>
                <button onclick="clearStatusTable()">Clear Table</button>
                <div class="google-sheets-info" style="flex: 1; padding: 15px; background: rgba(255, 255, 255, 0.05); border-radius: 5px; margin-left: 20px;">
                    <p style="margin-bottom: 10px; color: #00bfff; font-weight: bold;">Google Sheets Integration:</p>
                    <input type="text" id="webhookUrl" placeholder="Google Sheets webhook URL" style="width: 100%; padding: 8px; margin-bottom: 10px; background: #333; border: 1px solid #555; border-radius: 5px; color: #fff;" />
                    <button onclick="saveWebhookUrl()">Save URL</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Context Menu (hidden by default) -->
    <div class="context-menu" id="contextMenu" style="display: none; position: fixed;"></div>

<script>
// Global state management - Version 7 Enhanced
const state = {
    boats: new Map(),
    pods: new Map(),
    currentDisplay: 'pier',
    areaLayouts: new Map(), // Independent layouts per area
    areaBackgrounds: new Map(), // Independent backgrounds per area
    draggedItem: null,
    draggedFromArea: null,
    rotatingBoat: null,
    selectedPod: null,
    isViewOnly: false,
    pollTimer: null,
    lastKnownStates: new Map(),
    statusLogHistory: new Map(),
    rowTracking: new Map(), // Track which row each boat is currently using
    troubleStatusMemory: new Map(), // Store previous status before trouble
    nextPositions: new Map() // Track next available positions for each area
};

// Constants
const N8N_CONFIG = {
    assignmentWebhook: 'https://tacticalleadingedge.app.n8n.cloud/webhook/boat-assignments',
    statusWebhook: 'https://tacticalleadingedge.app.n8n.cloud/webhook/boat-status-update',
    stateWebhook: 'https://tacticalleadingedge.app.n8n.cloud/webhook/boat-state'
};

const POLL_INTERVAL = 30000;
const BOAT_SPACING = {
    horizontal: 40,
    vertical: 75,
    podSpacing: 6.5
};

// Initialize
document.addEventListener('DOMContentLoaded', function() {
    initializeSystem();
});

function initializeSystem() {
    // Check view-only mode
    const urlParams = new URLSearchParams(window.location.search);
    state.isViewOnly = urlParams.get('view') === 'only';
    
    if (state.isViewOnly) {
        enableViewOnlyMode();
    }
    
    // Initialize displays
    setupMainDisplay();
    setupContextMenu();
    setupEventListeners();
    setupSmallBoxDragDrop();
    setupBackgroundUpload();
    
    // Initialize next positions for each area
    ['pier', 'tow', 'transit', 'operational-area'].forEach(area => {
        state.nextPositions.set(area, { x: 20, y: 100, rowCount: 0 });
    });
    
    // Load saved state
    loadSavedState();
    
    // Start polling
    startPolling();
    
    console.log('✅ Boat Status Display v7 initialized with enhanced features');
}

// Setup background upload
function setupBackgroundUpload() {
    const input = document.getElementById('bgImageInput');
    input.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const bgData = e.target.result;
                // Save background for current display area
                state.areaBackgrounds.set(state.currentDisplay, bgData);
                localStorage.setItem(`background-${state.currentDisplay}`, bgData);
                
                // Apply to display
                document.getElementById('mainDisplay').style.backgroundImage = `url(${bgData})`;
                
                // Auto-save
                autoSaveState();
            };
            reader.readAsDataURL(file);
        }
    });
}

// Clear background for current display
function clearBackground() {
    state.areaBackgrounds.delete(state.currentDisplay);
    localStorage.removeItem(`background-${state.currentDisplay}`);
    document.getElementById('mainDisplay').style.backgroundImage = '';
    autoSaveState();
}

// Get next available position for boat placement
function getNextPosition(area, boatType = 1) {
    const pos = state.nextPositions.get(area) || { x: 20, y: 100, rowCount: 0 };
    const mainDisplay = document.getElementById('mainDisplay');
    const maxWidth = mainDisplay ? mainDisplay.offsetWidth : 1200;
    
    // Calculate boat width including spacing
    const boatWidth = (boatType === 1 ? 30 : 26) + BOAT_SPACING.horizontal;
    
    // Check if we need to wrap to next row
    if (pos.x + boatWidth > maxWidth - 20) {
        pos.x = 20;
        pos.y += BOAT_SPACING.vertical;
        pos.rowCount = 0;
    }
    
    // Store current position for return
    const returnPos = { x: pos.x, y: pos.y };
    
    // Update for next boat
    pos.x += boatWidth;
    pos.rowCount++;
    
    // Save updated position
    state.nextPositions.set(area, pos);
    
    return returnPos;
}

// Setup drag and drop for small boxes
function setupSmallBoxDragDrop() {
    const statusBoxes = document.querySelectorAll('.status-box');
    
    statusBoxes.forEach(box => {
        const content = box.querySelector('.status-box-content');
        
        content.addEventListener('dragover', (e) => {
            e.preventDefault();
            box.classList.add('drag-over');
        });
        
        content.addEventListener('dragleave', () => {
            box.classList.remove('drag-over');
        });
        
        content.addEventListener('drop', (e) => {
            e.preventDefault();
            box.classList.remove('drag-over');
            
            const targetArea = box.dataset.area;
            handleSmallBoxDrop(e, targetArea);
        });
    });
}

// Handle drop in small box
function handleSmallBoxDrop(e, targetArea) {
    if (!state.draggedItem) return;
    
    if (state.draggedItem.classList.contains('boat-wrapper')) {
        // Handle boat drop
        const boatId = parseInt(state.draggedItem.id.replace('boat-wrapper-', ''));
        const boat = state.boats.get(boatId);
        
        if (boat) {
            // Move boat to new area
            moveBoatToArea(boatId, targetArea);
            
            // Log movement status if it's a movement area
            const movementMap = {
                'tow': 'tow',
                'transit': 'transit',
                'operational-area': 'operational-area',
                'pier': 'return-pier'
            };
            
            if (movementMap[targetArea] && state.draggedFromArea !== targetArea) {
                const operator = localStorage.getItem('lastOperator') || 'Manual Drag';
                updateBoatStatus(boatId, movementMap[targetArea], operator);
            }
        }
    } else if (state.draggedItem.classList.contains('pod')) {
        // Handle pod drop
        const podId = state.draggedItem.dataset.podId;
        const pod = state.pods.get(podId);
        
        if (pod) {
            // Move entire pod
            movePodToArea(podId, targetArea);
            
            // Log movement for all boats in pod
            const movementMap = {
                'tow': 'tow',
                'transit': 'transit',
                'operational-area': 'operational-area',
                'pier': 'return-pier'
            };
            
            if (movementMap[targetArea] && state.draggedFromArea !== targetArea) {
                const operator = localStorage.getItem('lastOperator') || 'Manual Drag';
                pod.boats.forEach(boatId => {
                    updateBoatStatus(boatId, movementMap[targetArea], operator);
                });
            }
        }
    }
}

// Move pod to area
function movePodToArea(podId, area) {
    const pod = state.pods.get(podId);
    if (!pod) return;
    
    pod.location = area;
    
    // Update all boats in pod
    pod.boats.forEach(boatId => {
        const boat = state.boats.get(boatId);
        if (boat) {
            boat.location = area;
        }
    });
    
    updateMainDisplay();
    updateSmallBoxes();
}

// Main display management
function setupMainDisplay() {
    const mainDisplay = document.getElementById('mainDisplay');
    const displaySelect = document.getElementById('mainDisplaySelect');
    
    displaySelect.addEventListener('change', function() {
        // Save current area layout before switching
        saveAreaLayout(state.currentDisplay);
        
        state.currentDisplay = this.value;
        updateMainDisplay();
    });
    
    // Set up drag and drop for main display
    mainDisplay.addEventListener('dragover', handleDragOver);
    mainDisplay.addEventListener('drop', handleDrop);
    
    // Context menu for creating pods
    mainDisplay.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) {
            e.preventDefault();
            
            // Check if clicking on a boat within a pod
            const boatWrapper = e.target.closest('.boat-wrapper');
            const podElement = e.target.closest('.pod');
            
            if (boatWrapper && podElement) {
                // Clicking on a boat within a pod - show boat menu
                const boatId = parseInt(boatWrapper.id.replace('boat-wrapper-', ''));
                showBoatInPodContextMenu(e, boatId, podElement.dataset.podId);
            } else if (podElement) {
                // Clicking on pod but not on a boat - show pod menu
                showPodContextMenu(e, podElement.dataset.podId);
            } else if (boatWrapper) {
                // Individual boat not in pod
                const boatId = parseInt(boatWrapper.id.replace('boat-wrapper-', ''));
                showBoatContextMenu(e, boatId);
            } else {
                // Empty space - show area menu
                showAreaContextMenu(e, state.currentDisplay);
            }
        }
    });
}

// Save layout for specific area
function saveAreaLayout(area) {
    const layout = {
        boats: [],
        pods: []
    };
    
    // Save boat positions for this area
    state.boats.forEach((boat, id) => {
        if (boat.location === area && !boat.podId) {
            layout.boats.push({
                id: id,
                x: boat.x || 0,
                y: boat.y || 0,
                rotation: boat.rotation || 0
            });
        }
    });
    
    // Save pod positions for this area
    state.pods.forEach((pod, id) => {
        if (pod.location === area) {
            layout.pods.push({
                id: id,
                x: pod.x || 0,
                y: pod.y || 0,
                rotation: pod.rotation || 0
            });
        }
    });
    
    state.areaLayouts.set(area, layout);
    localStorage.setItem(`areaLayout-${area}`, JSON.stringify(layout));
}

// Update main display
function updateMainDisplay() {
    const mainDisplay = document.getElementById('mainDisplay');
    mainDisplay.innerHTML = '';
    
    // Always allow dragging
    mainDisplay.classList.add('draggable-area');
    
    // Load background for current area
    const areaBackground = state.areaBackgrounds.get(state.currentDisplay) || 
                          localStorage.getItem(`background-${state.currentDisplay}`);
    
    if (areaBackground) {
        mainDisplay.style.backgroundImage = `url(${areaBackground})`;
        state.areaBackgrounds.set(state.currentDisplay, areaBackground);
    } else {
        mainDisplay.style.backgroundImage = '';
    }
    
    // Display boats for current area only
    displayAreaContent(state.currentDisplay);
}

// Display content for an area
function displayAreaContent(area) {
    const mainDisplay = document.getElementById('mainDisplay');
    
    // Get saved layout for this specific area
    const savedLayout = state.areaLayouts.get(area) || 
                       JSON.parse(localStorage.getItem(`areaLayout-${area}`) || 'null');
    
    // Track boats in this area for default positioning
    const boatsInArea = [];
    const podsInArea = [];
    
    // Collect boats and pods in this area
    state.boats.forEach((boat, id) => {
        if (boat.location === area && !boat.podId) {
            boatsInArea.push(boat);
        }
    });
    
    state.pods.forEach((pod, id) => {
        if (pod.location === area) {
            podsInArea.push(pod);
        }
    });
    
    // Sort boats by type and number for organized display
    boatsInArea.sort((a, b) => {
        if (a.type !== b.type) return a.type - b.type; // C boats first
        return a.id - b.id; // Then by number
    });
    
    // Display pods first
    podsInArea.forEach(pod => {
        const podElement = createPodElement(pod);
        podElement.style.position = 'absolute';
        
        // Use saved position or pod's stored position
        if (savedLayout && savedLayout.pods) {
            const savedPod = savedLayout.pods.find(p => p.id === pod.id);
            if (savedPod) {
                pod.x = savedPod.x;
                pod.y = savedPod.y;
                pod.rotation = savedPod.rotation;
            }
        }
        
        // If no position set, get next available
        if (pod.x === undefined || pod.x === null) {
            const pos = getNextPosition(area);
            pod.x = pos.x;
            pod.y = pos.y;
        }
        
        podElement.style.left = pod.x + 'px';
        podElement.style.top = pod.y + 'px';
        
        // Enable right-click on boats within pod
        podElement.querySelectorAll('.boat-wrapper').forEach(boatEl => {
            boatEl.addEventListener('contextmenu', function(e) {
                if (!state.isViewOnly) {
                    e.preventDefault();
                    e.stopPropagation();
                    const boatId = parseInt(boatEl.id.replace('boat-wrapper-', ''));
                    showBoatInPodContextMenu(e, boatId, pod.id);
                }
            });
        });
        
        mainDisplay.appendChild(podElement);
    });
    
    // Display individual boats
    boatsInArea.forEach(boat => {
        const boatElement = boat.element;
        boatElement.classList.remove('in-small-box');
        boatElement.style.position = 'absolute';
        
        let positioned = false;
        
        // Check for saved position
        if (savedLayout && savedLayout.boats) {
            const savedBoat = savedLayout.boats.find(b => b.id === boat.id);
            if (savedBoat) {
                boat.x = savedBoat.x;
                boat.y = savedBoat.y;
                boat.rotation = savedBoat.rotation;
                boatElement.style.left = savedBoat.x + 'px';
                boatElement.style.top = savedBoat.y + 'px';
                boatElement.style.transform = `rotate(${savedBoat.rotation}deg)`;
                positioned = true;
            }
        }
        
        // If no saved position and no current position, use next available
        if (!positioned && (boat.x === undefined || boat.x === null)) {
            const pos = getNextPosition(area, boat.type);
            boat.x = pos.x;
            boat.y = pos.y;
            boat.rotation = 0;
        }
        
        // Apply position
        boatElement.style.left = (boat.x || 20) + 'px';
        boatElement.style.top = (boat.y || 100) + 'px';
        boatElement.style.transform = `rotate(${boat.rotation || 0}deg)`;
        
        mainDisplay.appendChild(boatElement);
    });
}

// Move boat to area
function moveBoatToArea(boatId, area) {
    const boatData = state.boats.get(boatId);
    if (!boatData) return;
    
    // Update location
    boatData.location = area;
    
    // Reset position for new area (will use next available or saved)
    boatData.x = null;
    boatData.y = null;
    
    // Update displays
    updateMainDisplay();
    updateSmallBoxes();
}

// Boat creation
function createBoat(config) {
    const wrapper = document.createElement('div');
    wrapper.className = `boat-wrapper user-${config.userGroup}`;
    wrapper.style.position = 'absolute';
    wrapper.style.left = (config.x || 0) + 'px';
    wrapper.style.top = (config.y || 0) + 'px';
    wrapper.style.transform = `rotate(${config.rotation || 0}deg)`;
    wrapper.style.width = config.type === 1 ? '34px' : '30px';
    wrapper.style.height = config.type === 1 ? '64px' : '48px';
    wrapper.id = `boat-wrapper-${config.id}`;
    wrapper.draggable = !state.isViewOnly;
    
    // Create outline
    const outline = document.createElement('div');
    outline.className = 'boat-outline';
    
    const boat = document.createElement('div');
    boat.className = `boat boat-type-${config.type} status-${config.status}`;
    boat.id = `boat-${config.id}`;
    boat.style.position = 'relative';
    boat.style.width = config.type === 1 ? '30px' : '26px';
    boat.style.height = config.type === 1 ? '60px' : '44px';
    boat.style.top = '2px';
    boat.style.left = '2px';
    boat.style.zIndex = '1';
    
    // Add boat number
    const prefix = config.type === 1 ? 'C' : 'G';
    const paddedNumber = config.id.toString().padStart(2, '0');
    
    const boatNumber = document.createElement('span');
    boatNumber.className = 'boat-number';
    boatNumber.textContent = `${prefix}${paddedNumber}`;
    boat.appendChild(boatNumber);
    
    // Create user indicator
    const userIndicator = document.createElement('div');
    userIndicator.className = 'user-indicator';
    userIndicator.textContent = config.userGroup === 'leg' ? 'Leg' : 'Lat';
    userIndicator.style.zIndex = '3';
    
    // Create rotation handle
    const rotationHandle = document.createElement('div');
    rotationHandle.className = 'rotation-handle';
    rotationHandle.style.zIndex = '4';
    rotationHandle.title = 'Click and drag to rotate';
    
    if (state.isViewOnly) {
        rotationHandle.style.display = 'none';
    }
    
    // Assemble elements
    wrapper.appendChild(outline);
    wrapper.appendChild(boat);
    wrapper.appendChild(userIndicator);
    wrapper.appendChild(rotationHandle);
    
    // Add event listeners
    if (!state.isViewOnly) {
        wrapper.addEventListener('dragstart', handleDragStart);
        wrapper.addEventListener('dragend', handleDragEnd);
        
        rotationHandle.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            handleRotationStart(e, wrapper);
        });
        
        wrapper.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            showBoatContextMenu(e, config.id);
        });
    }
    
    // Store boat data
    const boatData = {
        id: config.id,
        element: wrapper,
        boat: boat,
        type: config.type,
        userGroup: config.userGroup,
        status: config.status || 'none',
        checkStatus: config.status || 'none',
        location: config.location || 'pier',
        x: config.x,
        y: config.y,
        rotation: config.rotation || 0,
        podId: null,
        troublePreviousStatus: null
    };
    
    state.boats.set(config.id, boatData);
    
    updateBoatCount();
    updateSmallBoxes();
    
    return boatData;
}

// Update small boxes - FIXED for operational-area display
function updateSmallBoxes() {
    const areas = ['pier', 'tow', 'transit', 'operational-area'];
    
    areas.forEach(area => {
        // Fix the ID mapping for operational-area
        let smallBoxId;
        if (area === 'operational-area') {
            smallBoxId = 'operationalAreaSmallBox';
        } else {
            smallBoxId = area.replace('-', '') + 'SmallBox';
        }
        
        const smallBox = document.getElementById(smallBoxId);
        if (!smallBox) {
            console.warn(`Small box not found for area: ${area} (looked for ${smallBoxId})`);
            return;
        }
        
        smallBox.innerHTML = '';
        
        // Collect and sort boats/pods in this area
        const podsInArea = [];
        const boatsInArea = [];
        
        state.pods.forEach(pod => {
            if (pod.location === area) {
                podsInArea.push(pod);
            }
        });
        
        state.boats.forEach((boat, id) => {
            if (boat.location === area && !boat.podId) {
                boatsInArea.push({ id, boat });
            }
        });
        
        // Sort boats by type then number
        boatsInArea.sort((a, b) => {
            if (a.boat.type !== b.boat.type) {
                return a.boat.type - b.boat.type; // C boats first
            }
            return a.id - b.id;
        });
        
        // Add pods first
        podsInArea.forEach(pod => {
            const podElement = createPodElement(pod, true);
            smallBox.appendChild(podElement);
        });
        
        // Add individual boats
        boatsInArea.forEach(({ id, boat }) => {
            const boatElement = boat.element.cloneNode(true);
            boatElement.classList.add('in-small-box');
            boatElement.style.position = 'relative';
            boatElement.style.left = '';
            boatElement.style.top = '';
            boatElement.style.transform = '';
            
            // Keep check status color
            const checkStatus = boat.checkStatus || boat.status;
            const boatInner = boatElement.querySelector('.boat');
            if (boatInner) {
                boatInner.className = `boat boat-type-${boat.type} status-${checkStatus}`;
            }
            
            // Make draggable from small box
            boatElement.draggable = true;
            boatElement.addEventListener('dragstart', handleDragStart);
            
            // Add context menu
            boatElement.addEventListener('contextmenu', function(e) {
                if (!state.isViewOnly) {
                    e.preventDefault();
                    showBoatContextMenu(e, id);
                }
            });
            
            smallBox.appendChild(boatElement);
        });
    });
}

// Context Menu Functions

// Show context menu for boat within a pod
function showBoatInPodContextMenu(e, boatId, podId) {
    const menu = document.getElementById('contextMenu');
    const boatData = state.boats.get(boatId);
    const pod = state.pods.get(podId);
    
    if (!boatData) return;
    
    const prefix = boatData.type === 1 ? 'C' : 'G';
    const paddedNumber = boatId.toString().padStart(2, '0');
    
    menu.innerHTML = `
        <div class="context-menu-item" style="font-weight: bold; color: #00bfff;">
            ${prefix}${paddedNumber} - In Pod
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" style="font-weight: bold;">Check Status (This Boat)</div>
        <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'none')">
            <span class="status-indicator-menu status-none"></span>
            No Check
        </div>
        <div class="context-menu-item has-submenu">
            <span class="status-indicator-menu status-platform"></span>
            Platform Check ▶
            <div class="submenu" style="display: none; position: absolute; left: 100%; top: 0; background: #2a2a2a; border: 2px solid #444; border-radius: 8px; min-width: 120px;">
                <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'platform-start')">Start</div>
                <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'platform')">Complete</div>
            </div>
        </div>
        <div class="context-menu-item has-submenu">
            <span class="status-indicator-menu status-pierside"></span>
            Pierside Check ▶
            <div class="submenu" style="display: none; position: absolute; left: 100%; top: 0; background: #2a2a2a; border: 2px solid #444; border-radius: 8px; min-width: 120px;">
                <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pierside-start')">Start</div>
                <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pierside')">Complete</div>
            </div>
        </div>
        <div class="context-menu-item has-submenu">
            <span class="status-indicator-menu status-pretow"></span>
            Pre-Tow Check ▶
            <div class="submenu" style="display: none; position: absolute; left: 100%; top: 0; background: #2a2a2a; border: 2px solid #444; border-radius: 8px; min-width: 120px;">
                <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pretow-start')">Start</div>
                <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pretow')">Complete</div>
            </div>
        </div>
        <div class="context-menu-item has-submenu">
            <span class="status-indicator-menu status-operational"></span>
            Post-Tow Check ▶
            <div class="submenu" style="display: none; position: absolute; left: 100%; top: 0; background: #2a2a2a; border: 2px solid #444; border-radius: 8px; min-width: 120px;">
                <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'operational-start')">Start</div>
                <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'operational')">Complete</div>
            </div>
        </div>
        <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'trouble')">
            <span class="status-indicator-menu status-trouble"></span>
            Trouble
        </div>
        ${boatData.troublePreviousStatus ? `
        <div class="context-menu-item" onclick="clearTroubleStatus(${boatId})">
            ✓ Clear Trouble (Restore ${boatData.troublePreviousStatus})
        </div>
        ` : ''}
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" style="font-weight: bold;">Movement (Entire Pod)</div>
        <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'tow')">
            Being Towed
        </div>
        <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'transit')">
            In Transit
        </div>
        <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'operational-area')">
            Operational Area
        </div>
        <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'return-pier')">
            Return to Pier
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="breakUpPod('${podId}')">
            💔 Break Up Pod
        </div>
    `;
    
    positionContextMenu(menu, e.pageX, e.pageY);
    setupSubmenuHover(menu);
}

// Show boat context menu
function showBoatContextMenu(e, boatId) {
    const menu = document.getElementById('contextMenu');
    const boatData = state.boats.get(boatId);
    
    if (!boatData) return;
    
    const prefix = boatData.type === 1 ? 'C' : 'G';
    const paddedNumber = boatId.toString().padStart(2, '0');
    
    menu.innerHTML = `
        <div class="context-menu-item" style="font-weight: bold; color: #00bfff;">
            ${prefix}${paddedNumber} - Status Update
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'none')">
            <span class="status-indicator-menu status-none"></span>
            No Check
        </div>
        <div class="context-menu-item has-submenu">
            <span class="status-indicator-menu status-platform"></span>
            Platform Check ▶
            <div class="submenu" style="display: none; position: absolute; left: 100%; top: 0; background: #2a2a2a; border: 2px solid #444; border-radius: 8px; min-width: 120px;">
                <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'platform-start')">Start</div>
                <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'platform')">Complete</div>
            </div>
        </div>
        <div class="context-menu-item has-submenu">
            <span class="status-indicator-menu status-pierside"></span>
            Pierside Check ▶
            <div class="submenu" style="display: none; position: absolute; left: 100%; top: 0; background: #2a2a2a; border: 2px solid #444; border-radius: 8px; min-width: 120px;">
                <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pierside-start')">Start</div>
                <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pierside')">Complete</div>
            </div>
        </div>
        <div class="context-menu-item has-submenu">
            <span class="status-indicator-menu status-pretow"></span>
            Pre-Tow Check ▶
            <div class="submenu" style="display: none; position: absolute; left: 100%; top: 0; background: #2a2a2a; border: 2px solid #444; border-radius: 8px; min-width: 120px;">
                <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pretow-start')">Start</div>
                <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pretow')">Complete</div>
            </div>
        </div>
        <div class="context-menu-item has-submenu">
            <span class="status-indicator-menu status-operational"></span>
            Post-Tow Check ▶
            <div class="submenu" style="display: none; position: absolute; left: 100%; top: 0; background: #2a2a2a; border: 2px solid #444; border-radius: 8px; min-width: 120px;">
                <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'operational-start')">Start</div>
                <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'operational')">Complete</div>
            </div>
        </div>
        <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'trouble')">
            <span class="status-indicator-menu status-trouble"></span>
            Trouble
        </div>
        ${boatData.troublePreviousStatus ? `
        <div class="context-menu-item" onclick="clearTroubleStatus(${boatId})">
            ✓ Clear Trouble (Restore ${boatData.troublePreviousStatus})
        </div>
        ` : ''}
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'tow')">
            Being Towed
        </div>
        <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'transit')">
            In Transit
        </div>
        <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'operational-area')">
            Operational Area
        </div>
        <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'return-pier')">
            Return to Pier
        </div>
    `;
    
    positionContextMenu(menu, e.pageX, e.pageY);
    setupSubmenuHover(menu);
}

// Setup submenu hover behavior
function setupSubmenuHover(menu) {
    const itemsWithSubmenu = menu.querySelectorAll('.has-submenu');
    itemsWithSubmenu.forEach(item => {
        const submenu = item.querySelector('.submenu');
        if (submenu) {
            item.addEventListener('mouseenter', () => {
                submenu.style.display = 'block';
            });
            item.addEventListener('mouseleave', () => {
                submenu.style.display = 'none';
            });
        }
    });
}

// Clear trouble status and restore previous
window.clearTroubleStatus = function(boatId) {
    const boatData = state.boats.get(boatId);
    if (!boatData || !boatData.troublePreviousStatus) return;
    
    const operator = prompt('Enter your name:', localStorage.getItem('lastOperator') || 'Manual');
    if (operator) {
        localStorage.setItem('lastOperator', operator);
        
        // Restore previous status
        const previousStatus = boatData.troublePreviousStatus;
        boatData.troublePreviousStatus = null;
        
        updateBoatStatus(boatId, previousStatus, operator + ' (Trouble Cleared)');
    }
    
    document.getElementById('contextMenu').style.display = 'none';
}

// Update boat status from menu
window.updateBoatStatusFromMenu = function(boatId, status) {
    const operator = prompt('Enter your name:', localStorage.getItem('lastOperator') || 'Manual');
    if (operator) {
        localStorage.setItem('lastOperator', operator);
        updateBoatStatus(boatId, status, operator);
    }
    document.getElementById('contextMenu').style.display = 'none';
}

// Update entire pod status from menu
window.updatePodStatusFromMenu = function(podId, status) {
    const operator = prompt('Enter your name:', localStorage.getItem('lastOperator') || 'Manual');
    if (operator) {
        localStorage.setItem('lastOperator', operator);
        const pod = state.pods.get(podId);
        if (pod) {
            pod.boats.forEach(boatId => {
                updateBoatStatus(boatId, status, operator);
            });
        }
    }
    document.getElementById('contextMenu').style.display = 'none';
}

// Update boat status with enhanced timestamp precision
function updateBoatStatus(boatId, newStatus, operator = 'Unknown') {
    const boatData = state.boats.get(boatId);
    if (!boatData) return;
    
    // Handle trouble status
    if (newStatus === 'trouble' && boatData.status !== 'trouble') {
        // Store current status before switching to trouble
        boatData.troublePreviousStatus = boatData.status;
    }
    
    const movementStatuses = ['tow', 'transit', 'operational-area', 'return-pier'];
    const isMovementStatus = movementStatuses.includes(newStatus);
    
    // Save current check status
    if (!isMovementStatus) {
        boatData.checkStatus = newStatus;
        boatData.status = newStatus;
        boatData.boat.className = `boat boat-type-${boatData.type} status-${newStatus}`;
    }
    
    // Add to status table with full timestamp
    const timestamp = new Date();
    addStatusToTable(boatId, boatData, newStatus, operator, { timestamp });
    
    if (isMovementStatus) {
        // Movement status - handle movement
        let targetLocation = '';
        if (newStatus === 'tow') targetLocation = 'tow';
        else if (newStatus === 'transit') targetLocation = 'transit';
        else if (newStatus === 'operational-area') targetLocation = 'operational-area';
        else if (newStatus === 'return-pier') targetLocation = 'pier';
        
        if (targetLocation && boatData.location !== targetLocation) {
            // Move boat or pod
            if (boatData.podId) {
                movePodToArea(boatData.podId, targetLocation);
            } else {
                moveBoatToArea(boatId, targetLocation);
            }
        }
    }
    
    // Send update to server with full timestamp
    sendStatusUpdate(boatId, newStatus, operator, boatData.checkStatus, timestamp);
}

// Add status to table with split cells for start/complete
function addStatusToTable(boatId, boatData, status, operator, options = {}) {
    const timestamp = options.timestamp || new Date();
    const timeStr = new Date(timestamp).toLocaleTimeString('en-US', { 
        hour: '2-digit', 
        minute: '2-digit',
        hour12: false 
    });
    
    const dateStr = new Date(timestamp).toLocaleDateString('en-US', { 
        month: '2-digit',
        day: '2-digit',
        year: 'numeric'
    });
    
    // Check for recent duplicate
    const updateKey = `${boatId}-${status}-${timeStr}`;
    const lastUpdate = state.lastKnownStates.get(updateKey);
    
    if (lastUpdate && (Date.now() - lastUpdate) < 60000) {
        console.log(`Skipping duplicate: ${updateKey}`);
        return;
    }
    
    state.lastKnownStates.set(updateKey, Date.now());
    
    const tbody = document.getElementById('statusTableBody');
    const prefix = boatData.type === 1 ? 'C' : 'G';
    const paddedNumber = boatId.toString().padStart(2, '0');
    const boatName = `${prefix}${paddedNumber}`;
    
   // Map status names
const statusColumnMap = {
    'none': 'none',
    'platform-start': 'platform-start',
    'platform-complete': 'platform-complete',  // Changed from 'platform'
    'platform': 'platform-complete',  // Keep for compatibility
    'pierside-start': 'pierside-start',
    'pierside-complete': 'pierside-complete',  // Changed from 'pierside'
    'pierside': 'pierside-complete',  // Keep for compatibility
    'pretow-start': 'pretow-start',
    'pretow-complete': 'pretow-complete',  // Changed from 'pretow'
    'pretow': 'pretow-complete',  // Keep for compatibility
    'operational-start': 'operational-start',
    'operational-complete': 'operational-complete',  // Changed from 'operational'
    'operational': 'operational-complete',  // Keep for compatibility
    'trouble': 'trouble',
    'tow': 'tow',
    'transit': 'transit',
    'operational-area': 'oparea',
    'return-pier': 'return'
};
    
    const columnStatus = statusColumnMap[status] || status;
    
    // Get or create row for this boat
    let targetRow = document.querySelector(`tr[data-boat-id="${boatId}"]`);
    
    if (!targetRow) {
        // Create new row
        targetRow = createNewRow(boatId, boatName, boatData);
        
        // Insert in sorted position
        const allRows = Array.from(tbody.querySelectorAll('tr'));
        let insertBefore = null;
        
        for (const row of allRows) {
            const rowBoatId = parseInt(row.dataset.boatId);
            const rowBoat = state.boats.get(rowBoatId);
            if (rowBoat) {
                // Sort by type first (C boats before G boats), then by ID
                if (boatData.type < rowBoat.type || 
                    (boatData.type === rowBoat.type && boatId < rowBoatId)) {
                    insertBefore = row;
                    break;
                }
            }
        }
        
        if (insertBefore) {
            tbody.insertBefore(targetRow, insertBefore);
        } else {
            tbody.appendChild(targetRow);
        }
    }
    
    // Update the appropriate cell
    updateTableCell(targetRow, columnStatus, status, operator, timestamp, dateStr, timeStr);
    
    console.log(`Status recorded: ${boatName} - ${status} at ${dateStr} ${timeStr} by ${operator}`);
    
    // Send to Google Sheets
    sendToGoogleSheets(boatId, boatData, status, operator, timestamp);
}

// Create new row with split cells
function createNewRow(boatId, boatName, boatData) {
    const newRow = document.createElement('tr');
    newRow.setAttribute('data-boat-id', boatId);
    
    // Boat
    const boatCell = document.createElement('td');
    boatCell.textContent = boatName;
    newRow.appendChild(boatCell);
    
    // Group
    const groupCell = document.createElement('td');
    groupCell.textContent = boatData.userGroup === 'leg' ? 'Leg' : 'Lat';
    groupCell.style.color = boatData.userGroup === 'leg' ? '#b19cd9' : '#00bfff';
    newRow.appendChild(groupCell);
    
    // No Check
    const noneCell = document.createElement('td');
    noneCell.setAttribute('data-status', 'none');
    newRow.appendChild(noneCell);
    
    // Platform (split)
    const platformCell = document.createElement('td');
    platformCell.className = 'split-cell';
    platformCell.innerHTML = `
        <div class="split-cell-top" data-status="platform-start"></div>
        <div class="split-cell-bottom" data-status="platform-complete"></div>
    `;
    newRow.appendChild(platformCell);
    
    // Pierside (split)
    const piersideCell = document.createElement('td');
    piersideCell.className = 'split-cell';
    piersideCell.innerHTML = `
        <div class="split-cell-top" data-status="pierside-start"></div>
        <div class="split-cell-bottom" data-status="pierside-complete"></div>
    `;
    newRow.appendChild(piersideCell);
    
    // Pre-Tow (split)
    const pretowCell = document.createElement('td');
    pretowCell.className = 'split-cell';
    pretowCell.innerHTML = `
        <div class="split-cell-top" data-status="pretow-start"></div>
        <div class="split-cell-bottom" data-status="pretow-complete"></div>
    `;
    newRow.appendChild(pretowCell);
    
    // Post-Tow (split)
    const operationalCell = document.createElement('td');
    operationalCell.className = 'split-cell';
    operationalCell.innerHTML = `
        <div class="split-cell-top" data-status="operational-start"></div>
        <div class="split-cell-bottom" data-status="operational-complete"></div>
    `;
    newRow.appendChild(operationalCell);
    
    // Trouble
    const troubleCell = document.createElement('td');
    troubleCell.setAttribute('data-status', 'trouble');
    newRow.appendChild(troubleCell);
    
    // Movement statuses
    const statuses = ['tow', 'transit', 'oparea', 'return'];
    statuses.forEach(s => {
        const cell = document.createElement('td');
        cell.setAttribute('data-status', s);
        newRow.appendChild(cell);
    });
    
    return newRow;
}

// Update table cell
function updateTableCell(row, columnStatus, actualStatus, operator, timestamp, dateStr, timeStr) {
    let cell;
    
    // Find the right cell to update
    if (columnStatus.includes('-')) {
        // Split cell
        cell = row.querySelector(`[data-status="${columnStatus}"]`);
    } else {
        cell = row.querySelector(`td[data-status="${columnStatus}"]`);
    }
    
    if (!cell) return;
    
    // Determine display status for coloring
    let displayStatus = actualStatus;
    const movementStatuses = ['tow', 'transit', 'operational-area', 'return-pier'];
    if (movementStatuses.includes(actualStatus)) {
        // Use the boat's current check status for color
        const boatId = parseInt(row.dataset.boatId);
        const boatData = state.boats.get(boatId);
        displayStatus = boatData?.checkStatus || 'none';
    }
    
    // Update cell content and styling
    if (cell.classList.contains('split-cell-top') || cell.classList.contains('split-cell-bottom')) {
        cell.className = cell.className.split(' ')[0] + ` status-${actualStatus}`;
    } else {
        cell.className = `status-${displayStatus}`;
    }
    
    cell.innerHTML = `${timeStr}<br><small>${operator}</small>`;
    cell.title = `${dateStr} ${timeStr} - ${operator}`;
    cell.dataset.time = timeStr;
    cell.dataset.date = dateStr;
    cell.dataset.operator = operator;
    
    // Add context menu for manual override
    cell.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) {
            e.preventDefault();
            showCellContextMenu(e, cell);
        }
    });
}

// Create pod element with proper rotation support
function createPodElement(pod, isSmallBox = false) {
    const podDiv = document.createElement('div');
    podDiv.className = isSmallBox ? 'pod in-small-box' : 'pod';
    podDiv.dataset.podId = pod.id;
    
    if (!isSmallBox) {
        podDiv.style.position = 'absolute';
        podDiv.style.transform = `rotate(${pod.rotation || 0}deg)`;
        
        // Make pod draggable
        if (!state.isViewOnly) {
            podDiv.draggable = true;
            podDiv.addEventListener('dragstart', handlePodDragStart);
            podDiv.addEventListener('dragend', handleDragEnd);
            
            // Add rotation handle for pod
            const rotationHandle = document.createElement('div');
            rotationHandle.className = 'rotation-handle';
            rotationHandle.style.position = 'absolute';
            rotationHandle.style.top = '-15px';
            rotationHandle.style.left = '50%';
            rotationHandle.style.transform = 'translateX(-50%)';
            rotationHandle.title = 'Click and drag to rotate pod';
            podDiv.appendChild(rotationHandle);
            
            rotationHandle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                handlePodRotationStart(e, podDiv, pod.id);
            });
            
            // Context menu for pod
            podDiv.addEventListener('contextmenu', function(e) {
                if (!e.target.closest('.boat-wrapper')) {
                    e.preventDefault();
                    showPodContextMenu(e, pod.id);
                }
            });
        }
    } else {
        // Pod in small box is also draggable
        podDiv.draggable = true;
        podDiv.addEventListener('dragstart', handlePodDragStart);
        
        // Enable right-click on boats in small box pods
        setTimeout(() => {
            podDiv.querySelectorAll('.boat-wrapper').forEach(boatEl => {
                boatEl.addEventListener('contextmenu', function(e) {
                    if (!state.isViewOnly) {
                        e.preventDefault();
                        e.stopPropagation();
                        const boatId = parseInt(boatEl.id.replace('boat-wrapper-', ''));
                        showBoatInPodContextMenu(e, boatId, pod.id);
                    }
                });
            });
        }, 0);
    }
    
    // Add boats to pod
    pod.boats.forEach(boatId => {
        const boat = state.boats.get(boatId);
        if (boat) {
            const boatElement = boat.element.cloneNode(true);
            boatElement.style.position = 'relative';
            boatElement.style.left = '';
            boatElement.style.top = '';
            boatElement.classList.add('in-small-box');
            
            // Keep check status color
            const checkStatus = boat.checkStatus || boat.status;
            const boatInner = boatElement.querySelector('.boat');
            if (boatInner) {
                boatInner.className = `boat boat-type-${boat.type} status-${checkStatus}`;
            }
            
            // Remove individual boat rotation in pod
            boatElement.style.transform = '';
            
            // Hide individual rotation handles in pod
            const handle = boatElement.querySelector('.rotation-handle');
            if (handle) handle.style.display = 'none';
            
            podDiv.appendChild(boatElement);
        }
    });
    
    return podDiv;
}

// Handle pod rotation
function handlePodRotationStart(e, podElement, podId) {
    e.preventDefault();
    state.rotatingPod = { element: podElement, id: podId };
    
    const rect = podElement.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    const pod = state.pods.get(podId);
    const startAngle = pod?.rotation || 0;
    
    const mouseAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;
    
    podElement.dataset.rotationStart = startAngle;
    podElement.dataset.mouseStart = mouseAngle;
    
    document.addEventListener('mousemove', handlePodRotation);
    document.addEventListener('mouseup', handlePodRotationEnd);
}

function handlePodRotation(e) {
    if (!state.rotatingPod) return;
    
    const { element, id } = state.rotatingPod;
    const rect = element.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    const currentMouseAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;
    const mouseStart = parseFloat(element.dataset.mouseStart);
    const rotationStart = parseFloat(element.dataset.rotationStart);
    
    const angleDiff = currentMouseAngle - mouseStart;
    const newRotation = rotationStart + angleDiff;
    
    element.style.transform = `rotate(${newRotation}deg)`;
    
    // Update pod data
    const pod = state.pods.get(id);
    if (pod) {
        pod.rotation = newRotation;
        
        // Update all boats in pod
        pod.boats.forEach(boatId => {
            const boat = state.boats.get(boatId);
            if (boat) {
                boat.rotation = newRotation;
            }
        });
    }
}

function handlePodRotationEnd(e) {
    document.removeEventListener('mousemove', handlePodRotation);
    document.removeEventListener('mouseup', handlePodRotationEnd);
    
    if (state.rotatingPod) {
        // Save layout after rotation
        saveAreaLayout(state.currentDisplay);
        autoSaveState();
    }
    
    state.rotatingPod = null;
}

// Drag and Drop Handlers
function handleDragStart(e) {
    if (state.isViewOnly) return;
    
    state.draggedItem = e.target.closest('.boat-wrapper');
    if (!state.draggedItem) return;
    
    // Track where drag started from
    const parent = state.draggedItem.parentElement;
    if (parent.classList.contains('status-box-content')) {
        state.draggedFromArea = parent.closest('.status-box').dataset.area;
    } else if (parent.classList.contains('pod')) {
        // Dragging from within a pod
        const podElement = parent.closest('.pod');
        if (podElement.parentElement.classList.contains('status-box-content')) {
            state.draggedFromArea = podElement.parentElement.closest('.status-box').dataset.area;
        } else {
            state.draggedFromArea = state.currentDisplay;
        }
    } else {
        state.draggedFromArea = state.currentDisplay;
    }
    
    state.draggedItem.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    
    // Create ghost image that maintains rotation
    const ghost = state.draggedItem.cloneNode(true);
    ghost.style.position = 'absolute';
    ghost.style.top = '-1000px';
    ghost.style.transform = state.draggedItem.style.transform; // Preserve rotation
    document.body.appendChild(ghost);
    e.dataTransfer.setDragImage(ghost, e.offsetX, e.offsetY);
    
    // Clean up ghost after drag starts
    setTimeout(() => {
        document.body.removeChild(ghost);
    }, 0);
}

function handlePodDragStart(e) {
    if (state.isViewOnly) return;
    
    state.draggedItem = e.target.closest('.pod');
    if (!state.draggedItem) return;
    
    // Track where drag started from
    const parent = state.draggedItem.parentElement;
    if (parent.classList.contains('status-box-content')) {
        state.draggedFromArea = parent.closest('.status-box').dataset.area;
    } else {
        state.draggedFromArea = state.currentDisplay;
    }
    
    state.draggedItem.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    
    // Create ghost with rotation preserved
    const ghost = state.draggedItem.cloneNode(true);
    ghost.style.position = 'absolute';
    ghost.style.top = '-1000px';
    ghost.style.transform = state.draggedItem.style.transform;
    document.body.appendChild(ghost);
    e.dataTransfer.setDragImage(ghost, e.offsetX, e.offsetY);
    
    setTimeout(() => {
        document.body.removeChild(ghost);
    }, 0);
}

function handleDragEnd(e) {
    if (state.draggedItem) {
        state.draggedItem.classList.remove('dragging');
        state.draggedItem = null;
        state.draggedFromArea = null;
    }
}

function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
}

function handleDrop(e) {
    e.preventDefault();
    if (!state.draggedItem) return;
    
    const mainDisplay = document.getElementById('mainDisplay');
    const rect = mainDisplay.getBoundingClientRect();
    
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    if (state.draggedItem.classList.contains('pod')) {
        // Handle pod drop
        const podId = state.draggedItem.dataset.podId;
        const pod = state.pods.get(podId);
        if (pod) {
            pod.x = x;
            pod.y = y;
            state.draggedItem.style.left = x + 'px';
            state.draggedItem.style.top = y + 'px';
            
            // Save layout
            saveAreaLayout(state.currentDisplay);
            autoSaveState();
        }
    } else {
        // Handle boat drop
        const boatId = parseInt(state.draggedItem.id.replace('boat-wrapper-', ''));
        const boatData = state.boats.get(boatId);
        if (boatData) {
            boatData.x = x;
            boatData.y = y;
            state.draggedItem.style.left = x + 'px';
            state.draggedItem.style.top = y + 'px';
            
            // Save layout
            saveAreaLayout(state.currentDisplay);
            autoSaveState();
        }
    }
}

// Rotation handling
function handleRotationStart(e, element) {
    e.preventDefault();
    state.rotatingBoat = element;
    
    const rect = element.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    const currentRotation = element.style.transform.match(/rotate\((-?\d+(?:\.\d+)?)deg\)/);
    const startAngle = currentRotation ? parseFloat(currentRotation[1]) : 0;
    
    const mouseAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;
    
    element.dataset.rotationStart = startAngle;
    element.dataset.mouseStart = mouseAngle;
    
    document.addEventListener('mousemove', handleRotation);
    document.addEventListener('mouseup', handleRotationEnd);
}

function handleRotation(e) {
    if (!state.rotatingBoat) return;
    
    const rect = state.rotatingBoat.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    const currentMouseAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;
    const mouseStart = parseFloat(state.rotatingBoat.dataset.mouseStart);
    const rotationStart = parseFloat(state.rotatingBoat.dataset.rotationStart);
    
    const angleDiff = currentMouseAngle - mouseStart;
    const newRotation = rotationStart + angleDiff;
    
    state.rotatingBoat.style.transform = `rotate(${newRotation}deg)`;
    
    // Update boat data
    const boatId = parseInt(state.rotatingBoat.id.replace('boat-wrapper-', ''));
    const boatData = state.boats.get(boatId);
    if (boatData) {
        boatData.rotation = newRotation;
        
        // If boat is in a pod, rotate all boats in pod
        if (boatData.podId) {
            const pod = state.pods.get(boatData.podId);
            if (pod) {
                pod.rotation = newRotation;
                pod.boats.forEach(id => {
                    const boat = state.boats.get(id);
                    if (boat && boat.element !== state.rotatingBoat) {
                        boat.element.style.transform = `rotate(${newRotation}deg)`;
                        boat.rotation = newRotation;
                    }
                });
            }
        }
    }
}

function handleRotationEnd(e) {
    document.removeEventListener('mousemove', handleRotation);
    document.removeEventListener('mouseup', handleRotationEnd);
    
    if (state.rotatingBoat) {
        // Save layout after rotation
        saveAreaLayout(state.currentDisplay);
        autoSaveState();
    }
    
    state.rotatingBoat = null;
}

// Helper functions for context menus and pods

// Show pod context menu
function showPodContextMenu(e, podId) {
    const menu = document.getElementById('contextMenu');
    const pod = state.pods.get(podId);
    
    if (!pod) return;
    
    menu.innerHTML = `
        <div class="context-menu-item" style="font-weight: bold; color: #00bfff;">
            Pod Options
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'none')">
            <span class="status-indicator-menu status-none"></span>
            All No Check
        </div>
        <div class="context-menu-item has-submenu">
            <span class="status-indicator-menu status-platform"></span>
            All Platform Check ▶
            <div class="submenu" style="display: none; position: absolute; left: 100%; top: 0; background: #2a2a2a; border: 2px solid #444; border-radius: 8px; min-width: 120px;">
                <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'platform-start')">Start</div>
                <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'platform')">Complete</div>
            </div>
        </div>
        <div class="context-menu-item has-submenu">
            <span class="status-indicator-menu status-pierside"></span>
            All Pierside Check ▶
            <div class="submenu" style="display: none; position: absolute; left: 100%; top: 0; background: #2a2a2a; border: 2px solid #444; border-radius: 8px; min-width: 120px;">
                <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'pierside-start')">Start</div>
                <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'pierside')">Complete</div>
            </div>
        </div>
        <div class="context-menu-item has-submenu">
            <span class="status-indicator-menu status-pretow"></span>
            All Pre-Tow Check ▶
            <div class="submenu" style="display: none; position: absolute; left: 100%; top: 0; background: #2a2a2a; border: 2px solid #444; border-radius: 8px; min-width: 120px;">
                <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'pretow-start')">Start</div>
                <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'pretow')">Complete</div>
            </div>
        </div>
        <div class="context-menu-item has-submenu">
            <span class="status-indicator-menu status-operational"></span>
            All Post-Tow Check ▶
            <div class="submenu" style="display: none; position: absolute; left: 100%; top: 0; background: #2a2a2a; border: 2px solid #444; border-radius: 8px; min-width: 120px;">
                <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'operational-start')">Start</div>
                <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'operational')">Complete</div>
            </div>
        </div>
        <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'trouble')">
            <span class="status-indicator-menu status-trouble"></span>
            All Trouble
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'tow')">
            Being Towed
        </div>
        <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'transit')">
            In Transit
        </div>
        <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'operational-area')">
            Operational Area
        </div>
        <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'return-pier')">
            Return to Pier
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="breakUpPod('${podId}')">
            💔 Break Up Pod
        </div>
        <div class="context-menu-separator"></div>
    `;
    
    // Add boat list
    pod.boats.forEach(boatId => {
        const boat = state.boats.get(boatId);
        if (boat) {
            const prefix = boat.type === 1 ? 'C' : 'G';
            const paddedNumber = boatId.toString().padStart(2, '0');
            menu.innerHTML += `
                <div class="context-menu-item" style="padding-left: 30px; font-size: 0.85em;">
                    ${prefix}${paddedNumber} (${boat.userGroup === 'leg' ? 'Leg' : 'Lat'})
                </div>
            `;
        }
    });
    
    positionContextMenu(menu, e.pageX, e.pageY);
    setupSubmenuHover(menu);
}

// Show area context menu for creating pods
function showAreaContextMenu(e, area) {
    const menu = document.getElementById('contextMenu');
    
    // Get all boats in this area
    const areaBoats = [];
    state.boats.forEach((boat, id) => {
        if (boat.location === area && !boat.podId) {
            areaBoats.push({ id, boat });
        }
    });
    
    // Sort boats
    areaBoats.sort((a, b) => {
        if (a.boat.type !== b.boat.type) {
            return a.boat.type - b.boat.type;
        }
        return a.id - b.id;
    });
    
    let menuHTML = `
        <div class="context-menu-item" style="font-weight: bold; color: #00bfff;">
            Create Pod
        </div>
        <div class="context-menu-separator"></div>
    `;
    
    if (areaBoats.length === 0) {
        menuHTML += `<div class="context-menu-item" style="color: #666;">No boats available</div>`;
    } else {
        areaBoats.forEach(({ id, boat }) => {
            const prefix = boat.type === 1 ? 'C' : 'G';
            const paddedNumber = id.toString().padStart(2, '0');
            menuHTML += `
                <div class="context-menu-item" onclick="togglePodBoat(${id}, event)">
                    <input type="checkbox" id="pod-boat-${id}" value="${id}" style="margin-right: 5px; pointer-events: none;">
                    <label for="pod-boat-${id}" style="cursor: pointer; pointer-events: none;">
                        ${prefix}${paddedNumber} (${boat.userGroup === 'leg' ? 'Leg' : 'Lat'})
                    </label>
                </div>
            `;
        });
        
        menuHTML += `
            <div class="context-menu-separator"></div>
            <div class="context-menu-item" onclick="createPodFromSelection('${area}')" style="background: linear-gradient(45deg, #00bfff, #b19cd9); color: #fff;">
                Create Pod
            </div>
        `;
    }
    
    menu.innerHTML = menuHTML;
    positionContextMenu(menu, e.pageX, e.pageY);
}

// Position context menu properly
function positionContextMenu(menu, x, y) {
    menu.style.display = 'block';
    
    // Get viewport dimensions
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    // Get menu dimensions
    const menuRect = menu.getBoundingClientRect();
    const menuWidth = menuRect.width;
    const menuHeight = menuRect.height;
    
    // Adjust position to keep menu in viewport
    let adjustedX = x;
    let adjustedY = y;
    
    if (x + menuWidth > viewportWidth) {
        adjustedX = viewportWidth - menuWidth - 10;
    }
    
    if (y + menuHeight > viewportHeight) {
        adjustedY = viewportHeight - menuHeight - 10;
    }
    
    // Ensure menu doesn't go off the top or left
    adjustedX = Math.max(10, adjustedX);
    adjustedY = Math.max(10, adjustedY);
    
    menu.style.left = adjustedX + 'px';
    menu.style.top = adjustedY + 'px';
}

// Show context menu for manual cell override
function showCellContextMenu(e, cell) {
    const menu = document.getElementById('contextMenu');
    
    // Store reference to target cell
    menu.dataset.targetCell = cell.id || generateCellId(cell);
    if (!cell.id) {
        cell.id = menu.dataset.targetCell;
    }
    
    menu.innerHTML = `
        <div class="context-menu-item" onclick="manualOverrideCell()">
            ✏️ Manual Override
        </div>
        <div class="context-menu-item" onclick="clearCell()">
            🗑️ Clear Cell
        </div>
    `;
    
    positionContextMenu(menu, e.pageX, e.pageY);
}

// Toggle pod boat selection
function togglePodBoat(boatId, event) {
    event.stopPropagation();
    const checkbox = document.getElementById(`pod-boat-${boatId}`);
    if (checkbox) {
        checkbox.checked = !checkbox.checked;
    }
}

// Create pod from selected boats
function createPodFromSelection(area) {
    const menu = document.getElementById('contextMenu');
    const checkboxes = menu.querySelectorAll('input[type="checkbox"]:checked');
    
    if (checkboxes.length < 2) {
        alert('Please select at least 2 boats to create a pod');
        return;
    }
    
    const boatIds = Array.from(checkboxes).map(cb => parseInt(cb.value));
    createPod(boatIds, area);
    
    menu.style.display = 'none';
}

// Pod management functions
function createPod(boatIds, location) {
    const podId = 'pod_' + Date.now();
    const pod = {
        id: podId,
        boats: boatIds,
        location: location,
        rotation: 0,
        x: 20,
        y: 20
    };
    
    state.pods.set(podId, pod);
    
    // Update boats to reference pod
    boatIds.forEach(boatId => {
        const boat = state.boats.get(boatId);
        if (boat) {
            boat.podId = podId;
        }
    });
    
    updatePodCount();
    updateMainDisplay();
    updateSmallBoxes();
    
    return pod;
}

// Break up pod
function breakUpPod(podId) {
    const pod = state.pods.get(podId);
    if (!pod) return;
    
    // Remove pod reference from boats
    pod.boats.forEach(boatId => {
        const boat = state.boats.get(boatId);
        if (boat) {
            boat.podId = null;
            // Reset position for independent placement
            const pos = getNextPosition(boat.location, boat.type);
            boat.x = pos.x;
            boat.y = pos.y;
        }
    });
    
    // Delete pod
    state.pods.delete(podId);
    
    // Update displays
    updatePodCount();
    updateMainDisplay();
    updateSmallBoxes();
    
    // Hide menu
    document.getElementById('contextMenu').style.display = 'none';
}

// Manual override for status cell
window.manualOverrideCell = function() {
    const menu = document.getElementById('contextMenu');
    const cellId = menu.dataset.targetCell;
    const cell = document.getElementById(cellId);
    
    if (!cell) {
        console.error('Cell not found:', cellId);
        menu.style.display = 'none';
        return;
    }
    
    const timeInput = prompt('Enter time (HH:MM:SS) or leave blank for current time:');
    const operatorInput = prompt('Enter operator name:', localStorage.getItem('lastOperator') || '');
    
    if (operatorInput) {
        localStorage.setItem('lastOperator', operatorInput);
        
        let timestamp = new Date();
        if (timeInput) {
            const [hours, minutes, seconds] = timeInput.split(':').map(n => parseInt(n) || 0);
            timestamp.setHours(hours, minutes, seconds);
        }
        
        const timeStr = timestamp.toLocaleTimeString('en-US', { 
            hour: '2-digit', 
            minute: '2-digit',
            second: '2-digit',
            hour12: false 
        });
        
        // Update cell content
        cell.innerHTML = `${timeStr}<br><small>${operatorInput}</small>`;
        cell.title = `${timestamp.toLocaleString()} - ${operatorInput} (Manual Override)`;
        
        // Apply appropriate background based on cell type
        const statusType = cell.dataset.status || cell.parentElement.dataset.status;
        if (statusType) {
            cell.className = cell.className.split(' ')[0] + ` status-${statusType.replace('-complete', '').replace('-start', '')}`;
            if (statusType.includes('-start')) {
                cell.className += '-start';
            }
        }
    }
    
    menu.style.display = 'none';
}

// Clear cell
window.clearCell = function() {
    const menu = document.getElementById('contextMenu');
    const cellId = menu.dataset.targetCell;
    const cell = document.getElementById(cellId);
    
    if (cell && confirm('Clear this status entry?')) {
        cell.innerHTML = '';
        cell.className = cell.className.split(' ')[0]; // Keep only first class
        cell.removeAttribute('title');
    }
    
    menu.style.display = 'none';
}

// Generate unique cell ID
function generateCellId(cell) {
    const row = cell.closest('tr');
    const boatId = row.dataset.boatId || row.dataset.rowId;
    const status = cell.dataset.status || cell.parentElement.dataset.status;
    return `cell-${boatId}-${status}-${Date.now()}`;
}
// Server Communication Functions

// Update from server state
async function updateFromServerState() {
    try {
        const response = await fetch(N8N_CONFIG.stateWebhook);
        if (!response.ok) return;
        
        const serverState = await response.json();
        if (!serverState || !serverState.boats) return;
        
        console.log(`Polling update: ${serverState.boats.length} boats from server`);
        
        serverState.boats.forEach(boatData => {
            const existingBoat = state.boats.get(boatData.id);
            
            if (existingBoat) {
                // Update assignment if changed
                if (existingBoat.userGroup !== boatData.userGroup) {
                    console.log(`Updating boat ${boatData.id} assignment from ${existingBoat.userGroup} to ${boatData.userGroup}`);
                    
                    // Update the boat's assignment
                    existingBoat.userGroup = boatData.userGroup;
                    
                    // Update visual elements
                    existingBoat.element.className = `boat-wrapper user-${boatData.userGroup}`;
                    if (!existingBoat.element.classList.contains('in-small-box')) {
                        existingBoat.element.classList.remove('in-small-box');
                    }
                    
                    const indicator = existingBoat.element.querySelector('.user-indicator');
                    if (indicator) {
                        indicator.textContent = boatData.userGroup === 'leg' ? 'Leg' : 'Lat';
                    }
                    
                    // Update in all displays
                    updateSmallBoxes();
                }
                
                // Check for genuine status updates from users
                if (boatData.operator && !['Initial', 'Assignment System', 'n8n Update'].includes(boatData.operator)) {
                    const logKey = `${boatData.id}-${boatData.status}-${boatData.operator}-${boatData.lastUpdated}`;
                    
                    if (!state.statusLogHistory.has(logKey)) {
                        console.log(`Processing status update: Boat ${boatData.id} to ${boatData.status} by ${boatData.operator}`);
                        
                        // Update status and potentially move boat
                        updateBoatStatusFromServer(boatData.id, boatData.status, boatData.operator);
                        
                        state.statusLogHistory.set(logKey, true);
                        
                        // Clean old entries
                        if (state.statusLogHistory.size > 200) {
                            const entries = Array.from(state.statusLogHistory.keys());
                            entries.slice(0, 50).forEach(key => state.statusLogHistory.delete(key));
                        }
                    }
                }
                
            } else {
                // Create new boat
                console.log(`Creating new boat ${boatData.id}`);
                const newBoat = createBoat({
                    id: boatData.id,
                    type: boatData.type || 1,
                    userGroup: boatData.userGroup || 'lat',
                    status: 'none',
                    location: boatData.location || 'pier',
                    x: null,
                    y: null,
                    rotation: 0
                });
                
                // Log initial "No Check" status
                addStatusToTable(boatData.id, newBoat, 'none', 'Initial');
            }
        });
        
        // Update UI state for view-only mode
        if (state.isViewOnly) {
            loadViewOnlyState();
        }
        
        updateBoatCount();
        updateSmallBoxes();
        updateMainDisplay();
        
    } catch (error) {
        console.error('Error updating from server:', error);
    }
}

// Update boat status from server
function updateBoatStatusFromServer(boatId, newStatus, operator) {
    const boatData = state.boats.get(boatId);
    if (!boatData) return;
    
    const movementStatuses = ['tow', 'transit', 'operational-area', 'return-pier'];
    const isMovementStatus = movementStatuses.includes(newStatus);
    
    if (isMovementStatus) {
        // Movement status - move boat and keep check color
        let targetLocation = '';
        if (newStatus === 'tow') targetLocation = 'tow';
        else if (newStatus === 'transit') targetLocation = 'transit';
        else if (newStatus === 'operational-area') targetLocation = 'operational-area';
        else if (newStatus === 'return-pier') targetLocation = 'pier';
        
        if (targetLocation) {
            // Move boat (and pod if in one)
            if (boatData.podId) {
                movePodToArea(boatData.podId, targetLocation);
            } else {
                moveBoatToArea(boatId, targetLocation);
            }
            
            // Add to status table
            addStatusToTable(boatId, boatData, newStatus, operator);
        }
    } else {
        // Check status - update color but DON'T move
        boatData.status = newStatus;
        boatData.checkStatus = newStatus;
        boatData.boat.className = `boat boat-type-${boatData.type} status-${newStatus}`;
        
        // Add to status table
        addStatusToTable(boatId, boatData, newStatus, operator);
    }
}

// Load view-only state from server
async function loadViewOnlyState() {
    try {
        // Get the main state which includes UI state
        const response = await fetch(N8N_CONFIG.stateWebhook);
        if (!response.ok) return;
        
        const data = await response.json();
        
        // Apply UI state if present
        if (data.uiState) {
            applyUIState(data.uiState);
        }
        
        // Load saved layouts from localStorage as backup
        ['pier', 'tow', 'transit', 'operational-area'].forEach(area => {
            const savedLayout = localStorage.getItem(`areaLayout-${area}`);
            if (savedLayout) {
                state.areaLayouts.set(area, JSON.parse(savedLayout));
            }
            
            const savedBg = localStorage.getItem(`background-${area}`);
            if (savedBg) {
                state.areaBackgrounds.set(area, savedBg);
            }
        });
        
        // Update displays
        updateMainDisplay();
        updateSmallBoxes();
    } catch (error) {
        console.error('Error loading view-only state:', error);
    }
}

// Apply UI state from server
function applyUIState(uiState) {
    if (!uiState) return;
    
    // Apply backgrounds
    if (uiState.backgrounds) {
        Object.entries(uiState.backgrounds).forEach(([area, bgData]) => {
            state.areaBackgrounds.set(area, bgData);
            localStorage.setItem(`background-${area}`, bgData);
        });
    }
    
    // Apply layouts
    if (uiState.layouts) {
        Object.entries(uiState.layouts).forEach(([area, layout]) => {
            state.areaLayouts.set(area, layout);
            localStorage.setItem(`areaLayout-${area}`, JSON.stringify(layout));
        });
    }
    
    // Apply current display
    if (uiState.currentDisplay) {
        state.currentDisplay = uiState.currentDisplay;
        document.getElementById('mainDisplaySelect').value = uiState.currentDisplay;
    }
    
    // Apply status table
    if (uiState.statusTable) {
        document.getElementById('statusTableBody').innerHTML = uiState.statusTable;
        
        // Re-attach context menus
        document.querySelectorAll('td[data-status]').forEach(cell => {
            if (cell.innerHTML.trim() !== '') {
                cell.addEventListener('contextmenu', function(e) {
                    if (!state.isViewOnly) {
                        e.preventDefault();
                        showCellContextMenu(e, cell);
                    }
                });
            }
        });
    }
}

// Update sendStatusUpdate to include currentArea
async function sendStatusUpdate(boatId, status, operator, checkStatus, timestamp) {
    try {
        const boatData = state.boats.get(boatId);
        if (!boatData) return;
        
        // Determine current area based on display
        let currentArea = '';
        if (state.currentDisplay === 'pier') currentArea = 'pierArea';
        else if (state.currentDisplay === 'tow') currentArea = 'towArea';
        else if (state.currentDisplay === 'transit') currentArea = 'transitArea';
        else if (state.currentDisplay === 'operational-area') currentArea = 'operationalArea';
        
        await fetch(N8N_CONFIG.statusWebhook, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                boatId: boatId,
                status: status,
                location: boatData.location,
                operator: operator,
                timestamp: (timestamp || new Date()).toISOString(),
                checkStatus: checkStatus || boatData.checkStatus || boatData.status,
                isCheckStatus: !['tow', 'transit', 'operational-area', 'return-pier'].includes(status),
                currentArea: currentArea  // ADD THIS
            })
        });
    } catch (error) {
        console.error('Error sending status update:', error);
    }
}

async function sendUIStateToServer(stateData) {
    try {
        const uiState = {
            type: 'saveUIState',  // ADD THIS
            state: {  // Wrap in state object
                layouts: Object.fromEntries(state.areaLayouts),
                backgrounds: Object.fromEntries(state.areaBackgrounds),
                currentDisplay: state.currentDisplay,
                statusTable: document.getElementById('statusTableBody').innerHTML,
                timestamp: new Date().toISOString()
            }
        };
        
        // Send to n8n webhook
        await fetch(N8N_CONFIG.statusWebhook, {  // Use status webhook, not /ui-state
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(uiState)
        });
    } catch (error) {
        console.error('Error sending UI state to server:', error);
    }
}
// Send to Google Sheets
function sendToGoogleSheets(boatId, boatData, status, operator, timestamp) {
    const webhookUrl = localStorage.getItem('googleSheetsWebhook');
    if (!webhookUrl) return;
    
    const prefix = boatData.type === 1 ? 'C' : 'G';
    const boatName = `${prefix}${boatId.toString().padStart(2, '0')}`;
    
    // Comprehensive data for StatusLog
    const data = {
        timestamp: (timestamp || new Date()).toISOString(),
        boat: boatName,
        boatId: boatId,
        type: boatData.type,
        group: boatData.userGroup === 'leg' ? 'Leg' : 'Lat',
        status: status,
        checkStatus: boatData.checkStatus || 'none',
        location: boatData.location,
        operator: operator,
        x: boatData.x,
        y: boatData.y,
        rotation: boatData.rotation || 0,
        // Include movement context
        currentArea: state.currentDisplay,
        isCheckStatus: !['tow', 'transit', 'operational-area', 'return-pier'].includes(status)
    };
    
    fetch(webhookUrl, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(data)
    }).then(response => {
        console.log('Google Sheets update sent:', data);
    }).catch(err => {
        console.error('Google Sheets update failed:', err);
    });
}

async function saveUIStateToSheets() {
    const webhookUrl = localStorage.getItem('googleSheetsWebhook');
    if (!webhookUrl) return;
    
    const uiStateData = {
        type: 'uiState',
        timestamp: new Date().toISOString(),
        operator: localStorage.getItem('lastOperator') || 'System',
        layouts: JSON.stringify(Object.fromEntries(state.areaLayouts)),
        backgrounds: JSON.stringify(Object.fromEntries(state.areaBackgrounds)),
        currentDisplay: state.currentDisplay,
        statusTableHTML: document.getElementById('statusTableBody').innerHTML
    };
    
    try {
        await fetch(webhookUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(uiStateData)
        });
        console.log('UI State saved to sheets');
    } catch (error) {
        console.error('Failed to save UI state to sheets:', error);
    }
}

// Save/Load Functions

// Auto-save state
function autoSaveState() {
    const stateData = {
        boats: Array.from(state.boats.entries()).map(([id, boat]) => ({
            id: id,
            type: boat.type,
            userGroup: boat.userGroup,
            status: boat.status,
            checkStatus: boat.checkStatus,
            location: boat.location,
            x: boat.x,
            y: boat.y,
            rotation: boat.rotation,
            podId: boat.podId,
            troublePreviousStatus: boat.troublePreviousStatus
        })),
        pods: Array.from(state.pods.entries()).map(([id, pod]) => ({
            id: id,
            boats: pod.boats,
            location: pod.location,
            x: pod.x,
            y: pod.y,
            rotation: pod.rotation
        })),
        layouts: Object.fromEntries(state.areaLayouts),
        backgrounds: Object.fromEntries(state.areaBackgrounds),
        currentDisplay: state.currentDisplay,
        rowTracking: Object.fromEntries(state.rowTracking),
        troubleStatusMemory: Object.fromEntries(state.troubleStatusMemory),
        lastSaved: new Date().toISOString()
    };
    
    localStorage.setItem('boatDisplayAutoSave', JSON.stringify(stateData));
    
    // Send to server for view-only mode
    sendUIStateToServer(stateData);
}

// Save all layouts
window.saveAllLayouts = function() {
    // Save current area first
    saveAreaLayout(state.currentDisplay);
    
    // Save all data
    const data = {
        boats: Array.from(state.boats.entries()).map(([id, boat]) => ({
            id: id,
            type: boat.type,
            userGroup: boat.userGroup,
            status: boat.status,
            checkStatus: boat.checkStatus,
            location: boat.location,
            x: boat.x,
            y: boat.y,
            rotation: boat.rotation,
            podId: boat.podId,
            troublePreviousStatus: boat.troublePreviousStatus
        })),
        pods: Array.from(state.pods.entries()).map(([id, pod]) => ({
            id: id,
            boats: pod.boats,
            location: pod.location,
            x: pod.x,
            y: pod.y,
            rotation: pod.rotation
        })),
        layouts: Object.fromEntries(state.areaLayouts),
        backgrounds: Object.fromEntries(state.areaBackgrounds),
        statusTable: document.getElementById('statusTableBody').innerHTML,
        currentDisplay: state.currentDisplay
    };
    
    // Save locally
    localStorage.setItem('boatDisplayV7Complete', JSON.stringify(data));
    
    // Save to server via n8n
    sendUIStateToServer(data);
    
    // Save to Google Sheets - NEW
    saveUIStateToSheets();
    
    alert('All layouts saved and shared!');
}

// Load all layouts
window.loadAllLayouts = function() {
    // First try to load from manual save
    let saved = localStorage.getItem('boatDisplayV7Complete');
    
    // If no manual save, try auto-save
    if (!saved) {
        saved = localStorage.getItem('boatDisplayAutoSave');
    }
    
    if (saved) {
        const data = JSON.parse(saved);
        
        // Clear existing
        state.boats.clear();
        state.pods.clear();
        state.rowTracking.clear();
        state.areaLayouts.clear();
        state.areaBackgrounds.clear();
        state.troubleStatusMemory.clear();
        
        // Load boats
        if (data.boats) {
            data.boats.forEach(boatData => {
                const boat = createBoat(boatData);
                if (boat) {
                    boat.checkStatus = boatData.checkStatus;
                    boat.location = boatData.location;
                    boat.x = boatData.x;
                    boat.y = boatData.y;
                    boat.rotation = boatData.rotation;
                    boat.podId = boatData.podId;
                    boat.troublePreviousStatus = boatData.troublePreviousStatus;
                }
            });
        }
        
        // Load pods
        if (data.pods) {
            data.pods.forEach(podData => {
                state.pods.set(podData.id, podData);
            });
        }
        
        // Load layouts for all areas
        if (data.layouts) {
            Object.entries(data.layouts).forEach(([area, layout]) => {
                state.areaLayouts.set(area, layout);
                localStorage.setItem(`areaLayout-${area}`, JSON.stringify(layout));
            });
        }
        
        // Load backgrounds
        if (data.backgrounds) {
            Object.entries(data.backgrounds).forEach(([area, bgData]) => {
                state.areaBackgrounds.set(area, bgData);
                localStorage.setItem(`background-${area}`, bgData);
            });
        }
        
        // Load status table
        if (data.statusTable) {
            document.getElementById('statusTableBody').innerHTML = data.statusTable;
            
            // Re-attach context menus to cells
            document.querySelectorAll('td[data-status]').forEach(cell => {
                if (cell.innerHTML.trim() !== '') {
                    cell.addEventListener('contextmenu', function(e) {
                        if (!state.isViewOnly) {
                            e.preventDefault();
                            showCellContextMenu(e, cell);
                        }
                    });
                }
            });
        }
        
        // Load row tracking
        if (data.rowTracking) {
            Object.entries(data.rowTracking).forEach(([boatId, rowId]) => {
                state.rowTracking.set(parseInt(boatId), rowId);
            });
        }
        
        // Load trouble status memory
        if (data.troubleStatusMemory) {
            Object.entries(data.troubleStatusMemory).forEach(([boatId, status]) => {
                state.troubleStatusMemory.set(parseInt(boatId), status);
            });
        }
        
        // Set current display
        if (data.currentDisplay) {
            state.currentDisplay = data.currentDisplay;
            document.getElementById('mainDisplaySelect').value = data.currentDisplay;
        }
        
        updateBoatCount();
        updatePodCount();
        updateMainDisplay();
        updateSmallBoxes();
        
        alert('All layouts loaded successfully!');
    } else {
        alert('No saved layouts found');
    }
}
// Load saved state on startup
function loadSavedState() {
    // Try to load auto-saved state first
    const autoSaveLoaded = loadAutoSavedState();
    
    if (autoSaveLoaded) {
        console.log('Auto-saved state loaded successfully');
    } else {
        // If no auto-save, try manual save
        const manualSave = localStorage.getItem('boatDisplayV7Complete');
        if (manualSave) {
            loadAllLayouts();
        }
    }
    
    // Load webhook URL
    const webhookUrl = localStorage.getItem('googleSheetsWebhook');
    if (webhookUrl) {
        document.getElementById('webhookUrl').value = webhookUrl;
    }
    
    // Load status table if it exists
    const savedTable = localStorage.getItem('statusTableHTML');
    if (savedTable) {
        document.getElementById('statusTableBody').innerHTML = savedTable;
        
        // Re-attach context menus
        document.querySelectorAll('td[data-status], .split-cell-top, .split-cell-bottom').forEach(cell => {
            if (cell.innerHTML.trim() !== '') {
                cell.addEventListener('contextmenu', function(e) {
                    if (!state.isViewOnly) {
                        e.preventDefault();
                        showCellContextMenu(e, cell);
                    }
                });
            }
        });
    }
    
    updateBoatCount();
    updatePodCount();
    updateMainDisplay();
    updateSmallBoxes();
}

// Load auto-saved state
function loadAutoSavedState() {
    const saved = localStorage.getItem('boatDisplayAutoSave');
    if (saved) {
        try {
            const stateData = JSON.parse(saved);
            console.log('Loading auto-saved state from', stateData.lastSaved);
            
            // Clear existing
            state.boats.clear();
            state.pods.clear();
            state.areaLayouts.clear();
            state.areaBackgrounds.clear();
            state.rowTracking.clear();
            state.troubleStatusMemory.clear();
            
            // Load boats
            if (stateData.boats) {
                stateData.boats.forEach(boatData => {
                    const boat = createBoat(boatData);
                    if (boat) {
                        boat.checkStatus = boatData.checkStatus;
                        boat.location = boatData.location;
                        boat.x = boatData.x;
                        boat.y = boatData.y;
                        boat.rotation = boatData.rotation;
                        boat.podId = boatData.podId;
                        boat.troublePreviousStatus = boatData.troublePreviousStatus;
                    }
                });
            }
            
            // Load pods
            if (stateData.pods) {
                stateData.pods.forEach(podData => {
                    state.pods.set(podData.id, podData);
                });
            }
            
            // Load layouts for all areas
            if (stateData.layouts) {
                Object.entries(stateData.layouts).forEach(([area, layout]) => {
                    state.areaLayouts.set(area, layout);
                    localStorage.setItem(`areaLayout-${area}`, JSON.stringify(layout));
                });
            }
            
            // Load backgrounds
            if (stateData.backgrounds) {
                Object.entries(stateData.backgrounds).forEach(([area, bgData]) => {
                    state.areaBackgrounds.set(area, bgData);
                    localStorage.setItem(`background-${area}`, bgData);
                });
            }
            
            // Load row tracking
            if (stateData.rowTracking) {
                Object.entries(stateData.rowTracking).forEach(([boatId, rowId]) => {
                    state.rowTracking.set(parseInt(boatId), rowId);
                });
            }
            
            // Load trouble status memory
            if (stateData.troubleStatusMemory) {
                Object.entries(stateData.troubleStatusMemory).forEach(([boatId, status]) => {
                    state.troubleStatusMemory.set(parseInt(boatId), status);
                });
            }
            
            // Set current display
            if (stateData.currentDisplay) {
                state.currentDisplay = stateData.currentDisplay;
                document.getElementById('mainDisplaySelect').value = stateData.currentDisplay;
            }
            
            return true;
        } catch (error) {
            console.error('Error loading auto-saved state:', error);
            return false;
        }
    }
    return false;
}

// Save webhook URL
window.saveWebhookUrl = function() {
    const url = document.getElementById('webhookUrl').value;
    if (url) {
        localStorage.setItem('googleSheetsWebhook', url);
        alert('Google Sheets webhook URL saved!');
    }
}

// Utility Functions

// Update boat count
function updateBoatCount() {
    document.getElementById('boatCount').textContent = state.boats.size;
}

// Update pod count
function updatePodCount() {
    document.getElementById('podCount').textContent = state.pods.size;
}

// Export to CSV
window.exportToCSV = function() {
    const table = document.getElementById('statusTable');
    let csv = [];
    
    // Headers - handle colspan headers
    const header1 = [];
    const header2 = [];
    const headerRows = table.querySelectorAll('thead tr');
    
    // First header row
    headerRows[0].querySelectorAll('th').forEach(th => {
        const colspan = th.getAttribute('colspan') || 1;
        const text = th.textContent.trim();
        header1.push(text);
        for (let i = 1; i < colspan; i++) {
            header1.push(''); // Empty for merged cells
        }
    });
    
    // Second header row
    if (headerRows[1]) {
        // Add empty cells for rowspan headers
        header2.push('', '', ''); // Boat, Group, No Check
        headerRows[1].querySelectorAll('th').forEach(th => {
            header2.push(th.textContent.trim());
        });
        header2.push(''); // Trouble (rowspan)
        header2.push('', '', '', ''); // Movement columns
    }
    
    csv.push(header1.join(','));
    if (header2.length > 0) {
        csv.push(header2.join(','));
    }
    
    // Data rows
    const tbody = table.querySelector('tbody');
    tbody.querySelectorAll('tr').forEach(row => {
        const rowData = [];
        row.querySelectorAll('td').forEach(cell => {
            if (cell.classList.contains('split-cell')) {
                // Handle split cells
                const top = cell.querySelector('.split-cell-top');
                const bottom = cell.querySelector('.split-cell-bottom');
                rowData.push(top ? top.textContent.replace(/\n/g, ' ').trim() : '');
                rowData.push(bottom ? bottom.textContent.replace(/\n/g, ' ').trim() : '');
            } else {
                const text = cell.textContent.replace(/\n/g, ' ').trim();
                rowData.push(text.includes(',') ? `"${text}"` : text);
            }
        });
        csv.push(rowData.join(','));
    });
    
    // Download
    const blob = new Blob([csv.join('\n')], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `boat_status_tracking_${new Date().toISOString().split('T')[0]}.csv`;
    a.click();
    URL.revokeObjectURL(url);
}

// Clear status table
window.clearStatusTable = function() {
    if (confirm('Are you sure you want to clear the status tracking table?')) {
        document.getElementById('statusTableBody').innerHTML = '';
        state.lastKnownStates.clear();
        state.statusLogHistory.clear();
        state.rowTracking.clear();
        localStorage.removeItem('statusTableHTML');
    }
}

// Generate view-only link
window.generateViewOnlyLink = function() {
    const currentUrl = window.location.origin + window.location.pathname;
    const viewOnlyUrl = currentUrl + '?view=only';
    
    navigator.clipboard.writeText(viewOnlyUrl).then(() => {
        alert('View-only link copied to clipboard:\n' + viewOnlyUrl);
    }).catch(() => {
        prompt('View-only link:', viewOnlyUrl);
    });
}

// Reset display
window.resetStatusDisplay = function() {
    if (confirm('Are you sure you want to reset the entire display? This will remove all boats, pods, and status data.')) {
        // Export data first
        const hasData = state.boats.size > 0 || document.getElementById('statusTableBody').innerHTML.trim() !== '';
        if (hasData) {
            if (confirm('Would you like to export the status data before resetting?')) {
                exportToCSV();
            }
        }
        
        // Clear everything
        state.boats.forEach(boat => {
            if (boat.element) boat.element.remove();
        });
        state.boats.clear();
        state.pods.clear();
        state.areaLayouts.clear();
        state.areaBackgrounds.clear();
        state.lastKnownStates.clear();
        state.statusLogHistory.clear();
        state.rowTracking.clear();
        state.troubleStatusMemory.clear();
        state.nextPositions.clear();
        
        // Re-initialize next positions
        ['pier', 'tow', 'transit', 'operational-area'].forEach(area => {
            state.nextPositions.set(area, { x: 20, y: 100, rowCount: 0 });
        });
        
        document.getElementById('statusTableBody').innerHTML = '';
        document.getElementById('mainDisplay').style.backgroundImage = '';
        
        // Clear localStorage
        const keys = Object.keys(localStorage);
        keys.forEach(key => {
            if (key.startsWith('boatDisplay') || key.startsWith('areaLayout') || 
                key.startsWith('background-') || key === 'statusTableHTML') {
                localStorage.removeItem(key);
            }
        });
        
        updateBoatCount();
        updatePodCount();
        updateMainDisplay();
        updateSmallBoxes();
        
        alert('Display has been reset.');
    }
}

// Enable view-only mode
function enableViewOnlyMode() {
    // Hide controls
    document.querySelector('.controls').style.display = 'none';
    
    // Add view-only indicator
    const indicator = document.createElement('div');
    indicator.className = 'view-only-indicator';
    indicator.textContent = '👁️ VIEW ONLY MODE';
    document.querySelector('.header').appendChild(indicator);
    
    // Disable context menu
    document.addEventListener('contextmenu', e => e.preventDefault());
}

// Setup context menu
function setupContextMenu() {
    // Context menu already exists in HTML
    const menu = document.getElementById('contextMenu');
    
    // Ensure it's hidden initially
    menu.style.display = 'none';
    menu.style.position = 'fixed';
}

// Setup event listeners
function setupEventListeners() {
    // Close context menu on click
    document.addEventListener('click', function(e) {
        const menu = document.getElementById('contextMenu');
        if (!menu.contains(e.target)) {
            menu.style.display = 'none';
        }
    });
    
    // Stop polling when page is hidden
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            stopPolling();
        } else {
            startPolling();
        }
    });
    
    // Auto-save on page unload
    window.addEventListener('beforeunload', (e) => {
        autoSaveState();
        
        // Save status table separately
        const statusTable = document.getElementById('statusTableBody').innerHTML;
        if (statusTable) {
            localStorage.setItem('statusTableHTML', statusTable);
        }
    });
    
    // Auto-save periodically (every 60 seconds)
    setInterval(() => {
        autoSaveState();
        console.log('Auto-saved at', new Date().toLocaleTimeString());
    }, 60000);
    
    // Save when boat is moved
    document.addEventListener('dragend', () => {
        setTimeout(() => {
            autoSaveState();
        }, 100);
    });
    
    // Save when rotation ends
    document.addEventListener('mouseup', (e) => {
        if (state.rotatingBoat || state.rotatingPod) {
            setTimeout(() => {
                autoSaveState();
            }, 100);
        }
    });
}

// Polling functions
function startPolling() {
    updateFromServerState();
    state.pollTimer = setInterval(updateFromServerState, POLL_INTERVAL);
}

function stopPolling() {
    if (state.pollTimer) {
        clearInterval(state.pollTimer);
        state.pollTimer = null;
    }
}

// Global function references for onclick handlers
window.togglePodBoat = togglePodBoat;
window.createPodFromSelection = createPodFromSelection;
window.breakUpPod = breakUpPod;
window.clearTroubleStatus = clearTroubleStatus;

// Log initialization complete
console.log('Boat Status Display System v7 - Enhanced features initialized');
</script>

<!-- End of JavaScript -->
</body>
</html>