<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orange USV Status Display System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: #1a1a1a;
        color: #fff;
        overflow-x: auto;
        min-height: 100vh;
    }

    .container {
        max-width: 1600px;
        margin: 0 auto;
        padding: 20px;
    }

    .header {
        text-align: center;
        margin-bottom: 20px;
        padding: 15px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
    }

    .header h1 {
        font-size: 2.5em;
        margin-bottom: 5px;
        background: linear-gradient(45deg, #00bfff, #b19cd9);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
    }

    /* Main Display Controls */
    .display-controls {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 5px;
        align-items: center;
    }

    .display-controls label {
        font-weight: bold;
        color: #00bfff;
    }

    .display-controls select {
        padding: 5px 10px;
        background: #333;
        border: 1px solid #555;
        color: #fff;
        border-radius: 3px;
        cursor: pointer;
    }

    .display-controls button {
        padding: 5px 15px;
        background: linear-gradient(45deg, #00bfff, #b19cd9);
        border: none;
        border-radius: 3px;
        color: #fff;
        font-weight: bold;
        cursor: pointer;
        transition: transform 0.2s;
    }

    .display-controls button:hover {
        transform: scale(1.05);
    }

    /* Main display area */
    .main-display {
        position: relative;
        background: #2a2a2a;
        border: 2px solid #444;
        border-radius: 10px;
        min-height: 600px;
        height: 600px;
        margin-bottom: 20px;
        overflow: hidden;
        background-size: contain;
        background-position: center;
        background-repeat: no-repeat;
        cursor: default;
    }

    .main-display.draggable-area {
        cursor: crosshair;
    }

    /* Small status boxes */
    .status-boxes {
        display: flex;
        gap: 20px;
        flex-wrap: wrap;
        justify-content: center;
        margin-bottom: 20px;
    }

    .status-box {
        background: rgba(255, 255, 255, 0.05);
        border: 2px solid #444;
        border-radius: 10px;
        padding: 10px;
        min-width: 200px;
        max-width: 250px;
        flex: 1;
        position: relative;
    }

    .status-box.drag-over {
        border-color: #00bfff;
        background: rgba(0, 191, 255, 0.1);
    }

    .status-box h3 {
        color: #00bfff;
        font-size: 0.9em;
        margin-bottom: 10px;
        text-align: center;
    }

    .status-box-content {
        min-height: 80px;
        overflow: visible;
        position: relative;
        display: flex;
        flex-wrap: wrap;
        gap: 3px;
        padding: 5px;
    }

    /* Pod styles */
    .pod {
        display: inline-flex;
        flex-wrap: wrap;
        gap: 3px;
        padding: 3px;
        margin: 2px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px dashed #666;
        border-radius: 5px;
        position: relative;
        cursor: move;
    }

    .pod.selected {
        background: rgba(0, 191, 255, 0.2);
        border-color: #00bfff;
    }

    .pod.in-small-box {
        cursor: grab;
    }

    /* Legend */
    .legend {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 15px;
        margin-bottom: 20px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
        font-size: 0.85em;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 6px;
    }

    /* Boat wrapper styles */
    .legend-boat-wrapper {
        width: 16px;
        height: 32px;
        position: relative;
        padding: 2px;
        background: #fff;
        clip-path: polygon(50% 0%, 85% 15%, 95% 35%, 95% 65%, 85% 85%, 75% 100%, 25% 100%, 15% 85%, 5% 65%, 5% 35%, 15% 15%);
        display: inline-block;
    }

    .legend-boat-wrapper.user-leg {
        background: #b19cd9;
    }

    .legend-boat-wrapper.user-lat {
        background: #00bfff;
    }

    .legend-boat {
        width: 12px;
        height: 28px;
        position: relative;
        overflow: visible;
        clip-path: polygon(50% 0%, 85% 15%, 95% 35%, 95% 65%, 85% 85%, 75% 100%, 25% 100%, 15% 85%, 5% 65%, 5% 35%, 15% 15%);
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #ff0000;
    }

    /* Status colors - Complete states */
    .legend-boat.status-none { background-color: #ff0000 !important; }
    .legend-boat.status-platform { background-color: #ff8c00 !important; }
    .legend-boat.status-pierside { background-color: #ffff00 !important; }
    .legend-boat.status-pretow { 
        background: repeating-linear-gradient(
            45deg,
            #ffffff,
            #ffffff 2px,
            #00ff00 2px,
            #00ff00 4px
        ) !important;
    }
    .legend-boat.status-operational { background-color: #00ff00 !important; }
    
    /* Status colors - Start states (with grey hatching) */
    .legend-boat.status-platform-start { 
        background: repeating-linear-gradient(
            135deg,
            #ff8c00,
            #ff8c00 3px,
            #808080 3px,
            #808080 6px
        ) !important;
    }
    .legend-boat.status-pierside-start { 
        background: repeating-linear-gradient(
            135deg,
            #ffff00,
            #ffff00 3px,
            #808080 3px,
            #808080 6px
        ) !important;
    }
    
    /* Pierside Hold with X-hatch pattern */
    .legend-boat.status-pierside-hold {
        background: 
            repeating-linear-gradient(
                45deg,
                #ffff00,
                #ffff00 3px,
                #808080 3px,
                #808080 6px
            ),
            repeating-linear-gradient(
                -45deg,
                #ffff00,
                #ffff00 3px,
                #808080 3px,
                #808080 6px
            ) !important;
        background-blend-mode: multiply;
    }
    
    /* Pre-Tow Start - WHITE and GREY hatched */
    .legend-boat.status-pretow-start { 
        background: repeating-linear-gradient(
            135deg,
            #ffffff,
            #ffffff 3px,
            #808080 3px,
            #808080 6px
        ) !important;
    }
    
    .legend-boat.status-operational-start { 
        background: repeating-linear-gradient(
            135deg,
            #00ff00,
            #00ff00 3px,
            #808080 3px,
            #808080 6px
        ) !important;
    }
    
    /* Trouble status */
    .legend-boat.status-trouble { 
        background: repeating-linear-gradient(
            45deg,
            #ff0000,
            #ff0000 3px,
            #ff8c00 3px,
            #ff8c00 6px
        ) !important;
    }

    /* Boat styles */
    .boat {
        position: absolute;
        cursor: grab;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 11px;
        font-weight: bold;
        transition: all 0.3s ease;
        overflow: visible;
        clip-path: polygon(50% 0%, 85% 15%, 95% 35%, 95% 65%, 85% 85%, 75% 100%, 25% 100%, 15% 85%, 5% 65%, 5% 35%, 15% 15%);
        background-color: #ff0000;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .boat:active {
        cursor: grabbing;
    }

    /* Boat wrapper */
    .boat-wrapper {
        position: absolute;
        background: transparent;
        display: inline-block;
        cursor: grab;
    }

    .boat-wrapper:active {
        cursor: grabbing;
    }

    .boat-wrapper.in-small-box {
        position: relative !important;
        display: inline-block;
        margin: 2px;
        cursor: grab;
    }
    
    /* Ghost image for dragging */
    .boat-wrapper.dragging {
        opacity: 0.7;
        cursor: grabbing;
    }

    .boat-outline {
        position: absolute;
        top: -2px;
        left: -2px;
        right: -2px;
        bottom: -2px;
        background: #fff;
        clip-path: polygon(50% 0%, 85% 15%, 95% 35%, 95% 65%, 85% 85%, 75% 100%, 25% 100%, 15% 85%, 5% 65%, 5% 35%, 15% 15%);
        z-index: 0;
    }

    .boat-wrapper.user-leg .boat-outline {
        background: #b19cd9;
    }

    .boat-wrapper.user-lat .boat-outline {
        background: #00bfff;
    }

    /* Context Menu */
    .context-menu {
        position: fixed;
        background: #2a2a2a;
        border: 2px solid #444;
        border-radius: 8px;
        padding: 5px 0;
        display: none;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        max-height: 400px;
	max-width: 300px;
        overflow-y: auto;
    }

    .context-menu-item {
        padding: 8px 20px;
        cursor: pointer;
        color: #fff;
        font-size: 0.9em;
        transition: background 0.2s;
        display: flex;
        align-items: center;
        gap: 8px;
        white-space: nowrap;
    }

    .context-menu-item:hover {
        background: rgba(0, 191, 255, 0.2);
    }
    
    .context-menu-item.has-submenu {
        padding-right: 30px;
        position: relative;
    }
    
    .context-menu-item.has-submenu .submenu {
    min-width: 150px;
    max-height: 300px;
    overflow-y: auto;
    }	

    .context-menu-item.has-submenu::after {
        content: '▶';
        position: absolute;
        right: 10px;
        opacity: 0.6;
    }

    /* Ensure submenu is always visible when hovered */
    .context-menu-item.has-submenu:hover .submenu {
    display: block !important;
    opacity: 1;
    pointer-events: all;
    }    

    .context-menu-separator {
        height: 1px;
        background: #444;
        margin: 5px 0;
    }
</style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Orange USV Status Display System</h1>
            <p>Capstone Aug 2025</p>
        </div>
<div class="legend">
            <div class="legend-item">
                <div class="legend-boat-wrapper">
                    <div class="legend-boat status-none">
                        <span class="boat-number">C</span>
                    </div>
                </div>
                <span>C Boat</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper">
                    <div class="legend-boat status-none">
                        <span class="boat-number">G</span>
                    </div>
                </div>
                <span>G Boat</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper">
                    <div class="legend-boat status-none"></div>
                </div>
                <span>No Check</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper">
                    <div class="legend-boat status-platform-start"></div>
                </div>
                <span>Platform Start</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper">
                    <div class="legend-boat status-platform"></div>
                </div>
                <span>Platform Complete</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper">
                    <div class="legend-boat status-pierside-start"></div>
                </div>
                <span>Pierside Start</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper">
                    <div class="legend-boat status-pierside-hold"></div>
                </div>
                <span>Pierside Hold</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper">
                    <div class="legend-boat status-pierside"></div>
                </div>
                <span>Pierside Complete</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper">
                    <div class="legend-boat status-pretow-start"></div>
                </div>
                <span>Pre-Tow Start</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper">
                    <div class="legend-boat status-pretow"></div>
                </div>
                <span>Pre-Tow Complete</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper">
                    <div class="legend-boat status-operational-start"></div>
                </div>
                <span>Post-Tow Start</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper">
                    <div class="legend-boat status-operational"></div>
                </div>
                <span>Post-Tow Complete</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper">
                    <div class="legend-boat status-trouble"></div>
                </div>
                <span>Trouble</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper user-leg">
                    <div class="legend-boat"></div>
                    <div class="user-indicator">Leg</div>
                </div>
                <span>Leg</span>
            </div>
            <div class="legend-item">
                <div class="legend-boat-wrapper user-lat">
                    <div class="legend-boat"></div>
                    <div class="user-indicator">Lat</div>
                </div>
                <span>Lat</span>
            </div>
            <div class="legend-item">
                <div class="pod" style="position: relative; display: inline-block; padding: 2px;">
                    <div style="width: 10px; height: 20px; background: #666; margin: 1px;"></div>
                    <div style="width: 10px; height: 20px; background: #666; margin: 1px;"></div>
                </div>
                <span>Pod (grouped boats)</span>
            </div>
        </div>
    <!-- Main Display Controls -->
    <div class="display-controls">
        <label>Main Display:</label>
        <select id="mainDisplaySelect">
            <option value="pier">Pier Area</option>
            <option value="tow">Being Towed</option>
            <option value="transit">In Transit</option>
            <option value="operational-area">Operational Area</option>
        </select>
        <input type="file" id="bgImageInput" accept="image/*" style="display: none;">
        <button onclick="document.getElementById('bgImageInput').click()">Set Background for This Display</button>
        <button onclick="clearBackground()">Clear Background</button>
    </div>

    <!-- Main Display Area -->
    <div class="main-display draggable-area" id="mainDisplay">
        <!-- Boats will be dynamically displayed here -->
    </div>

    <!-- Small Status Boxes -->
    <div class="status-boxes">
        <div class="status-box" data-area="pier">
            <h3>At Pier</h3>
            <div class="status-box-content" id="pierSmallBox"></div>
        </div>
        <div class="status-box" data-area="tow">
            <h3>Being Towed</h3>
            <div class="status-box-content" id="towSmallBox"></div>
        </div>
        <div class="status-box" data-area="transit">
            <h3>In Transit</h3>
            <div class="status-box-content" id="transitSmallBox"></div>
        </div>
        <div class="status-box" data-area="operational-area">
            <h3>Operational Area</h3>
            <div class="status-box-content" id="operationalAreaSmallBox"></div>
        </div>
    </div>

    <div class="controls">
        <button onclick="saveAllLayouts()">Save All</button>
        <button onclick="loadAllLayouts()">Load All</button>
        <button onclick="exportToCSV()">Export Status Log</button>
        <button onclick="generateViewOnlyLink()">Generate View-Only Link</button>
        <button onclick="window.resetStatusDisplay()" style="background: linear-gradient(45deg, #ff6b6b, #ff5252);">Reset Display</button>
        <div class="boat-count">
            Total Boats: <span id="boatCount">0</span> | 
            Total Pods: <span id="podCount">0</span>
        </div>
    </div>

    <div class="status-tracker">
        <h2>Status Tracking</h2>
        <div class="table-container">
            <table id="statusTable">
                <thead>
                    <tr>
                        <th rowspan="2">Boat</th>
                        <th rowspan="2">Group</th>
                        <th rowspan="2">No Check</th>
                        <th colspan="2">Platform</th>
                        <th colspan="3">Pierside</th>
                        <th colspan="2">Pre-Tow</th>
                        <th colspan="2">Post-Tow</th>
                        <th rowspan="2">Trouble</th>
                        <th rowspan="2">Towed</th>
                        <th rowspan="2">Transit</th>
                        <th rowspan="2">Op Area</th>
                        <th rowspan="2">Return</th>
                    </tr>
                    <tr>
                        <th>Start</th>
                        <th>Done</th>
                        <th>Start</th>
                        <th>Hold</th>
                        <th>Done</th>
                        <th>Start</th>
                        <th>Done</th>
                        <th>Start</th>
                        <th>Done</th>
                    </tr>
                </thead>
                <tbody id="statusTableBody">
                </tbody>
            </table>
        </div>
        <div class="table-controls">
            <button onclick="exportToCSV()">Export to CSV</button>
            <button onclick="clearStatusTable()">Clear Table</button>
            <div class="google-sheets-info">
                <p>Google Sheets Integration:</p>
                <input type="text" id="webhookUrl" placeholder="Google Sheets webhook URL" />
                <button onclick="saveWebhookUrl()">Save URL</button>
            </div>
        </div>
    </div>
</div>

<!-- Context Menu (hidden by default) -->
<div class="context-menu" id="contextMenu" style="display: none; position: fixed;"></div>

<!-- Manual override dialog styles -->
<style>
    .manual-override-dialog {
        position: fixed;
        background: #2a2a2a;
        border: 2px solid #444;
        border-radius: 8px;
        padding: 15px;
        z-index: 10000;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    }
    
    /* Additional CSS for status tracking table */
    .status-tracker {
        margin-top: 30px;
        padding: 20px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
    }

    .status-tracker h2 {
        color: #00bfff;
        margin-bottom: 20px;
        text-align: center;
    }

    .table-container {
        overflow-x: auto;
        margin-bottom: 20px;
        max-height: 400px;
        overflow-y: auto;
        position: relative;
    }

    table {
        width: 100%;
        border-collapse: collapse;
        background: rgba(0, 0, 0, 0.3);
    }

    thead {
        position: sticky;
        top: 0;
        z-index: 10;
        background: #1a1a1a;
    }

    th {
        padding: 8px;
        border: 1px solid #444;
        text-align: center;
        background: rgba(0, 191, 255, 0.2);
        color: #00bfff;
        position: sticky;
        top: 0;
        z-index: 10;
        white-space: nowrap;
    }

    td {
        padding: 8px;
        border: 1px solid #444;
        text-align: center;
        color: #000 !important;
        font-size: 0.85em;
        line-height: 1.2;
        font-weight: bold;
        text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
        vertical-align: middle;
        height: 40px;
    }

    /* All boat status classes */
    .status-none { background-color: #ff0000 !important; }
    .status-platform { background-color: #ff8c00 !important; }
    .status-pierside { background-color: #ffff00 !important; }
    .status-pretow { 
        background: repeating-linear-gradient(
            45deg,
            #ffffff,
            #ffffff 3px,
            #00ff00 3px,
            #00ff00 6px
        ) !important;
    }
    .status-operational { background-color: #00ff00 !important; }
    
    .status-platform-start { 
        background: repeating-linear-gradient(
            135deg,
            #ff8c00,
            #ff8c00 3px,
            #808080 3px,
            #808080 6px
        ) !important;
    }
    .status-pierside-start { 
        background: repeating-linear-gradient(
            135deg,
            #ffff00,
            #ffff00 3px,
            #808080 3px,
            #808080 6px
        ) !important;
    }
    
    .status-pierside-hold {
        background: 
            repeating-linear-gradient(
                45deg,
                #ffff00,
                #ffff00 3px,
                #808080 3px,
                #808080 6px
            ),
            repeating-linear-gradient(
                -45deg,
                #ffff00,
                #ffff00 3px,
                #808080 3px,
                #808080 6px
            ) !important;
        background-blend-mode: multiply;
    }
    
    .status-pretow-start { 
        background: repeating-linear-gradient(
            135deg,
            #ffffff,
            #ffffff 3px,
            #808080 3px,
            #808080 6px
        ) !important;
    }
    
    .status-operational-start {
        background: repeating-linear-gradient(
            135deg,
            #00ff00,
            #00ff00 3px,
            #808080 3px,
            #808080 6px
        ) !important;
    }
    
    .status-trouble {
        background: repeating-linear-gradient(
            45deg,
            #ff0000,
            #ff0000 3px,
            #ff8c00 3px,
            #ff8c00 6px
        ) !important;
    }

    /* Additional boat styles */
    .boat-type-1 {
        width: 30px;
        height: 60px;
    }

    .boat-type-2 {
        width: 26px;
        height: 44px;
    }

    .boat:hover {
        transform: scale(1.1);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    }

    .boat-number {
        background: rgba(255, 255, 255, 0.9);
        color: #000;
        padding: 2px 3px;
        border-radius: 3px;
        font-size: 10px;
        font-weight: bold;
        z-index: 2;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        white-space: nowrap;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
    }

    .user-indicator {
        position: absolute;
        bottom: 3px;
        right: 3px;
        width: 14px;
        height: 14px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 9px;
        font-weight: bold;
        color: #fff;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        z-index: 3;
    }

    .user-leg .user-indicator {
        background-color: #b19cd9;
    }

    .user-lat .user-indicator {
        background-color: #00bfff;
    }

    /* Rotation handle */
    .rotation-handle {
        position: absolute;
        top: -15px;
        left: 50%;
        transform: translateX(-50%);
        width: 12px;
        height: 12px;
        background: rgba(255, 255, 255, 0.9);
        border: 2px solid #333;
        border-radius: 50%;
        cursor: grab;
        opacity: 0;
        transition: opacity 0.3s ease;
        z-index: 10;
        pointer-events: all;
    }

    .boat-wrapper:hover .rotation-handle {
        opacity: 1;
    }

    .rotation-handle:hover {
        background: #fff;
        transform: translateX(-50%) scale(1.2);
    }

    .rotation-handle:active {
        cursor: grabbing;
    }

    .boat-wrapper.in-small-box .rotation-handle {
        display: none;
    }
</style>
<script>
// Global state management - Version 14 Fixed
const state = {
    boats: new Map(),
    pods: new Map(),
    currentDisplay: 'pier',
    areaLayouts: new Map(),
    areaBackgrounds: new Map(),
    draggedItem: null,
    draggedFromArea: null,
    rotatingBoat: null,
    rotatingPod: null,
    selectedPod: null,
    isViewOnly: false,
    pollTimer: null,
    lastKnownStates: new Map(),
    statusLogHistory: new Map(),
    rowTracking: new Map(),
    troubleStatusMemory: new Map(),
    nextPositions: new Map()
};

// Constants
const N8N_CONFIG = {
    assignmentWebhook: 'https://tacticalleadingedge.app.n8n.cloud/webhook/boat-assignments',
    statusWebhook: 'https://tacticalleadingedge.app.n8n.cloud/webhook/boat-status-update',
    stateWebhook: 'https://tacticalleadingedge.app.n8n.cloud/webhook/boat-state'
};

const POLL_INTERVAL = 30000;
const BOAT_SPACING = {
    horizontal: 40,
    vertical: 75,
    podSpacing: 6.5
};
// Initialize
document.addEventListener('DOMContentLoaded', function() {
    initializeSystem();
});
function initializeSystem() {
// Check view-only mode
const urlParams = new URLSearchParams(window.location.search);
state.isViewOnly = urlParams.get('view') === 'only';
if (state.isViewOnly) {
    enableViewOnlyMode();
    loadViewOnlyState();
} else {
    // For non-view-only, also load shared state
    loadSharedState();
}

// Initialize displays
setupMainDisplay();
setupContextMenu();
setupEventListeners();
setupSmallBoxDragDrop();
setupBackgroundUpload();

// Initialize next positions for each area
['pier', 'tow', 'transit', 'operational-area'].forEach(area => {
    state.nextPositions.set(area, { x: 20, y: 100, rowCount: 0 });
});

// Load saved state
loadSavedState();

// Start polling
startPolling();

console.log('✅ Orange USV Status Display System initialized v14');
}
// Load shared state for follow-on displays
async function loadSharedState() {
try {
const response = await fetch(N8N_CONFIG.stateWebhook);
if (!response.ok) return;
    const serverState = await response.json();
    if (serverState && serverState.uiState) {
        applyUIState(serverState.uiState);
    }
} catch (error) {
    console.error('Error loading shared state:', error);
}
}
// Load view-only state from server
async function loadViewOnlyState() {
try {
const response = await fetch(N8N_CONFIG.stateWebhook);
if (!response.ok) return;
    const serverState = await response.json();
    
    if (serverState && serverState.uiState) {
        applyUIState(serverState.uiState);
    }
    
    updateMainDisplay();
    
} catch (error) {
    console.error('Error loading view-only state:', error);
}
}
// Apply UI state from server
function applyUIState(uiState) {
if (!uiState) return;
try {
    // Parse and apply layouts
    if (uiState.layouts) {
        let layouts = uiState.layouts;
        if (typeof layouts === 'string') {
            layouts = JSON.parse(layouts);
        }
        Object.entries(layouts).forEach(([area, layout]) => {
            state.areaLayouts.set(area, layout);
            localStorage.setItem(`areaLayout-${area}`, JSON.stringify(layout));
        });
    }
    
    // Parse and apply backgrounds
    if (uiState.backgrounds) {
        let backgrounds = uiState.backgrounds;
        if (typeof backgrounds === 'string') {
            backgrounds = JSON.parse(backgrounds);
        }
        Object.entries(backgrounds).forEach(([area, bgData]) => {
            state.areaBackgrounds.set(area, bgData);
            localStorage.setItem(`background-${area}`, bgData);
        });
    }
    
    // Parse and apply boat states
    if (uiState.boatStates) {
        let boatStates = uiState.boatStates;
        if (typeof boatStates === 'string') {
            boatStates = JSON.parse(boatStates);
        }
        Object.entries(boatStates).forEach(([id, boatState]) => {
            const boat = state.boats.get(parseInt(id));
            if (boat) {
                boat.x = boatState.x;
                boat.y = boatState.y;
                boat.rotation = boatState.rotation;
                boat.location = boatState.location;
                boat.checkStatus = boatState.checkStatus;
                boat.status = boatState.status;
                boat.podId = boatState.podId;
            }
        });
    }
    
    // Parse and apply pod states
    if (uiState.podStates) {
        let podStates = uiState.podStates;
        if (typeof podStates === 'string') {
            podStates = JSON.parse(podStates);
        }
        if (Array.isArray(podStates)) {
            podStates.forEach(([id, pod]) => {
                state.pods.set(id, pod);
            });
        }
    }
    
    // Apply current display
    if (uiState.currentDisplay) {
        state.currentDisplay = uiState.currentDisplay;
        document.getElementById('mainDisplaySelect').value = state.currentDisplay;
    }
    
    // Note: We're NOT loading statusTable HTML anymore to avoid size issues
    
} catch (error) {
    console.error('Error applying UI state:', error);
}
}
// Setup background upload
function setupBackgroundUpload() {
const input = document.getElementById('bgImageInput');
input.addEventListener('change', function(e) {
const file = e.target.files[0];
if (file) {
const reader = new FileReader();
reader.onload = function(e) {
const bgData = e.target.result;
state.areaBackgrounds.set(state.currentDisplay, bgData);
localStorage.setItem(`background-${state.currentDisplay}`, bgData);
document.getElementById('mainDisplay').style.backgroundImage = `url(${bgData})`;
autoSaveState();
};
reader.readAsDataURL(file);
}
});
}
// Clear background for current display
function clearBackground() {
state.areaBackgrounds.delete(state.currentDisplay);
localStorage.removeItem(`background-${state.currentDisplay}`);
document.getElementById('mainDisplay').style.backgroundImage = '';
autoSaveState();
}
// Get next available position for boat placement
function getNextPosition(area, boatType = 1) {
const pos = state.nextPositions.get(area) || { x: 20, y: 100, rowCount: 0 };
const mainDisplay = document.getElementById('mainDisplay');
const maxWidth = mainDisplay ? mainDisplay.offsetWidth : 1200;
const boatWidth = (boatType === 1 ? 30 : 26) + BOAT_SPACING.horizontal;

if (pos.x + boatWidth > maxWidth - 20) {
    pos.x = 20;
    pos.y += BOAT_SPACING.vertical;
    pos.rowCount = 0;
}

const returnPos = { x: pos.x, y: pos.y };

pos.x += boatWidth;
pos.rowCount++;

state.nextPositions.set(area, pos);

return returnPos;
}
// Setup context menu
function setupContextMenu() {
const menu = document.getElementById('contextMenu');
menu.style.display = 'none';
menu.style.position = 'fixed';
}
// Setup event listeners
function setupEventListeners() {
// Close context menu on click
document.addEventListener('click', function(e) {
const menu = document.getElementById('contextMenu');
if (!menu.contains(e.target)) {
menu.style.display = 'none';
}
});
// Stop polling when page is hidden
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        stopPolling();
    } else {
        startPolling();
    }
});

// Auto-save on page unload
window.addEventListener('beforeunload', (e) => {
    autoSaveState();
});

// Auto-save periodically (every 60 seconds)
setInterval(() => {
    autoSaveState();
    console.log('Auto-saved at', new Date().toLocaleTimeString());
}, 60000);

// Save when boat is moved
document.addEventListener('dragend', () => {
    setTimeout(() => {
        autoSaveState();
    }, 100);
});

// Save when rotation ends
document.addEventListener('mouseup', (e) => {
    if (state.rotatingBoat || state.rotatingPod) {
        setTimeout(() => {
            autoSaveState();
        }, 100);
    }
});
}
// Polling functions
function startPolling() {
updateFromServerState();
state.pollTimer = setInterval(updateFromServerState, POLL_INTERVAL);
}
function stopPolling() {
if (state.pollTimer) {
clearInterval(state.pollTimer);
state.pollTimer = null;
}
}
// Enable view-only mode
function enableViewOnlyMode() {
document.querySelector('.controls').style.display = 'none';
const indicator = document.createElement('div');
indicator.className = 'view-only-indicator';
indicator.textContent = '👁️ VIEW ONLY MODE';
indicator.style.cssText = `
    background: rgba(255, 165, 0, 0.2);
    border: 2px solid orange;
    padding: 10px;
    margin-top: 10px;
    border-radius: 5px;
    text-align: center;
    font-weight: bold;
`;
document.querySelector('.header').appendChild(indicator);

document.addEventListener('contextmenu', e => e.preventDefault());
}
// Utility Functions
function updateBoatCount() {
document.getElementById('boatCount').textContent = state.boats.size;
}
function updatePodCount() {
document.getElementById('podCount').textContent = state.pods.size;
}
// Generate unique cell ID
function generateCellId(cell) {
const row = cell.closest('tr');
const boatId = row.dataset.boatId || row.dataset.rowId;
const status = cell.dataset.status || cell.parentElement.dataset.status;
return `cell-${boatId}-${status}-${Date.now()}`;
}
// Helper function to extract text from cell
function extractCellText(cell) {
if (!cell) return '';
const html = cell.innerHTML;
const match = html.match(/([0-9]{2}:[0-9]{2})<br><small>([^<]+)<\/small>/);
if (match) {
    return `${match[1]} - ${match[2]}`;
}

return cell.textContent.replace(/\n/g, ' ').trim();
}
// Setup drag and drop for small boxes
function setupSmallBoxDragDrop() {
const statusBoxes = document.querySelectorAll('.status-box');
statusBoxes.forEach(box => {
    const content = box.querySelector('.status-box-content');
    
    content.addEventListener('dragover', (e) => {
        e.preventDefault();
        box.classList.add('drag-over');
    });
    
    content.addEventListener('dragleave', () => {
        box.classList.remove('drag-over');
    });
    
    content.addEventListener('drop', (e) => {
        e.preventDefault();
        box.classList.remove('drag-over');
        
        const targetArea = box.dataset.area;
        handleSmallBoxDrop(e, targetArea);
    });
});
}
// Handle drop in small box
function handleSmallBoxDrop(e, targetArea) {
if (!state.draggedItem) return;
if (state.draggedItem.classList.contains('boat-wrapper')) {
    const boatId = parseInt(state.draggedItem.id.replace('boat-wrapper-', ''));
    const boat = state.boats.get(boatId);
    
    if (boat) {
        moveBoatToArea(boatId, targetArea);
        
        const movementMap = {
            'tow': 'tow',
            'transit': 'transit',
            'operational-area': 'operational-area',
            'pier': 'return-pier'
        };
        
        if (movementMap[targetArea] && state.draggedFromArea !== targetArea) {
            const operator = localStorage.getItem('lastOperator') || 'Manual Drag';
            const preservedCheckStatus = boat.checkStatus || boat.status;
            updateBoatStatus(boatId, movementMap[targetArea], operator);
            // Restore check status color
            boat.checkStatus = preservedCheckStatus;
            if (boat.boat) {
                boat.boat.className = `boat boat-type-${boat.type} status-${preservedCheckStatus}`;
            }
        }
    }
} else if (state.draggedItem.classList.contains('pod')) {
    const podId = state.draggedItem.dataset.podId;
    const pod = state.pods.get(podId);
    
    if (pod) {
        movePodToArea(podId, targetArea);
        
        const movementMap = {
            'tow': 'tow',
            'transit': 'transit',
            'operational-area': 'operational-area',
            'pier': 'return-pier'
        };
        
        if (movementMap[targetArea] && state.draggedFromArea !== targetArea) {
            const operator = localStorage.getItem('lastOperator') || 'Manual Drag';
            pod.boats.forEach(boatId => {
                const boat = state.boats.get(boatId);
                if (boat) {
                    const preservedCheckStatus = boat.checkStatus || boat.status;
                    updateBoatStatus(boatId, movementMap[targetArea], operator);
                    boat.checkStatus = preservedCheckStatus;
                    if (boat.boat) {
                        boat.boat.className = `boat boat-type-${boat.type} status-${preservedCheckStatus}`;
                    }
                }
            });
        }
    }
}
}
// Move pod to area
function movePodToArea(podId, area) {
const pod = state.pods.get(podId);
if (!pod) return;
pod.location = area;

pod.boats.forEach(boatId => {
    const boat = state.boats.get(boatId);
    if (boat) {
        boat.location = area;
    }
});

updateMainDisplay();
updateSmallBoxes();
}
// Main display management
function setupMainDisplay() {
const mainDisplay = document.getElementById('mainDisplay');
const displaySelect = document.getElementById('mainDisplaySelect');
displaySelect.addEventListener('change', function() {
    saveAreaLayout(state.currentDisplay);
    state.currentDisplay = this.value;
    updateMainDisplay();
});

mainDisplay.addEventListener('dragover', handleDragOver);
mainDisplay.addEventListener('drop', handleDrop);

mainDisplay.addEventListener('contextmenu', function(e) {
    if (!state.isViewOnly) {
        e.preventDefault();
        
        const boatWrapper = e.target.closest('.boat-wrapper');
        const podElement = e.target.closest('.pod');
        
        if (boatWrapper && podElement) {
            const boatId = parseInt(boatWrapper.id.replace('boat-wrapper-', ''));
            showBoatInPodContextMenu(e, boatId, podElement.dataset.podId);
        } else if (podElement) {
            showPodContextMenu(e, podElement.dataset.podId);
        } else if (boatWrapper) {
            const boatId = parseInt(boatWrapper.id.replace('boat-wrapper-', ''));
            showBoatContextMenu(e, boatId);
        } else {
            showAreaContextMenu(e, state.currentDisplay);
        }
    }
});
}
// Save layout for specific area
function saveAreaLayout(area) {
    const layout = {
        boats: [],
        pods: []
    };
state.boats.forEach((boat, id) => {
    if (boat.location === area && !boat.podId) {
        layout.boats.push({
            id: id,
            x: boat.x || 0,
            y: boat.y || 0,
            rotation: boat.rotation || 0
        });
    }
});

state.pods.forEach((pod, id) => {
    if (pod.location === area) {
        layout.pods.push({
            id: id,
            x: pod.x || 0,
            y: pod.y || 0,
            rotation: pod.rotation || 0
        });
    }
});

state.areaLayouts.set(area, layout);
localStorage.setItem(`areaLayout-${area}`, JSON.stringify(layout));
}
// Update main display
function updateMainDisplay() {
const mainDisplay = document.getElementById('mainDisplay');
mainDisplay.innerHTML = '';
mainDisplay.classList.add('draggable-area');

const areaBackground = state.areaBackgrounds.get(state.currentDisplay) || 
                      localStorage.getItem(`background-${state.currentDisplay}`);

if (areaBackground) {
    mainDisplay.style.backgroundImage = `url(${areaBackground})`;
    state.areaBackgrounds.set(state.currentDisplay, areaBackground);
} else {
    mainDisplay.style.backgroundImage = '';
}

displayAreaContent(state.currentDisplay);
}
// Display content for an area with proper layout loading
function displayAreaContent(area) {
const mainDisplay = document.getElementById('mainDisplay');
const savedLayout = state.areaLayouts.get(area) || 
                   JSON.parse(localStorage.getItem(`areaLayout-${area}`) || 'null');

const boatsInArea = [];
const podsInArea = [];

state.boats.forEach((boat, id) => {
    if (boat.location === area && !boat.podId) {
        boatsInArea.push(boat);
    }
});

state.pods.forEach((pod, id) => {
    if (pod.location === area) {
        podsInArea.push(pod);
    }
});

boatsInArea.sort((a, b) => {
    if (a.userGroup !== b.userGroup) {
        return a.userGroup === 'lat' ? -1 : 1;
    }
    if (a.type !== b.type) return a.type - b.type;
    return a.id - b.id;
});

// Display pods first
podsInArea.forEach(pod => {
    const podElement = createPodElement(pod);
    podElement.style.position = 'absolute';
    
    if (savedLayout && savedLayout.pods) {
        const savedPod = savedLayout.pods.find(p => p.id === pod.id);
        if (savedPod) {
            pod.x = savedPod.x;
            pod.y = savedPod.y;
            pod.rotation = savedPod.rotation || 0;
        }
    }
    
    if (pod.x === undefined || pod.x === null) {
        const pos = getNextPosition(area);
        pod.x = pos.x;
        pod.y = pos.y;
    }
    
    podElement.style.left = pod.x + 'px';
    podElement.style.top = pod.y + 'px';
    podElement.style.transform = `rotate(${pod.rotation || 0}deg)`;
    
    podElement.querySelectorAll('.boat-wrapper').forEach(boatEl => {
        boatEl.addEventListener('contextmenu', function(e) {
            if (!state.isViewOnly) {
                e.preventDefault();
                e.stopPropagation();
                const boatId = parseInt(boatEl.id.replace('boat-wrapper-', ''));
                showBoatInPodContextMenu(e, boatId, pod.id);
            }
        });
    });
    
    mainDisplay.appendChild(podElement);
});

// Display individual boats
boatsInArea.forEach(boat => {
    const boatElement = boat.element;
    if (!boatElement) {
        console.warn(`Boat ${boat.id} has no element`);
        return;
    }
    
    boatElement.classList.remove('in-small-box');
    boatElement.style.position = 'absolute';
    
    let positioned = false;
    
    if (savedLayout && savedLayout.boats) {
        const savedBoat = savedLayout.boats.find(b => b.id === boat.id);
        if (savedBoat && savedBoat.x !== undefined && savedBoat.y !== undefined) {
            boat.x = savedBoat.x;
            boat.y = savedBoat.y;
            boat.rotation = savedBoat.rotation || 0;
            boatElement.style.left = savedBoat.x + 'px';
            boatElement.style.top = savedBoat.y + 'px';
            boatElement.style.transform = `rotate(${savedBoat.rotation || 0}deg)`;
            positioned = true;
        }
    }
    
    if (!positioned && (boat.x === undefined || boat.x === null)) {
        const pos = getNextPosition(area, boat.type);
        boat.x = pos.x;
        boat.y = pos.y;
        boat.rotation = 0;
    }
    
    if (!positioned) {
        boatElement.style.left = (boat.x || 20) + 'px';
        boatElement.style.top = (boat.y || 100) + 'px';
        boatElement.style.transform = `rotate(${boat.rotation || 0}deg)`;
    }
    
    mainDisplay.appendChild(boatElement);
});
}
// Move boat to area
function moveBoatToArea(boatId, area) {
const boatData = state.boats.get(boatId);
if (!boatData) return;
boatData.location = area;
boatData.x = null;
boatData.y = null;

updateMainDisplay();
updateSmallBoxes();
}
// Update small boxes
function updateSmallBoxes() {
const areas = ['pier', 'tow', 'transit', 'operational-area'];
areas.forEach(area => {
    let smallBoxId;
    if (area === 'operational-area') {
        smallBoxId = 'operationalAreaSmallBox';
    } else {
        smallBoxId = area + 'SmallBox';
    }
    
    const smallBox = document.getElementById(smallBoxId);
    if (!smallBox) {
        console.warn(`Small box not found for area: ${area} (looked for ${smallBoxId})`);
        return;
    }
    
    smallBox.innerHTML = '';
    
    const podsInArea = [];
    const boatsInArea = [];
    
    state.pods.forEach(pod => {
        if (pod.location === area) {
            podsInArea.push(pod);
        }
    });
    
    state.boats.forEach((boat, id) => {
        if (boat.location === area && !boat.podId) {
            boatsInArea.push({ id, boat });
        }
    });
    
    boatsInArea.sort((a, b) => {
        if (a.boat.userGroup !== b.boat.userGroup) {
            return a.boat.userGroup === 'lat' ? -1 : 1;
        }
        if (a.boat.type !== b.boat.type) {
            return a.boat.type - b.boat.type;
        }
        return a.id - b.id;
    });
    
    podsInArea.forEach(pod => {
        const podElement = createPodElement(pod, true);
        smallBox.appendChild(podElement);
    });
    
    boatsInArea.forEach(({ id, boat }) => {
        const boatElement = boat.element.cloneNode(true);
        boatElement.classList.add('in-small-box');
        boatElement.style.position = 'relative';
        boatElement.style.left = '';
        boatElement.style.top = '';
        boatElement.style.transform = '';
        
        const checkStatus = boat.checkStatus || boat.status;
        const boatInner = boatElement.querySelector('.boat');
        if (boatInner) {
            boatInner.className = `boat boat-type-${boat.type} status-${checkStatus}`;
        }
        
        boatElement.draggable = true;
        boatElement.addEventListener('dragstart', handleDragStart);
        
        boatElement.addEventListener('contextmenu', function(e) {
            if (!state.isViewOnly) {
                e.preventDefault();
                showBoatContextMenu(e, id);
            }
        });
        
        smallBox.appendChild(boatElement);
    });
});
}
// Boat creation
function createBoat(config) {
const wrapper = document.createElement('div');
wrapper.className = `boat-wrapper user-${config.userGroup}`;
wrapper.style.position = 'absolute';
wrapper.style.left = (config.x || 0) + 'px';
wrapper.style.top = (config.y || 0) + 'px';
wrapper.style.transform = `rotate(${config.rotation || 0}deg)`;
wrapper.style.width = config.type === 1 ? '34px' : '30px';
wrapper.style.height = config.type === 1 ? '64px' : '48px';
wrapper.id = `boat-wrapper-${config.id}`;
wrapper.draggable = !state.isViewOnly;
const outline = document.createElement('div');
outline.className = 'boat-outline';

const boat = document.createElement('div');
boat.className = `boat boat-type-${config.type} status-${config.status}`;
boat.id = `boat-${config.id}`;
boat.style.position = 'relative';
boat.style.width = config.type === 1 ? '30px' : '26px';
boat.style.height = config.type === 1 ? '60px' : '44px';
boat.style.top = '2px';
boat.style.left = '2px';
boat.style.zIndex = '1';

const prefix = config.type === 1 ? 'C' : 'G';
const paddedNumber = config.id.toString().padStart(2, '0');

const boatNumber = document.createElement('span');
boatNumber.className = 'boat-number';
boatNumber.textContent = `${prefix}${paddedNumber}`;
boat.appendChild(boatNumber);

const userIndicator = document.createElement('div');
userIndicator.className = 'user-indicator';
userIndicator.textContent = config.userGroup === 'leg' ? 'Leg' : 'Lat';
userIndicator.style.zIndex = '3';

const rotationHandle = document.createElement('div');
rotationHandle.className = 'rotation-handle';
rotationHandle.style.zIndex = '4';
rotationHandle.title = 'Click and drag to rotate';

if (state.isViewOnly) {
    rotationHandle.style.display = 'none';
}

wrapper.appendChild(outline);
wrapper.appendChild(boat);
wrapper.appendChild(userIndicator);
wrapper.appendChild(rotationHandle);

if (!state.isViewOnly) {
    wrapper.addEventListener('dragstart', handleDragStart);
    wrapper.addEventListener('dragend', handleDragEnd);
    
    rotationHandle.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        handleRotationStart(e, wrapper);
    });
    
    wrapper.addEventListener('contextmenu', function(e) {
        e.preventDefault();
        showBoatContextMenu(e, config.id);
    });
}

const boatData = {
    id: config.id,
    element: wrapper,
    boat: boat,
    type: config.type || (config.id <= 70 ? 1 : 2),
    userGroup: config.userGroup,
    status: config.status || 'none',
    checkStatus: config.checkStatus || config.status || 'none',
    location: config.location || 'pier',
    x: config.x,
    y: config.y,
    rotation: config.rotation || 0,
    podId: null,
    troublePreviousStatus: null
};

state.boats.set(config.id, boatData);

updateBoatCount();
updateSmallBoxes();

return boatData;
}
// Create pod element with proper rotation support
function createPodElement(pod, isSmallBox = false) {
const podDiv = document.createElement('div');
podDiv.className = isSmallBox ? 'pod in-small-box' : 'pod';
podDiv.dataset.podId = pod.id;
if (!isSmallBox) {
    podDiv.style.position = 'absolute';
    podDiv.style.transform = `rotate(${pod.rotation || 0}deg)`;
    
    if (!state.isViewOnly) {
        podDiv.draggable = true;
        podDiv.addEventListener('dragstart', handlePodDragStart);
        podDiv.addEventListener('dragend', handleDragEnd);
        
        const rotationHandle = document.createElement('div');
        rotationHandle.className = 'rotation-handle';
        rotationHandle.style.position = 'absolute';
        rotationHandle.style.top = '-15px';
        rotationHandle.style.left = '50%';
        rotationHandle.style.transform = 'translateX(-50%)';
        rotationHandle.style.opacity = '1';
        rotationHandle.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
        rotationHandle.style.width = '12px';
        rotationHandle.style.height = '12px';
        rotationHandle.style.borderRadius = '50%';
        rotationHandle.style.border = '2px solid #333';
        rotationHandle.style.cursor = 'grab';
        rotationHandle.style.zIndex = '100';
        rotationHandle.title = 'Click and drag to rotate pod';
        podDiv.appendChild(rotationHandle);
        
        rotationHandle.addEventListener('mousedown', (e) => {
            e.preventDefault();
            e.stopPropagation();
            handlePodRotationStart(e, podDiv, pod.id);
        });
        
        podDiv.addEventListener('contextmenu', function(e) {
            if (!e.target.closest('.boat-wrapper')) {
                e.preventDefault();
                showPodContextMenu(e, pod.id);
            }
        });
    }
} else {
    podDiv.draggable = true;
    podDiv.addEventListener('dragstart', handlePodDragStart);
    
    setTimeout(() => {
        podDiv.querySelectorAll('.boat-wrapper').forEach(boatEl => {
            boatEl.addEventListener('contextmenu', function(e) {
                if (!state.isViewOnly) {
                    e.preventDefault();
                    e.stopPropagation();
                    const boatId = parseInt(boatEl.id.replace('boat-wrapper-', ''));
                    showBoatInPodContextMenu(e, boatId, pod.id);
                }
            });
        });
    }, 0);
}

const sortedBoats = [...pod.boats].sort((a, b) => {
    const boatA = state.boats.get(a);
    const boatB = state.boats.get(b);
    if (!boatA || !boatB) return 0;
    
    if (boatA.userGroup !== boatB.userGroup) {
        return boatA.userGroup === 'lat' ? -1 : 1;
    }
    if (boatA.type !== boatB.type) return boatA.type - boatB.type;
    return a - b;
});

sortedBoats.forEach(boatId => {
    const boat = state.boats.get(boatId);
    if (boat) {
        const boatElement = boat.element.cloneNode(true);
        boatElement.style.position = 'relative';
        boatElement.style.left = '';
        boatElement.style.top = '';
        boatElement.classList.add('in-small-box');
        
        const checkStatus = boat.checkStatus || boat.status;
        const boatInner = boatElement.querySelector('.boat');
        if (boatInner) {
            boatInner.className = `boat boat-type-${boat.type} status-${checkStatus}`;
        }
        
        boatElement.style.transform = '';
        
        const handle = boatElement.querySelector('.rotation-handle');
        if (handle) handle.style.display = 'none';
        
        podDiv.appendChild(boatElement);
    }
});

return podDiv;
}
// Drag and Drop Handlers with ghost rotation
function handleDragStart(e) {
    if (state.isViewOnly) return;
state.draggedItem = e.target.closest('.boat-wrapper');
if (!state.draggedItem) return;

const parent = state.draggedItem.parentElement;
if (parent.classList.contains('status-box-content')) {
    state.draggedFromArea = parent.closest('.status-box').dataset.area;
} else if (parent.classList.contains('pod')) {
    const podElement = parent.closest('.pod');
    if (podElement.parentElement.classList.contains('status-box-content')) {
        state.draggedFromArea = podElement.parentElement.closest('.status-box').dataset.area;
    } else {
        state.draggedFromArea = state.currentDisplay;
    }
} else {
    state.draggedFromArea = state.currentDisplay;
}

state.draggedItem.classList.add('dragging');
e.dataTransfer.effectAllowed = 'move';

// Create ghost image that maintains rotation
const ghost = state.draggedItem.cloneNode(true);
ghost.style.position = 'fixed';
ghost.style.top = '-1000px';
ghost.style.left = '-1000px';
ghost.style.pointerEvents = 'none';
ghost.style.opacity = '0.7';

const boatId = parseInt(state.draggedItem.id.replace('boat-wrapper-', ''));
const boatData = state.boats.get(boatId);
if (boatData && boatData.rotation) {
    ghost.style.transform = `rotate(${boatData.rotation}deg)`;
} else {
    const computedStyle = window.getComputedStyle(state.draggedItem);
    ghost.style.transform = computedStyle.transform;
}

document.body.appendChild(ghost);

const rect = state.draggedItem.getBoundingClientRect();
const offsetX = e.clientX - rect.left;
const offsetY = e.clientY - rect.top;
e.dataTransfer.setDragImage(ghost, offsetX, offsetY);

setTimeout(() => {
    if (ghost && ghost.parentNode) {
        document.body.removeChild(ghost);
    }
}, 0);
}
function handlePodDragStart(e) {
if (state.isViewOnly) return;
state.draggedItem = e.target.closest('.pod');
if (!state.draggedItem) return;

const parent = state.draggedItem.parentElement;
if (parent.classList.contains('status-box-content')) {
    state.draggedFromArea = parent.closest('.status-box').dataset.area;
} else {
    state.draggedFromArea = state.currentDisplay;
}

state.draggedItem.classList.add('dragging');
e.dataTransfer.effectAllowed = 'move';

const ghost = state.draggedItem.cloneNode(true);
ghost.style.position = 'fixed';
ghost.style.top = '-1000px';
ghost.style.left = '-1000px';
ghost.style.pointerEvents = 'none';
ghost.style.opacity = '0.7';

const podId = state.draggedItem.dataset.podId;
const pod = state.pods.get(podId);
if (pod && pod.rotation) {
    ghost.style.transform = `rotate(${pod.rotation}deg)`;
} else {
    const computedStyle = window.getComputedStyle(state.draggedItem);
    ghost.style.transform = computedStyle.transform;
}

document.body.appendChild(ghost);

const rect = state.draggedItem.getBoundingClientRect();
const offsetX = e.clientX - rect.left;
const offsetY = e.clientY - rect.top;
e.dataTransfer.setDragImage(ghost, offsetX, offsetY);

setTimeout(() => {
    if (ghost && ghost.parentNode) {
        document.body.removeChild(ghost);
    }
}, 0);
}
function handleDragEnd(e) {
if (state.draggedItem) {
state.draggedItem.classList.remove('dragging');
state.draggedItem = null;
state.draggedFromArea = null;
}
}
function handleDragOver(e) {
e.preventDefault();
e.dataTransfer.dropEffect = 'move';
}
function handleDrop(e) {
e.preventDefault();
if (!state.draggedItem) return;
const mainDisplay = document.getElementById('mainDisplay');
const rect = mainDisplay.getBoundingClientRect();

const x = e.clientX - rect.left;
const y = e.clientY - rect.top;

if (state.draggedItem.classList.contains('pod')) {
    const podId = state.draggedItem.dataset.podId;
    const pod = state.pods.get(podId);
    if (pod) {
        pod.x = x;
        pod.y = y;
        state.draggedItem.style.left = x + 'px';
        state.draggedItem.style.top = y + 'px';
        
        saveAreaLayout(state.currentDisplay);
        autoSaveState();
    }
} else {
    const boatId = parseInt(state.draggedItem.id.replace('boat-wrapper-', ''));
    const boatData = state.boats.get(boatId);
    if (boatData) {
        boatData.x = x;
        boatData.y = y;
        state.draggedItem.style.left = x + 'px';
        state.draggedItem.style.top = y + 'px';
        
        saveAreaLayout(state.currentDisplay);
        autoSaveState();
    }
}
}
// Rotation handling
function handleRotationStart(e, element) {
e.preventDefault();
state.rotatingBoat = element;
const rect = element.getBoundingClientRect();
const centerX = rect.left + rect.width / 2;
const centerY = rect.top + rect.height / 2;

const currentRotation = element.style.transform.match(/rotate\((-?\d+(?:\.\d+)?)deg\)/);
const startAngle = currentRotation ? parseFloat(currentRotation[1]) : 0;

const mouseAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;

element.dataset.rotationStart = startAngle;
element.dataset.mouseStart = mouseAngle;

document.addEventListener('mousemove', handleRotation);
document.addEventListener('mouseup', handleRotationEnd);
}
function handleRotation(e) {
if (!state.rotatingBoat) return;
const rect = state.rotatingBoat.getBoundingClientRect();
const centerX = rect.left + rect.width / 2;
const centerY = rect.top + rect.height / 2;

const currentMouseAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;
const mouseStart = parseFloat(state.rotatingBoat.dataset.mouseStart);
const rotationStart = parseFloat(state.rotatingBoat.dataset.rotationStart);

const angleDiff = currentMouseAngle - mouseStart;
const newRotation = rotationStart + angleDiff;

state.rotatingBoat.style.transform = `rotate(${newRotation}deg)`;

const boatId = parseInt(state.rotatingBoat.id.replace('boat-wrapper-', ''));
const boatData = state.boats.get(boatId);
if (boatData) {
    boatData.rotation = newRotation;
}
}
function handleRotationEnd(e) {
document.removeEventListener('mousemove', handleRotation);
document.removeEventListener('mouseup', handleRotationEnd);
if (state.rotatingBoat) {
    saveAreaLayout(state.currentDisplay);
    autoSaveState();
}

state.rotatingBoat = null;
}
// Handle pod rotation
function handlePodRotationStart(e, podElement, podId) {
e.preventDefault();
state.rotatingPod = { element: podElement, id: podId };
const rect = podElement.getBoundingClientRect();
const centerX = rect.left + rect.width / 2;
const centerY = rect.top + rect.height / 2;

const pod = state.pods.get(podId);
const startAngle = pod?.rotation || 0;

const mouseAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;

podElement.dataset.rotationStart = startAngle;
podElement.dataset.mouseStart = mouseAngle;

document.addEventListener('mousemove', handlePodRotation);
document.addEventListener('mouseup', handlePodRotationEnd);
}
function handlePodRotation(e) {
if (!state.rotatingPod) return;
const { element, id } = state.rotatingPod;
const rect = element.getBoundingClientRect();
const centerX = rect.left + rect.width / 2;
const centerY = rect.top + rect.height / 2;

const currentMouseAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;
const mouseStart = parseFloat(element.dataset.mouseStart);
const rotationStart = parseFloat(element.dataset.rotationStart);

const angleDiff = currentMouseAngle - mouseStart;
const newRotation = rotationStart + angleDiff;

element.style.transform = `rotate(${newRotation}deg)`;

const pod = state.pods.get(id);
if (pod) {
    pod.rotation = newRotation;
    
    pod.boats.forEach(boatId => {
        const boat = state.boats.get(boatId);
        if (boat) {
            boat.rotation = newRotation;
        }
    });
}
}
function handlePodRotationEnd(e) {
document.removeEventListener('mousemove', handlePodRotation);
document.removeEventListener('mouseup', handlePodRotationEnd);
if (state.rotatingPod) {
    saveAreaLayout(state.currentDisplay);
    autoSaveState();
}

state.rotatingPod = null;
}
// Pod management functions
function createPod(boatIds, location) {
const podId = 'pod_' + Date.now();
const pod = {
id: podId,
boats: boatIds,
location: location,
rotation: 0,
x: 20,
y: 20
};
state.pods.set(podId, pod);

boatIds.forEach(boatId => {
    const boat = state.boats.get(boatId);
    if (boat) {
        boat.podId = podId;
    }
});

updatePodCount();
updateMainDisplay();
updateSmallBoxes();

return pod;
}
// Break up pod
function breakUpPod(podId) {
const pod = state.pods.get(podId);
if (!pod) return;
pod.boats.forEach(boatId => {
    const boat = state.boats.get(boatId);
    if (boat) {
        boat.podId = null;
        const pos = getNextPosition(boat.location, boat.type);
        boat.x = pos.x;
        boat.y = pos.y;
    }
});

state.pods.delete(podId);

updatePodCount();
updateMainDisplay();
updateSmallBoxes();

document.getElementById('contextMenu').style.display = 'none';
}
// Toggle pod boat selection
function togglePodBoat(boatId, event) {
event.stopPropagation();
const checkbox = document.getElementById(`pod-boat-${boatId}`);
if (checkbox) {
checkbox.checked = !checkbox.checked;
}
}
// Create pod from selected boats
function createPodFromSelection(area) {
const menu = document.getElementById('contextMenu');
const checkboxes = menu.querySelectorAll('input[type="checkbox"]:checked');
if (checkboxes.length < 2) {
    alert('Please select at least 2 boats to create a pod');
    return;
}

const boatIds = Array.from(checkboxes).map(cb => parseInt(cb.value));
createPod(boatIds, area);

menu.style.display = 'none';
}
// Global function references for onclick handlers
window.togglePodBoat = togglePodBoat;
window.createPodFromSelection = createPodFromSelection;
window.breakUpPod = breakUpPod;
// Context Menu Functions
// Show boat context menu
function showBoatContextMenu(e, boatId) {
const menu = document.getElementById('contextMenu');
const boatData = state.boats.get(boatId);
if (!boatData) return;

const prefix = boatData.type === 1 ? 'C' : 'G';
const paddedNumber = boatId.toString().padStart(2, '0');

menu.innerHTML = `
    <div class="context-menu-item" style="font-weight: bold; color: #00bfff;">
        ${prefix}${paddedNumber} - Status Update
    </div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'none')">
        <span class="status-indicator-menu status-none" style="width: 10px; height: 10px; border-radius: 2px; display: inline-block;"></span>
        No Check
    </div>
    <div class="context-menu-item has-submenu">
        <span class="status-indicator-menu status-platform" style="width: 10px; height: 10px; border-radius: 2px; display: inline-block; background: #ff8c00;"></span>
        Platform Check
        <div class="submenu" style="display: none; position: absolute; left: 100%; top: 0; background: #2a2a2a; border: 2px solid #444; border-radius: 8px; min-width: 150px; max-height: 300px; overflow-y: auto;">
            <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'platform-start')">Start</div>
            <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'platform')">Complete</div>
        </div>
    </div>
    <div class="context-menu-item has-submenu">
        <span class="status-indicator-menu status-pierside" style="width: 10px; height: 10px; border-radius: 2px; display: inline-block; background: #ffff00;"></span>
        Pierside Check
        <div class="submenu" style="display: none; position: absolute; left: 100%; top: 0; background: #2a2a2a; border: 2px solid #444; border-radius: 8px; min-width: 150px; max-height: 300px; overflow-y: auto;">
            <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pierside-start')">Start</div>
            <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pierside-hold')">Hold</div>
            <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pierside')">Complete</div>
        </div>
    </div>
    <div class="context-menu-item has-submenu">
        <span class="status-indicator-menu status-pretow" style="width: 10px; height: 10px; border-radius: 2px; display: inline-block; background: linear-gradient(45deg, #fff 50%, #0f0 50%);"></span>
        Pre-Tow Check
        <div class="submenu" style="display: none; position: absolute; left: 100%; top: 0; background: #2a2a2a; border: 2px solid #444; border-radius: 8px; min-width: 150px; max-height: 300px; overflow-y: auto;">
            <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pretow-start')">Start</div>
            <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pretow')">Complete</div>
        </div>
    </div>
    <div class="context-menu-item has-submenu">
        <span class="status-indicator-menu status-operational" style="width: 10px; height: 10px; border-radius: 2px; display: inline-block; background: #00ff00;"></span>
        Post-Tow Check
        <div class="submenu" style="display: none; position: absolute; left: 100%; top: 0; background: #2a2a2a; border: 2px solid #444; border-radius: 8px; min-width: 150px; max-height: 300px; overflow-y: auto;">
            <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'operational-start')">Start</div>
            <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'operational')">Complete</div>
        </div>
    </div>
    <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'trouble')">
        <span class="status-indicator-menu status-trouble" style="width: 10px; height: 10px; border-radius: 2px; display: inline-block; background: repeating-linear-gradient(45deg, #f00, #f00 3px, #f80 3px, #f80 6px);"></span>
        Trouble
    </div>
    ${boatData.troublePreviousStatus ? `
    <div class="context-menu-item" onclick="clearTroubleStatus(${boatId})">
        ✓ Clear Trouble (Restore ${boatData.troublePreviousStatus})
    </div>
    ` : ''}
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'tow')">
        Being Towed
    </div>
    <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'transit')">
        In Transit
    </div>
    <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'operational-area')">
        Operational Area
    </div>
    <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'return-pier')">
        Return to Pier
    </div>
`;

positionContextMenu(menu, e.pageX, e.pageY);
setupSubmenuHover(menu);
}
// Show context menu for boat within a pod - FIXED with all options
function showBoatInPodContextMenu(e, boatId, podId) {
const menu = document.getElementById('contextMenu');
const boatData = state.boats.get(boatId);
const pod = state.pods.get(podId);
if (!boatData) return;

const prefix = boatData.type === 1 ? 'C' : 'G';
const paddedNumber = boatId.toString().padStart(2, '0');

menu.innerHTML = `
    <div class="context-menu-item" style="font-weight: bold; color: #00bfff;">
        ${prefix}${paddedNumber} - In Pod
    </div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" style="font-weight: bold;">Check Status (This Boat)</div>
    <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'none')">
        <span class="status-indicator-menu status-none" style="width: 10px; height: 10px; border-radius: 2px; display: inline-block;"></span>
        No Check
    </div>
    <div class="context-menu-item has-submenu">
        <span class="status-indicator-menu status-platform" style="width: 10px; height: 10px; border-radius: 2px; display: inline-block; background: #ff8c00;"></span>
        Platform Check
        <div class="submenu" style="display: none; position: absolute; left: 100%; top: 0; background: #2a2a2a; border: 2px solid #444; border-radius: 8px; min-width: 150px;">
            <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'platform-start')">Start</div>
            <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'platform')">Complete</div>
        </div>
    </div>
    <div class="context-menu-item has-submenu">
        <span class="status-indicator-menu status-pierside" style="width: 10px; height: 10px; border-radius: 2px; display: inline-block; background: #ffff00;"></span>
        Pierside Check
        <div class="submenu" style="display: none; position: absolute; left: 100%; top: 0; background: #2a2a2a; border: 2px solid #444; border-radius: 8px; min-width: 150px;">
            <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pierside-start')">Start</div>
            <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pierside-hold')">Hold</div>
            <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pierside')">Complete</div>
        </div>
    </div>
    <div class="context-menu-item has-submenu">
        <span class="status-indicator-menu status-pretow" style="width: 10px; height: 10px; border-radius: 2px; display: inline-block; background: linear-gradient(45deg, #fff 50%, #0f0 50%);"></span>
        Pre-Tow Check
        <div class="submenu" style="display: none; position: absolute; left: 100%; top: 0; background: #2a2a2a; border: 2px solid #444; border-radius: 8px; min-width: 150px;">
            <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pretow-start')">Start</div>
            <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pretow')">Complete</div>
        </div>
    </div>
    <div class="context-menu-item has-submenu">
        <span class="status-indicator-menu status-operational" style="width: 10px; height: 10px; border-radius: 2px; display: inline-block; background: #00ff00;"></span>
        Post-Tow Check
        <div class="submenu" style="display: none; position: absolute; left: 100%; top: 0; background: #2a2a2a; border: 2px solid #444; border-radius: 8px; min-width: 150px;">
            <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'operational-start')">Start</div>
            <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'operational')">Complete</div>
        </div>
    </div>
    <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'trouble')">
        <span class="status-indicator-menu status-trouble" style="width: 10px; height: 10px; border-radius: 2px; display: inline-block;"></span>
        Trouble
    </div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" style="font-weight: bold;">Check Status (Entire Pod)</div>
    <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'none')">
        All No Check
    </div>
    <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'platform-start')">
        All Platform Start
    </div>
    <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'platform')">
        All Platform Complete
    </div>
    <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'pierside-start')">
        All Pierside Start
    </div>
    <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'pierside-hold')">
        All Pierside Hold
    </div>
    <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'pierside')">
        All Pierside Complete
    </div>
    <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'pretow-start')">
        All Pre-Tow Start
    </div>
    <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'pretow')">
        All Pre-Tow Complete
    </div>
    <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'operational-start')">
        All Post-Tow Start
    </div>
    <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'operational')">
        All Post-Tow Complete
    </div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" style="font-weight: bold;">Movement (Entire Pod)</div>
    <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'tow')">
        All Being Towed
    </div>
    <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'transit')">
        All In Transit
    </div>
    <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'operational-area')">
        All Operational Area
    </div>
    <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'return-pier')">
        All Return to Pier
    </div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" onclick="breakUpPod('${podId}')">
        💔 Break Up Pod
    </div>
`;

positionContextMenu(menu, e.clientX, e.clientY);
setupSubmenuHover(menu);
}
// Show pod context menu
function showPodContextMenu(e, podId) {
const menu = document.getElementById('contextMenu');
const pod = state.pods.get(podId);
if (!pod) return;

menu.innerHTML = `
    <div class="context-menu-item" style="font-weight: bold; color: #00bfff;">
        Pod Options
    </div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'none')">
        <span class="status-indicator-menu status-none" style="width: 10px; height: 10px; border-radius: 2px; display: inline-block;"></span>
        All No Check
    </div>
    <div class="context-menu-item has-submenu">
        <span class="status-indicator-menu status-platform" style="width: 10px; height: 10px; border-radius: 2px; display: inline-block; background: #ff8c00;"></span>
        All Platform Check
        <div class="submenu" style="display: none; position: absolute; left: 100%; top: 0; background: #2a2a2a; border: 2px solid #444; border-radius: 8px; min-width: 120px;">
            <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'platform-start')">Start</div>
            <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'platform')">Complete</div>
        </div>
    </div>
    <div class="context-menu-item has-submenu">
        <span class="status-indicator-menu status-pierside" style="width: 10px; height: 10px; border-radius: 2px; display: inline-block; background: #ffff00;"></span>
        All Pierside Check
        <div class="submenu" style="display: none; position: absolute; left: 100%; top: 0; background: #2a2a2a; border: 2px solid #444; border-radius: 8px; min-width: 120px;">
            <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'pierside-start')">Start</div>
            <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'pierside-hold')">Hold</div>
            <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'pierside')">Complete</div>
        </div>
    </div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" style="font-weight: bold;">Movement (Entire Pod)</div>
    <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'tow')">
        All Being Towed
    </div>
    <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'transit')">
        All In Transit
    </div>
    <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'operational-area')">
        All Operational Area
    </div>
    <div class="context-menu-item" onclick="updatePodStatusFromMenu('${podId}', 'return-pier')">
        All Return to Pier
    </div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" onclick="breakUpPod('${podId}')">
        💔 Break Up Pod
    </div>
`;

positionContextMenu(menu, e.pageX, e.pageY);
setupSubmenuHover(menu);
}
// Show area context menu for creating pods
function showAreaContextMenu(e, area) {
const menu = document.getElementById('contextMenu');
const areaBoats = [];
state.boats.forEach((boat, id) => {
    if (boat.location === area && !boat.podId) {
        areaBoats.push({ id, boat });
    }
});

areaBoats.sort((a, b) => {
    if (a.boat.userGroup !== b.boat.userGroup) {
        return a.boat.userGroup === 'lat' ? -1 : 1;
    }
    if (a.boat.type !== b.boat.type) {
        return a.boat.type - b.boat.type;
    }
    return a.id - b.id;
});

let menuHTML = `
    <div class="context-menu-item" style="font-weight: bold; color: #00bfff;">
        Create Pod
    </div>
    <div class="context-menu-separator"></div>
`;

if (areaBoats.length === 0) {
    menuHTML += `<div class="context-menu-item" style="color: #666;">No boats available</div>`;
} else {
    areaBoats.forEach(({ id, boat }) => {
        const prefix = boat.type === 1 ? 'C' : 'G';
        const paddedNumber = id.toString().padStart(2, '0');
        menuHTML += `
            <div class="context-menu-item" onclick="togglePodBoat(${id}, event)">
                <input type="checkbox" id="pod-boat-${id}" value="${id}" style="margin-right: 5px; pointer-events: none;">
                <label for="pod-boat-${id}" style="cursor: pointer; pointer-events: none;">
                    ${prefix}${paddedNumber} (${boat.userGroup === 'leg' ? 'Leg' : 'Lat'})
                </label>
            </div>
        `;
    });
    
    menuHTML += `
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" onclick="createPodFromSelection('${area}')" style="background: linear-gradient(45deg, #00bfff, #b19cd9); color: #fff;">
            Create Pod
        </div>
    `;
}

menu.innerHTML = menuHTML;
positionContextMenu(menu, e.pageX, e.pageY);
}
// Show context menu for manual cell override
function showCellContextMenu(e, cell) {
e.preventDefault();
const cellId = cell.id || generateCellId(cell);
if (!cell.id) {
    cell.id = cellId;
}

const dialog = document.createElement('div');
dialog.className = 'manual-override-dialog';
dialog.style.cssText = `
    position: fixed;
    left: ${e.clientX}px;
    top: ${e.clientY}px;
    background: #2a2a2a;
    border: 2px solid #444;
    border-radius: 8px;
    padding: 15px;
    z-index: 10000;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    color: #fff;
`;

dialog.innerHTML = `
    <div style="color: #00bfff; margin-bottom: 10px; font-weight: bold;">Manual Override</div>
    <input type="text" id="override-time" placeholder="HH:MM (or leave blank for now)" 
           style="width: 100%; margin-bottom: 5px; padding: 5px; background: #333; border: 1px solid #555; color: #fff; border-radius: 3px;">
    <input type="text" id="override-operator" placeholder="Operator name" 
           value="${localStorage.getItem('lastOperator') || ''}"
           style="width: 100%; margin-bottom: 10px; padding: 5px; background: #333; border: 1px solid #555; color: #fff; border-radius: 3px;">
    <div style="display: flex; gap: 5px;">
        <button onclick="applyManualOverride('${cellId}')" 
                style="flex: 1; padding: 5px 10px; background: #00bfff; border: none; border-radius: 3px; color: #000; cursor: pointer; font-weight: bold;">
            Apply
        </button>
        <button onclick="clearCell('${cellId}')" 
                style="flex: 1; padding: 5px 10px; background: #ff6b6b; border: none; border-radius: 3px; color: #fff; cursor: pointer; font-weight: bold;">
            Clear
        </button>
        <button onclick="this.parentElement.parentElement.remove()" 
                style="flex: 1; padding: 5px 10px; background: #666; border: none; border-radius: 3px; color: #fff; cursor: pointer;">
            Cancel
        </button>
    </div>
`;

document.querySelectorAll('.manual-override-dialog').forEach(d => d.remove());
document.body.appendChild(dialog);

const rect = dialog.getBoundingClientRect();
if (rect.right > window.innerWidth) {
    dialog.style.left = (window.innerWidth - rect.width - 10) + 'px';
}
if (rect.bottom > window.innerHeight) {
    dialog.style.top = (window.innerHeight - rect.height - 10) + 'px';
}

document.getElementById('override-time').focus();
}
// Position context menu properly near cursor
function positionContextMenu(menu, x, y) {
    menu.style.display = 'block';
    
    // First, show the menu to get its dimensions
    menu.style.visibility = 'hidden';
    menu.style.display = 'block';
    
    const menuRect = menu.getBoundingClientRect();
    const menuWidth = menuRect.width;
    const menuHeight = menuRect.height;
    
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    const scrollY = window.scrollY;
    const scrollX = window.scrollX;
    
    // Position near mouse, accounting for scroll
    let adjustedX = x - scrollX;
    let adjustedY = y - scrollY;
    
    // Check if menu would go off right edge
    if (adjustedX + menuWidth > viewportWidth - 10) {
        adjustedX = x - scrollX - menuWidth - 10; // Show to left of cursor
    }
    
    // Check if menu would go off bottom edge
    if (adjustedY + menuHeight > viewportHeight - 10) {
        adjustedY = viewportHeight - menuHeight - 10;
    }
    
    // Ensure menu doesn't go off top or left
    adjustedX = Math.max(10, adjustedX);
    adjustedY = Math.max(10, adjustedY);
    
    menu.style.left = adjustedX + 'px';
    menu.style.top = adjustedY + 'px';
    menu.style.visibility = 'visible';
}

// Setup submenu hover behavior with proper positioning
function setupSubmenuHover(menu) {
const itemsWithSubmenu = menu.querySelectorAll('.has-submenu');
itemsWithSubmenu.forEach(item => {
const submenu = item.querySelector('.submenu');
if (submenu) {
item.addEventListener('mouseenter', () => {
submenu.style.display = 'block';
            const itemRect = item.getBoundingClientRect();
            const submenuRect = submenu.getBoundingClientRect();
            
            if (itemRect.right + submenuRect.width > window.innerWidth) {
                submenu.style.left = 'auto';
                submenu.style.right = '100%';
            } else {
                submenu.style.left = '100%';
                submenu.style.right = 'auto';
            }
            
            if (itemRect.top + submenuRect.height > window.innerHeight) {
                submenu.style.top = 'auto';
                submenu.style.bottom = '0';
            }
        });
        
        item.addEventListener('mouseleave', () => {
            submenu.style.display = 'none';
        });
    }
});
}

// Status Update Functions

// Update boat status from menu
window.updateBoatStatusFromMenu = function(boatId, status) {
    const operator = prompt('Enter your name:', localStorage.getItem('lastOperator') || 'Manual');
    if (operator) {
        localStorage.setItem('lastOperator', operator);
        updateBoatStatus(boatId, status, operator);
    }
    document.getElementById('contextMenu').style.display = 'none';
}

// Update entire pod check status from menu
window.updatePodCheckStatusFromMenu = function(podId, status) {
    const operator = prompt('Enter your name:', localStorage.getItem('lastOperator') || 'Manual');
    if (operator) {
        localStorage.setItem('lastOperator', operator);
        const pod = state.pods.get(podId);
        if (pod) {
            pod.boats.forEach(boatId => {
                const boatData = state.boats.get(boatId);
                if (boatData) {
                    const currentLocation = boatData.location;
                    updateBoatStatus(boatId, status, operator);
                    boatData.location = currentLocation;
                }
            });
            updateMainDisplay();
            updateSmallBoxes();
        }
    }
    document.getElementById('contextMenu').style.display = 'none';
}

// Update entire pod status from menu (movement)
window.updatePodStatusFromMenu = function(podId, status) {
    const operator = prompt('Enter your name:', localStorage.getItem('lastOperator') || 'Manual');
    if (operator) {
        localStorage.setItem('lastOperator', operator);
        const pod = state.pods.get(podId);
        if (pod) {
            pod.boats.forEach(boatId => {
                updateBoatStatus(boatId, status, operator);
            });
        }
    }
    document.getElementById('contextMenu').style.display = 'none';
}

// Clear trouble status and restore previous
window.clearTroubleStatus = function(boatId) {
    const boatData = state.boats.get(boatId);
    if (!boatData || !boatData.troublePreviousStatus) return;
    
    const operator = prompt('Enter your name:', localStorage.getItem('lastOperator') || 'Manual');
    if (operator) {
        localStorage.setItem('lastOperator', operator);
        
        const previousStatus = boatData.troublePreviousStatus;
        boatData.troublePreviousStatus = null;
        
        updateBoatStatus(boatId, previousStatus, operator + ' (Trouble Cleared)');
    }
    
    document.getElementById('contextMenu').style.display = 'none';
}

// Manual override for status cell
window.applyManualOverride = function(cellId) {
    const cell = document.getElementById(cellId);
    if (!cell) {
        console.error('Cell not found:', cellId);
        return;
    }
    
    const timeInput = document.getElementById('override-time').value;
    const operatorInput = document.getElementById('override-operator').value;
    
    if (!operatorInput) {
        alert('Please enter an operator name');
        return;
    }
    
    localStorage.setItem('lastOperator', operatorInput);
    
    let timestamp = new Date();
    if (timeInput) {
        const [hours, minutes] = timeInput.split(':').map(n => parseInt(n) || 0);
        timestamp.setHours(hours, minutes, 0);
    }
    
    const timeStr = timestamp.toLocaleTimeString('en-US', { 
        hour: '2-digit', 
        minute: '2-digit',
        hour12: false 
    });
    
    cell.innerHTML = `${timeStr}<br><small>${operatorInput}</small>`;
    cell.title = `${timestamp.toLocaleString()} - ${operatorInput} (Manual Override)`;
    
    const statusType = cell.dataset.status || cell.parentElement.dataset.status;
    if (statusType) {
        cell.className = cell.className.split(' ').filter(c => !c.startsWith('status-')).join(' ');
        
        if (statusType === 'platform-start') {
            cell.className += ' status-platform-start';
        } else if (statusType === 'platform-complete') {
            cell.className += ' status-platform';
        } else if (statusType === 'pierside-start') {
            cell.className += ' status-pierside-start';
        } else if (statusType === 'pierside-hold') {
            cell.className += ' status-pierside-hold';
        } else if (statusType === 'pierside-complete') {
            cell.className += ' status-pierside';
        } else if (statusType === 'pretow-start') {
            cell.className += ' status-pretow-start';
        } else if (statusType === 'pretow-complete') {
            cell.className += ' status-pretow';
        } else if (statusType === 'operational-start') {
            cell.className += ' status-operational-start';
        } else if (statusType === 'operational-complete') {
            cell.className += ' status-operational';
        } else {
            cell.className += ` status-${statusType.replace('-complete', '').replace('-start', '').replace('-hold', '')}`;
        }
    }
    
    // Save to local storage for persistence
    saveStatusTableState();
    
    const row = cell.closest('tr');
    const boatId = parseInt(row.dataset.boatId);
    const boat = state.boats.get(boatId);
    if (boat) {
        const status = statusType.replace('-complete', '').replace('-start', '').replace('-hold', '');
        sendToGoogleSheets(boatId, boat, statusType, operatorInput, timestamp);
    }
    
    document.querySelectorAll('.manual-override-dialog').forEach(d => d.remove());
}

// Clear cell
window.clearCell = function(cellId) {
    const cell = document.getElementById(cellId);
    
    if (cell && confirm('Clear this status entry?')) {
        cell.innerHTML = '';
        cell.className = cell.className.split(' ').filter(c => !c.startsWith('status-')).join(' ');
        cell.removeAttribute('title');
        
        saveStatusTableState();
    }
    
    document.querySelectorAll('.manual-override-dialog').forEach(d => d.remove());
}

// Update boat status with enhanced timestamp precision
function updateBoatStatus(boatId, newStatus, operator = 'Unknown') {
    const boatData = state.boats.get(boatId);
    if (!boatData) return;
    
    // Handle trouble status
    if (newStatus === 'trouble' && boatData.status !== 'trouble') {
        boatData.troublePreviousStatus = boatData.status;
    }
    
    const movementStatuses = ['tow', 'transit', 'operational-area', 'return-pier'];
    const isMovementStatus = movementStatuses.includes(newStatus);
    
    if (!isMovementStatus) {
        // Check status - update color
        boatData.checkStatus = newStatus;
        boatData.status = newStatus;
        
        if (boatData.boat) {
            boatData.boat.className = `boat boat-type-${boatData.type} status-${newStatus}`;
        }
        
        const mainDisplay = document.getElementById('mainDisplay');
        const displayBoat = mainDisplay.querySelector(`#boat-wrapper-${boatId}`);
        if (displayBoat) {
            const boatInner = displayBoat.querySelector('.boat');
            if (boatInner) {
                boatInner.className = `boat boat-type-${boatData.type} status-${newStatus}`;
            }
        }
        
        const allBoatElements = document.querySelectorAll(`#boat-${boatId}`);
        allBoatElements.forEach(el => {
            el.className = `boat boat-type-${boatData.type} status-${newStatus}`;
        });
    }
    
    const timestamp = new Date();
    addStatusToTable(boatId, boatData, newStatus, operator, { timestamp });
    
    if (isMovementStatus) {
        let targetLocation = '';
        if (newStatus === 'tow') targetLocation = 'tow';
        else if (newStatus === 'transit') targetLocation = 'transit';
        else if (newStatus === 'operational-area') targetLocation = 'operational-area';
        else if (newStatus === 'return-pier') targetLocation = 'pier';
        
        if (targetLocation && boatData.location !== targetLocation) {
            if (boatData.podId) {
                movePodToArea(boatData.podId, targetLocation);
            } else {
                moveBoatToArea(boatId, targetLocation);
            }
        }
    }
    
    sendStatusUpdate(boatId, newStatus, operator, boatData.checkStatus, timestamp);
}
// Create new row with side-by-side split cells
function createNewRow(boatId, boatName, boatData) {
    const newRow = document.createElement('tr');
    newRow.setAttribute('data-boat-id', boatId);
    
    // Boat
    const boatCell = document.createElement('td');
    boatCell.textContent = boatName;
    newRow.appendChild(boatCell);
    
    // Group
    const groupCell = document.createElement('td');
    groupCell.textContent = boatData.userGroup === 'leg' ? 'Leg' : 'Lat';
    groupCell.style.color = boatData.userGroup === 'leg' ? '#b19cd9' : '#00bfff';
    newRow.appendChild(groupCell);
    
    // No Check - single cell
    const noneCell = document.createElement('td');
    noneCell.setAttribute('data-status', 'none');
    noneCell.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) {
            showCellContextMenu(e, noneCell);
        }
    });
    newRow.appendChild(noneCell);
    
    // Platform (side-by-side split) - Start | Complete
    const platformCell = document.createElement('td');
    platformCell.className = 'split-cell';
    platformCell.setAttribute('colspan', '2');
    platformCell.innerHTML = `
        <div class="split-cell-container">
            <div class="split-cell-left" data-status="platform-start"></div>
            <div class="split-cell-right" data-status="platform-complete"></div>
        </div>
    `;
    newRow.appendChild(platformCell);
    
    const platformLeft = platformCell.querySelector('.split-cell-left');
    const platformRight = platformCell.querySelector('.split-cell-right');
    platformLeft.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, platformLeft);
    });
    platformRight.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, platformRight);
    });
    
    // Pierside (triple split) - Start | Hold | Complete
    const piersideCell = document.createElement('td');
    piersideCell.className = 'split-cell-triple';
    piersideCell.setAttribute('colspan', '3');
    piersideCell.innerHTML = `
        <div class="split-cell-triple-container">
            <div class="split-cell-triple-left" data-status="pierside-start"></div>
            <div class="split-cell-triple-middle" data-status="pierside-hold"></div>
            <div class="split-cell-triple-right" data-status="pierside-complete"></div>
        </div>
    `;
    newRow.appendChild(piersideCell);
    
    const piersideLeft = piersideCell.querySelector('.split-cell-triple-left');
    const piersideMiddle = piersideCell.querySelector('.split-cell-triple-middle');
    const piersideRight = piersideCell.querySelector('.split-cell-triple-right');
    piersideLeft.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, piersideLeft);
    });
    piersideMiddle.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, piersideMiddle);
    });
    piersideRight.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, piersideRight);
    });
    
    // Pre-Tow (side-by-side split) - Start | Complete
    const pretowCell = document.createElement('td');
    pretowCell.className = 'split-cell';
    pretowCell.setAttribute('colspan', '2');
    pretowCell.innerHTML = `
        <div class="split-cell-container">
            <div class="split-cell-left" data-status="pretow-start"></div>
            <div class="split-cell-right" data-status="pretow-complete"></div>
        </div>
    `;
    newRow.appendChild(pretowCell);
    
    const pretowLeft = pretowCell.querySelector('.split-cell-left');
    const pretowRight = pretowCell.querySelector('.split-cell-right');
    pretowLeft.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, pretowLeft);
    });
    pretowRight.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, pretowRight);
    });
    
    // Post-Tow (side-by-side split) - Start | Complete
    const operationalCell = document.createElement('td');
    operationalCell.className = 'split-cell';
    operationalCell.setAttribute('colspan', '2');
    operationalCell.innerHTML = `
        <div class="split-cell-container">
            <div class="split-cell-left" data-status="operational-start"></div>
            <div class="split-cell-right" data-status="operational-complete"></div>
        </div>
    `;
    newRow.appendChild(operationalCell);
    
    const operationalLeft = operationalCell.querySelector('.split-cell-left');
    const operationalRight = operationalCell.querySelector('.split-cell-right');
    operationalLeft.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, operationalLeft);
    });
    operationalRight.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, operationalRight);
    });
    
    // Trouble - single cell
    const troubleCell = document.createElement('td');
    troubleCell.setAttribute('data-status', 'trouble');
    troubleCell.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, troubleCell);
    });
    newRow.appendChild(troubleCell);
    
    // Movement statuses - single cells
    const towCell = document.createElement('td');
    towCell.setAttribute('data-status', 'tow');
    towCell.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, towCell);
    });
    newRow.appendChild(towCell);
    
    const transitCell = document.createElement('td');
    transitCell.setAttribute('data-status', 'transit');
    transitCell.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, transitCell);
    });
    newRow.appendChild(transitCell);
    
    const opareaCell = document.createElement('td');
    opareaCell.setAttribute('data-status', 'oparea');
    opareaCell.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, opareaCell);
    });
    newRow.appendChild(opareaCell);
    
    const returnCell = document.createElement('td');
    returnCell.setAttribute('data-status', 'return');
    returnCell.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, returnCell);
    });
    newRow.appendChild(returnCell);
    
    return newRow;
}

// Add status to table with side-by-side cells
function addStatusToTable(boatId, boatData, status, operator, options = {}) {
    const timestamp = options.timestamp || new Date();
    const timeStr = new Date(timestamp).toLocaleTimeString('en-US', { 
        hour: '2-digit', 
        minute: '2-digit',
        hour12: false 
    });
    
    const dateStr = new Date(timestamp).toLocaleDateString('en-US', { 
        month: '2-digit',
        day: '2-digit',
        year: 'numeric'
    });
    
    const tbody = document.getElementById('statusTableBody');
    const prefix = boatData.type === 1 ? 'C' : 'G';
    const paddedNumber = boatId.toString().padStart(2, '0');
    const boatName = `${prefix}${paddedNumber}`;
    
    const statusColumnMap = {
        'none': 'none',
        'platform-start': 'platform-start',
        'platform-complete': 'platform-complete',
        'platform': 'platform-complete',
        'pierside-start': 'pierside-start',
        'pierside-hold': 'pierside-hold',
        'pierside-complete': 'pierside-complete',
        'pierside': 'pierside-complete',
        'pretow-start': 'pretow-start',
        'pretow-complete': 'pretow-complete',
        'pretow': 'pretow-complete',
        'operational-start': 'operational-start',
        'operational-complete': 'operational-complete',
        'operational': 'operational-complete',
        'trouble': 'trouble',
        'tow': 'tow',
        'transit': 'transit',
        'operational-area': 'oparea',
        'return-pier': 'return'
    };
    
    const columnStatus = statusColumnMap[status] || status;
    
    // Find existing row(s) for this boat
    const existingRows = Array.from(tbody.querySelectorAll(`tr[data-boat-id="${boatId}"]`));
    let targetRow = null;
    
    if (existingRows.length > 0) {
        // Check if we need to create a duplicate row
        const lastRow = existingRows[existingRows.length - 1];
        const targetCell = lastRow.querySelector(`[data-status="${columnStatus}"]`) || 
                         lastRow.querySelector(`td[data-status="${columnStatus}"]`);
        
        if (targetCell && targetCell.innerHTML.trim() !== '') {
            // Cell already has data - create a new row for duplicate entry
            targetRow = createNewRow(boatId, boatName + ' (2)', boatData);
            // Insert right after the last row for this boat
            lastRow.parentNode.insertBefore(targetRow, lastRow.nextSibling);
        } else {
            // Use existing row
            targetRow = lastRow;
        }
    } else {
        // Create first row for this boat
        targetRow = createNewRow(boatId, boatName, boatData);
        insertRowInOrder(tbody, targetRow, boatId, boatData);
    }
    
    updateTableCell(targetRow, columnStatus, status, operator, timestamp, dateStr, timeStr);
    
    // Save status table state
    saveStatusTableState();
    
    console.log(`Status recorded: ${boatName} - ${status} at ${dateStr} ${timeStr} by ${operator}`);
    
    sendToGoogleSheets(boatId, boatData, status, operator, timestamp);
}

// Helper function to insert row in sorted order
function insertRowInOrder(tbody, newRow, boatId, boatData) {
    const allRows = Array.from(tbody.querySelectorAll('tr'));
    let insertBefore = null;
    
    for (const row of allRows) {
        const rowBoatId = parseInt(row.dataset.boatId);
        const rowBoat = state.boats.get(rowBoatId);
        if (rowBoat) {
            if (boatData.userGroup === 'lat' && rowBoat.userGroup === 'leg') {
                insertBefore = row;
                break;
            } else if (boatData.userGroup === rowBoat.userGroup) {
                if (boatData.type < rowBoat.type || 
                    (boatData.type === rowBoat.type && boatId < rowBoatId)) {
                    insertBefore = row;
                    break;
                }
            }
        }
    }
    
    if (insertBefore) {
        tbody.insertBefore(newRow, insertBefore);
    } else {
        tbody.appendChild(newRow);
    }
}

// Update table cell for side-by-side layout
function updateTableCell(row, columnStatus, actualStatus, operator, timestamp, dateStr, timeStr) {
    let cell;
    
    if (columnStatus === 'pierside-start' || columnStatus === 'pierside-hold' || columnStatus === 'pierside-complete') {
        cell = row.querySelector(`[data-status="${columnStatus}"]`);
    } else if (columnStatus.includes('-')) {
        cell = row.querySelector(`[data-status="${columnStatus}"]`);
    } else {
        cell = row.querySelector(`td[data-status="${columnStatus}"]`);
    }
    
    if (!cell) {
        console.warn(`Cell not found for status: ${columnStatus}`);
        return;
    }
    
    let statusClass = `status-${actualStatus.replace('-complete', '').replace('-start', '').replace('-hold', '')}`;
    
    cell.className = cell.className.split(' ').filter(c => !c.startsWith('status-')).join(' ');
    
    if (actualStatus.includes('-start')) {
        cell.className += ` ${statusClass}-start`;
    } else if (actualStatus.includes('-hold')) {
        cell.className += ` ${statusClass}-hold`;
    } else if (actualStatus === 'trouble') {
        cell.className += ` status-trouble`;
    } else if (actualStatus.includes('complete') || ['platform', 'pierside', 'pretow', 'operational'].includes(actualStatus)) {
        cell.className += ` status-${actualStatus.replace('-complete', '')}`;
    } else {
        cell.className += ` status-${actualStatus}`;
    }
    
    cell.innerHTML = `${timeStr}<br><small>${operator}</small>`;
    cell.title = `${dateStr} ${timeStr} - ${operator}`;
    cell.dataset.time = timeStr;
    cell.dataset.date = dateStr;
    cell.dataset.operator = operator;

    if (['tow', 'transit', 'oparea', 'return'].includes(columnStatus)) {
        const boatId = parseInt(row.dataset.boatId);
        const boat = state.boats.get(boatId);
        if (boat && boat.checkStatus) {
            const checkColor = boat.checkStatus.replace('-start', '').replace('-complete', '').replace('-hold', '');
            cell.style.backgroundColor = getStatusColor(checkColor);
        }
    }
    
    if (!cell.hasAttribute('data-has-context-menu')) {
        cell.setAttribute('data-has-context-menu', 'true');
        cell.addEventListener('contextmenu', function(e) {
            if (!state.isViewOnly) {
                showCellContextMenu(e, cell);
            }
        });
    }
}

// Helper function for updateTableCell color status
function getStatusColor(status) {
    const colors = {
        'none': 'rgba(255, 0, 0, 0.7)',
        'platform': 'rgba(255, 140, 0, 0.7)',
        'pierside': 'rgba(255, 255, 0, 0.7)',
        'pretow': 'rgba(255, 255, 255, 0.7)',
        'operational': 'rgba(0, 255, 0, 0.7)',
        'trouble': 'rgba(255, 0, 0, 0.7)'
    };
    return colors[status] || 'rgba(128, 128, 128, 0.3)';
}

// Save status table state (optimized for size)
function saveStatusTableState() {
    // Extract minimal data from table
    const tbody = document.getElementById('statusTableBody');
    const rows = tbody.querySelectorAll('tr');
    const tableData = [];
    
    rows.forEach(row => {
        const boatId = row.dataset.boatId;
        const cells = {};
        
        // Store only cells with content
        row.querySelectorAll('[data-status]').forEach(cell => {
            if (cell.innerHTML.trim()) {
                cells[cell.dataset.status] = {
                    t: cell.dataset.time,
                    o: cell.dataset.operator,
                    d: cell.dataset.date
                };
            }
        });
        
        if (Object.keys(cells).length > 0) {
            tableData.push({ id: boatId, c: cells });
        }
    });
    
    localStorage.setItem('statusTableData', JSON.stringify(tableData));
}

// Clear status table
window.clearStatusTable = function() {
    if (confirm('Are you sure you want to clear the status tracking table?')) {
        document.getElementById('statusTableBody').innerHTML = '';
        state.lastKnownStates.clear();
        state.statusLogHistory.clear();
        state.rowTracking.clear();
        localStorage.removeItem('statusTableData');
    }
}
// Export to CSV with proper handling of side-by-side cells
window.exportToCSV = function() {
    const table = document.getElementById('statusTable');
    let csv = [];
    
    // Headers - handle colspan headers
    const header1 = [];
    const header2 = [];
    const headerRows = table.querySelectorAll('thead tr');
    
    // First header row
    headerRows[0].querySelectorAll('th').forEach(th => {
        const colspan = parseInt(th.getAttribute('colspan')) || 1;
        const text = th.textContent.trim();
        header1.push(text);
        for (let i = 1; i < colspan; i++) {
            header1.push(''); // Empty for merged cells
        }
    });
    
    // Second header row
    if (headerRows[1]) {
        // Add empty cells for rowspan headers
        header2.push('', '', ''); // Boat, Group, No Check (have rowspan=2)
        
        // Add the actual sub-headers from the second row
        headerRows[1].querySelectorAll('th').forEach(th => {
            header2.push(th.textContent.trim());
        });
        
        // Add empty cells for remaining rowspan headers
        header2.push('', '', '', '', ''); // Trouble, Towed, Transit, Op Area, Return
    }
    
    csv.push(header1.join(','));
    if (header2.length > 0) {
        csv.push(header2.join(','));
    }
    
    // Data rows
    const tbody = table.querySelector('tbody');
    const allRows = Array.from(tbody.querySelectorAll('tr'));
    
    // Sort rows by group and boat number
    allRows.sort((a, b) => {
        const boatIdA = parseInt(a.dataset.boatId);
        const boatIdB = parseInt(b.dataset.boatId);
        const boatA = state.boats.get(boatIdA);
        const boatB = state.boats.get(boatIdB);
        
        if (boatA && boatB) {
            // Sort by group (Lat first)
            if (boatA.userGroup !== boatB.userGroup) {
                return boatA.userGroup === 'lat' ? -1 : 1;
            }
            // Then by type
            if (boatA.type !== boatB.type) return boatA.type - boatB.type;
            // Then by ID
            return boatIdA - boatIdB;
        }
        return 0;
    });
    
    allRows.forEach(row => {
        const rowData = [];
        row.querySelectorAll('td').forEach(cell => {
            if (cell.classList.contains('split-cell')) {
                // Handle dual split cells
                const left = cell.querySelector('.split-cell-left');
                const right = cell.querySelector('.split-cell-right');
                
                const leftText = left ? extractCellText(left) : '';
                const rightText = right ? extractCellText(right) : '';
                
                rowData.push(leftText);
                rowData.push(rightText);
            } else if (cell.classList.contains('split-cell-triple')) {
                // Handle triple split cells (Pierside with Hold)
                const left = cell.querySelector('.split-cell-triple-left');
                const middle = cell.querySelector('.split-cell-triple-middle');
                const right = cell.querySelector('.split-cell-triple-right');
                
                const leftText = left ? extractCellText(left) : '';
                const middleText = middle ? extractCellText(middle) : '';
                const rightText = right ? extractCellText(right) : '';
                
                rowData.push(leftText);
                rowData.push(middleText);
                rowData.push(rightText);
            } else {
                // Handle single cells
                const text = extractCellText(cell);
                rowData.push(text.includes(',') ? `"${text}"` : text);
            }
        });
        csv.push(rowData.join(','));
    });
    
    // Download
    const blob = new Blob([csv.join('\n')], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `boat_status_tracking_${new Date().toISOString().split('T')[0]}.csv`;
    a.click();
    URL.revokeObjectURL(url);
}

// Server Communication Functions

// Update from server state with proper duplicate prevention
async function updateFromServerState() {
    try {
        const response = await fetch(N8N_CONFIG.stateWebhook);
        if (!response.ok) return;
        
        const serverState = await response.json();
        if (!serverState || !serverState.boats) return;
        
        console.log(`Polling update: ${serverState.boats.length} boats from server`);
        
        // Sort boats by group and number for organized creation
        const sortedBoats = serverState.boats.sort((a, b) => {
            if (a.userGroup !== b.userGroup) {
                return a.userGroup === 'lat' ? -1 : 1;
            }
            if (a.type !== b.type) return a.type - b.type;
            return a.id - b.id;
        });
        
        sortedBoats.forEach(boatData => {
            const existingBoat = state.boats.get(boatData.id);
            
            if (existingBoat) {
                // Update assignment if changed
                if (existingBoat.userGroup !== boatData.userGroup) {
                    console.log(`Updating boat ${boatData.id} assignment from ${existingBoat.userGroup} to ${boatData.userGroup}`);
                    
                    existingBoat.userGroup = boatData.userGroup;
                    existingBoat.element.className = `boat-wrapper user-${boatData.userGroup}`;
                    if (!existingBoat.element.classList.contains('in-small-box')) {
                        existingBoat.element.classList.remove('in-small-box');
                    }
                    
                    const indicator = existingBoat.element.querySelector('.user-indicator');
                    if (indicator) {
                        indicator.textContent = boatData.userGroup === 'leg' ? 'Leg' : 'Lat';
                    }
                    
                    updateSmallBoxes();
                }
                
                // Only process genuine new updates, not polling echoes
                if (boatData.operator && !['Initial', 'Assignment System', 'n8n Update'].includes(boatData.operator)) {
                    const logKey = `${boatData.id}-${boatData.status}-${boatData.operator}-${boatData.lastUpdated}`;
                    
                    if (!state.statusLogHistory.has(logKey)) {
                        console.log(`Processing status update: Boat ${boatData.id} to ${boatData.status} by ${boatData.operator}`);
                        
                        updateBoatStatusFromServer(boatData.id, boatData.status, boatData.operator);
                        state.statusLogHistory.set(logKey, true);
                        
                        // Clean old entries
                        if (state.statusLogHistory.size > 1000) {
                            const entries = Array.from(state.statusLogHistory.keys());
                            entries.slice(0, 200).forEach(key => state.statusLogHistory.delete(key));
                        }
                    } else {
                        // Update visual state only (no table update)
                        const boat = state.boats.get(boatData.id);
                        if (boat && boat.checkStatus !== boatData.checkStatus) {
                            boat.checkStatus = boatData.checkStatus;
                            if (boat.boat) {
                                boat.boat.className = `boat boat-type-${boat.type} status-${boatData.checkStatus}`;
                            }
                        }
                    }
                }
                
            } else {
                // Create new boat
                console.log(`Creating new boat ${boatData.id}`);
                const newBoat = createBoat({
                    id: boatData.id,
                    type: boatData.type || (boatData.id <= 70 ? 1 : 2),
                    userGroup: boatData.userGroup,
                    status: 'none',
                    checkStatus: 'none',
                    location: boatData.location || 'pier',
                    x: null,
                    y: null,
                    rotation: 0
                });
                
                // Log initial "No Check" status
                addStatusToTable(boatData.id, newBoat, 'none', 'Initial');
            }
        });
        
        // Update UI state only for view-only mode
        if (state.isViewOnly && serverState.uiState) {
            applyUIState(serverState.uiState);
        }

        // Update UI state for ALL instances to maintain synchronization
        if (serverState.uiState) {
            const currentDisplay = state.currentDisplay;
            applyUIState(serverState.uiState);
            if (!state.isViewOnly) {
                state.currentDisplay = currentDisplay;
                document.getElementById('mainDisplaySelect').value = currentDisplay;
            }
        }
        
        updateBoatCount();
        updateSmallBoxes();
        updateMainDisplay();
        
    } catch (error) {
        console.error('Error updating from server:', error);
    }
}

// Update boat status from server
function updateBoatStatusFromServer(boatId, newStatus, operator) {
    const boatData = state.boats.get(boatId);
    if (!boatData) return;
    
    const movementStatuses = ['tow', 'transit', 'operational-area', 'return-pier'];
    const isMovementStatus = movementStatuses.includes(newStatus);
    
    if (isMovementStatus) {
        // Movement status - move boat but PRESERVE check color
        const preservedCheckStatus = boatData.checkStatus || boatData.status;
        
        let targetLocation = '';
        if (newStatus === 'tow') targetLocation = 'tow';
        else if (newStatus === 'transit') targetLocation = 'transit';
        else if (newStatus === 'operational-area') targetLocation = 'operational-area';
        else if (newStatus === 'return-pier') targetLocation = 'pier';
        
        if (targetLocation) {
            if (boatData.podId) {
                movePodToArea(boatData.podId, targetLocation);
            } else {
                moveBoatToArea(boatId, targetLocation);
            }
            
            // CRITICAL: Restore check status after movement
            boatData.checkStatus = preservedCheckStatus;
            boatData.status = preservedCheckStatus; // Keep both in sync
            
            // Update visual appearance
            if (boatData.boat) {
                boatData.boat.className = `boat boat-type-${boatData.type} status-${preservedCheckStatus}`;
            }
            
            const allBoatElements = document.querySelectorAll(`#boat-${boatId}`);
            allBoatElements.forEach(el => {
                el.className = `boat boat-type-${boatData.type} status-${preservedCheckStatus}`;
            });
            
            addStatusToTable(boatId, boatData, newStatus, operator);
        }
    } else {
        // Check status - update color
        boatData.status = newStatus;
        boatData.checkStatus = newStatus;
        
        if (boatData.boat) {
            boatData.boat.className = `boat boat-type-${boatData.type} status-${newStatus}`;
        }
        
        const allBoatElements = document.querySelectorAll(`#boat-${boatId}`);
        allBoatElements.forEach(el => {
            el.className = `boat boat-type-${boatData.type} status-${newStatus}`;
        });
        
        addStatusToTable(boatId, boatData, newStatus, operator);
    }
    
    updateMainDisplay();
    updateSmallBoxes();
}
// Send status update to server
async function sendStatusUpdate(boatId, status, operator, checkStatus, timestamp) {
    try {
        const boatData = state.boats.get(boatId);
        if (!boatData) return;
        
        let currentArea = '';
        if (boatData.location === 'pier') currentArea = 'pierArea';
        else if (boatData.location === 'tow') currentArea = 'towArea';
        else if (boatData.location === 'transit') currentArea = 'transitArea';
        else if (boatData.location === 'operational-area') currentArea = 'operationalArea';
        
        await fetch(N8N_CONFIG.statusWebhook, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                boatId: boatId,
                status: status,
                location: boatData.location,
                operator: operator,
                timestamp: (timestamp || new Date()).toISOString(),
                checkStatus: checkStatus || boatData.checkStatus || boatData.status,
                isCheckStatus: !['tow', 'transit', 'operational-area', 'return-pier'].includes(status),
                currentArea: currentArea
            })
        });
    } catch (error) {
        console.error('Error sending status update:', error);
    }
}

// Send UI state to server (OPTIMIZED for size)
async function sendUIStateToServer(stateData) {
    try {
        // Prepare minimal state data
        const minimalLayouts = {};
        const minimalBackgrounds = {};
        
        ['pier', 'tow', 'transit', 'operational-area'].forEach(area => {
            const layout = state.areaLayouts.get(area);
            if (layout && (layout.boats.length > 0 || layout.pods.length > 0)) {
                minimalLayouts[area] = layout;
            }
            
            // Don't send backgrounds - they're too large
            // Background data will be stored locally only
        });
        
        // Create boat states object
        const boatStates = {};
        state.boats.forEach((boat, id) => {
            boatStates[id] = {
                x: boat.x,
                y: boat.y,
                rotation: boat.rotation || 0,
                location: boat.location,
                checkStatus: boat.checkStatus,
                status: boat.status,
                podId: boat.podId
            };
        });
        
        // Create pod states array
        const podStates = Array.from(state.pods.entries());
        
        const uiState = {
            type: 'saveUIState',
            state: {
                layouts: JSON.stringify(minimalLayouts),
                boatStates: JSON.stringify(boatStates),
                podStates: JSON.stringify(podStates),
                currentDisplay: state.currentDisplay,
                // Don't send statusTable HTML - reconstruct from data instead
                timestamp: new Date().toISOString()
            }
        };
        
        // Send to n8n webhook
        await fetch(N8N_CONFIG.statusWebhook, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(uiState)
        });
        
        console.log('UI state sent to server (optimized)');
    } catch (error) {
        console.error('Error sending UI state to server:', error);
    }
}

// Google Sheets Integration
function sendToGoogleSheets(boatId, boatData, status, operator, timestamp) {
    const webhookUrl = localStorage.getItem('googleSheetsWebhook');
    if (!webhookUrl) return;
    
    const prefix = boatData.type === 1 ? 'C' : 'G';
    const boatName = `${prefix}${boatId.toString().padStart(2, '0')}`;
    
    const movementStatuses = ['tow', 'transit', 'operational-area', 'return-pier'];
    const isMovement = movementStatuses.includes(status);
    
    const oldStatus = boatData.status || 'none';
    
    const statusLogData = {
        Timestamp: (timestamp || new Date()).toISOString(),
        BoatId: boatId.toString(),
        BoatType: boatData.type.toString(),
        UserGroup: boatData.userGroup,
        OldStatus: oldStatus,
        NewStatus: status,
        Location: boatData.location,
        Operator: operator,
        StatusType: isMovement ? 'Movement' : 'Check',
        CurrentArea: state.currentDisplay
    };
    
    const boatsData = {
        id: boatId,
        type: boatData.type,
        userGroup: boatData.userGroup,
        status: status,
        checkStatus: boatData.checkStatus || status,
        location: boatData.location,
        x: boatData.x || 0,
        y: boatData.y || 0,
        rotation: boatData.rotation || 0,
        operator: operator,
        lastUpdated: (timestamp || new Date()).toISOString()
    };
    
    fetch(webhookUrl, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            type: 'statusUpdate',
            statusLog: statusLogData,
            boatsData: boatsData,
            boat: boatName,
            boatId: boatId,
            timestamp: (timestamp || new Date()).toISOString()
        })
    }).then(response => {
        console.log('Google Sheets update sent:', {
            statusLog: statusLogData,
            boatsData: boatsData
        });
    }).catch(err => {
        console.error('Google Sheets update failed:', err);
    });
}

// Save webhook URL
window.saveWebhookUrl = function() {
    const url = document.getElementById('webhookUrl').value;
    if (url) {
        localStorage.setItem('googleSheetsWebhook', url);
        alert('Google Sheets webhook URL saved!');
    }
}
// Save/Load Functions

// Auto-save state (OPTIMIZED)
function autoSaveState() {
    const stateData = {
        boats: Array.from(state.boats.entries()).map(([id, boat]) => ({
            id: id,
            type: boat.type,
            userGroup: boat.userGroup,
            status: boat.status,
            checkStatus: boat.checkStatus,
            location: boat.location,
            x: boat.x,
            y: boat.y,
            rotation: boat.rotation,
            podId: boat.podId,
            troublePreviousStatus: boat.troublePreviousStatus
        })),
        pods: Array.from(state.pods.entries()).map(([id, pod]) => ({
            id: id,
            boats: pod.boats,
            location: pod.location,
            x: pod.x,
            y: pod.y,
            rotation: pod.rotation
        })),
        layouts: Object.fromEntries(state.areaLayouts),
        // Store backgrounds separately in localStorage due to size
        currentDisplay: state.currentDisplay,
        rowTracking: Object.fromEntries(state.rowTracking),
        troubleStatusMemory: Object.fromEntries(state.troubleStatusMemory),
        lastSaved: new Date().toISOString()
    };
    
    localStorage.setItem('boatDisplayAutoSave', JSON.stringify(stateData));
    
    // Save backgrounds separately
    state.areaBackgrounds.forEach((bgData, area) => {
        localStorage.setItem(`background-${area}`, bgData);
    });
    
    // Send optimized state to server
    sendUIStateToServer(stateData);
}

// Save all layouts
window.saveAllLayouts = function() {
    // Save current area first
    saveAreaLayout(state.currentDisplay);
    
    const data = {
        boats: Array.from(state.boats.entries()).map(([id, boat]) => ({
            id: id,
            type: boat.type,
            userGroup: boat.userGroup,
            status: boat.status,
            checkStatus: boat.checkStatus,
            location: boat.location,
            x: boat.x,
            y: boat.y,
            rotation: boat.rotation,
            podId: boat.podId,
            troublePreviousStatus: boat.troublePreviousStatus
        })),
        pods: Array.from(state.pods.entries()).map(([id, pod]) => ({
            id: id,
            boats: pod.boats,
            location: pod.location,
            x: pod.x,
            y: pod.y,
            rotation: pod.rotation
        })),
        layouts: Object.fromEntries(state.areaLayouts),
        currentDisplay: state.currentDisplay,
        statusTableData: getStatusTableData()
    };
    
    // Save locally
    localStorage.setItem('boatDisplayV14Complete', JSON.stringify(data));
    
    // Save backgrounds separately
    state.areaBackgrounds.forEach((bgData, area) => {
        localStorage.setItem(`background-${area}`, bgData);
    });
    
    // Save to server
    sendUIStateToServer(data);
    
    alert('All layouts saved and shared!');
}

// Get status table data (for saving)
function getStatusTableData() {
    const tbody = document.getElementById('statusTableBody');
    const rows = tbody.querySelectorAll('tr');
    const tableData = [];
    
    rows.forEach(row => {
        const boatId = row.dataset.boatId;
        const cells = {};
        
        row.querySelectorAll('[data-status]').forEach(cell => {
            if (cell.innerHTML.trim()) {
                cells[cell.dataset.status] = {
                    time: cell.dataset.time,
                    operator: cell.dataset.operator,
                    date: cell.dataset.date,
                    html: cell.innerHTML
                };
            }
        });
        
        if (Object.keys(cells).length > 0) {
            tableData.push({ boatId: boatId, cells: cells });
        }
    });
    
    return tableData;
}

// Load all layouts
window.loadAllLayouts = function() {
    // First try to load from manual save
    let saved = localStorage.getItem('boatDisplayV14Complete');
    
    // If no manual save, try auto-save
    if (!saved) {
        saved = localStorage.getItem('boatDisplayAutoSave');
    }
    
    if (saved) {
        try {
            const data = JSON.parse(saved);
            
            // Clear existing
            state.boats.clear();
            state.pods.clear();
            state.rowTracking.clear();
            state.areaLayouts.clear();
            state.areaBackgrounds.clear();
            state.troubleStatusMemory.clear();
            
            // Load boats
            if (data.boats) {
                data.boats.forEach(boatData => {
                    const boat = createBoat({
                        id: boatData.id,
                        type: boatData.type,
                        userGroup: boatData.userGroup,
                        status: boatData.status || 'none',
                        checkStatus: boatData.checkStatus || boatData.status || 'none',
                        location: boatData.location || 'pier',
                        x: boatData.x,
                        y: boatData.y,
                        rotation: boatData.rotation || 0
                    });
                    
                    if (boat) {
                        boat.checkStatus = boatData.checkStatus || boatData.status || 'none';
                        boat.location = boatData.location || 'pier';
                        boat.x = boatData.x;
                        boat.y = boatData.y;
                        boat.rotation = boatData.rotation || 0;
                        boat.podId = boatData.podId;
                        boat.troublePreviousStatus = boatData.troublePreviousStatus;
                    }
                });
            }
            
            // Load pods
            if (data.pods) {
                data.pods.forEach(podData => {
                    state.pods.set(podData.id, {
                        id: podData.id,
                        boats: podData.boats,
                        location: podData.location,
                        x: podData.x,
                        y: podData.y,
                        rotation: podData.rotation || 0
                    });
                });
            }
            
            // Load layouts
            if (data.layouts) {
                Object.entries(data.layouts).forEach(([area, layout]) => {
                    state.areaLayouts.set(area, layout);
                    localStorage.setItem(`areaLayout-${area}`, JSON.stringify(layout));
                });
            }
            
            // Load backgrounds from separate localStorage
            ['pier', 'tow', 'transit', 'operational-area'].forEach(area => {
                const bgData = localStorage.getItem(`background-${area}`);
                if (bgData) {
                    state.areaBackgrounds.set(area, bgData);
                }
            });
            
            // Load status table
            if (data.statusTableData) {
                loadStatusTableData(data.statusTableData);
            } else {
                // Try loading from separate storage
                const savedTableData = localStorage.getItem('statusTableData');
                if (savedTableData) {
                    loadStatusTableData(JSON.parse(savedTableData));
                }
            }
            
            // Load row tracking
            if (data.rowTracking) {
                Object.entries(data.rowTracking).forEach(([boatId, rowId]) => {
                    state.rowTracking.set(parseInt(boatId), rowId);
                });
            }
            
            // Load trouble status memory
            if (data.troubleStatusMemory) {
                Object.entries(data.troubleStatusMemory).forEach(([boatId, status]) => {
                    state.troubleStatusMemory.set(parseInt(boatId), status);
                });
            }
            
            // Set current display
            if (data.currentDisplay) {
                state.currentDisplay = data.currentDisplay;
                document.getElementById('mainDisplaySelect').value = data.currentDisplay;
            }
            
            updateBoatCount();
            updatePodCount();
            updateMainDisplay();
            updateSmallBoxes();
            
            console.log('Layouts loaded successfully with positions:', {
                boats: state.boats.size,
                layouts: state.areaLayouts.size,
                backgrounds: state.areaBackgrounds.size
            });
            
            alert('All layouts loaded successfully!');
        } catch (error) {
            console.error('Error loading layouts:', error);
            alert('Error loading layouts: ' + error.message);
        }
    } else {
        alert('No saved layouts found');
    }
}

// Load status table data
function loadStatusTableData(tableData) {
    const tbody = document.getElementById('statusTableBody');
    tbody.innerHTML = '';
    
    if (!tableData || !Array.isArray(tableData)) return;
    
    // Sort table data by boat ID
    tableData.sort((a, b) => {
        const boatIdA = parseInt(a.boatId);
        const boatIdB = parseInt(b.boatId);
        const boatA = state.boats.get(boatIdA);
        const boatB = state.boats.get(boatIdB);
        
        if (boatA && boatB) {
            if (boatA.userGroup !== boatB.userGroup) {
                return boatA.userGroup === 'lat' ? -1 : 1;
            }
            if (boatA.type !== boatB.type) return boatA.type - boatB.type;
            return boatIdA - boatIdB;
        }
        return 0;
    });
    
    // Recreate rows
    tableData.forEach(rowData => {
        const boatId = parseInt(rowData.boatId);
        const boat = state.boats.get(boatId);
        if (!boat) return;
        
        const prefix = boat.type === 1 ? 'C' : 'G';
        const paddedNumber = boatId.toString().padStart(2, '0');
        const boatName = `${prefix}${paddedNumber}`;
        
        const newRow = createNewRow(boatId, boatName, boat);
        tbody.appendChild(newRow);
        
        // Restore cell contents
        Object.entries(rowData.cells).forEach(([status, cellData]) => {
            let cell = newRow.querySelector(`[data-status="${status}"]`);
            if (!cell) {
                cell = newRow.querySelector(`td[data-status="${status}"]`);
            }
            
            if (cell && cellData) {
                if (cellData.html) {
                    cell.innerHTML = cellData.html;
                } else if (cellData.time && cellData.operator) {
                    cell.innerHTML = `${cellData.time}<br><small>${cellData.operator}</small>`;
                }
                
                if (cellData.time) cell.dataset.time = cellData.time;
                if (cellData.date) cell.dataset.date = cellData.date;
                if (cellData.operator) cell.dataset.operator = cellData.operator;
                
                // Apply appropriate status class
                cell.className = cell.className.split(' ').filter(c => !c.startsWith('status-')).join(' ');
                cell.className += ` status-${status.replace('-start', '').replace('-complete', '').replace('-hold', '')}`;
                
                if (status.includes('-start')) {
                    cell.className = cell.className.replace(/status-\w+/, '') + ` status-${status}`;
                } else if (status.includes('-hold')) {
                    cell.className = cell.className.replace(/status-\w+/, '') + ` status-${status}`;
                }
            }
        });
    });
}

// Load saved state on startup
function loadSavedState() {
    // Try to load auto-saved state first
    const autoSaveLoaded = loadAutoSavedState();
    
    if (autoSaveLoaded) {
        console.log('Auto-saved state loaded successfully');
    } else {
        // If no auto-save, try manual save
        const manualSave = localStorage.getItem('boatDisplayV14Complete');
        if (manualSave) {
            loadAllLayouts();
        }
    }
    
    // Load webhook URL
    const webhookUrl = localStorage.getItem('googleSheetsWebhook');
    if (webhookUrl) {
        document.getElementById('webhookUrl').value = webhookUrl;
    }
    
    // Load status table if separate data exists
    const savedTableData = localStorage.getItem('statusTableData');
    if (savedTableData && !document.getElementById('statusTableBody').innerHTML) {
        try {
            loadStatusTableData(JSON.parse(savedTableData));
        } catch (e) {
            console.error('Error loading status table data:', e);
        }
    }
    
    updateBoatCount();
    updatePodCount();
    updateMainDisplay();
    updateSmallBoxes();
}

// Load auto-saved state
function loadAutoSavedState() {
    const saved = localStorage.getItem('boatDisplayAutoSave');
    if (saved) {
        try {
            const stateData = JSON.parse(saved);
            console.log('Loading auto-saved state from', stateData.lastSaved);
            
            // Load the data (similar to loadAllLayouts)
            // Implementation is the same as in loadAllLayouts
            // but reading from auto-save format
            
            return true;
        } catch (error) {
            console.error('Error loading auto-saved state:', error);
            return false;
        }
    }
    return false;
}

// Generate view-only link
window.generateViewOnlyLink = function() {
    const currentUrl = window.location.origin + window.location.pathname;
    const viewOnlyUrl = currentUrl + '?view=only';
    
    navigator.clipboard.writeText(viewOnlyUrl).then(() => {
        alert('View-only link copied to clipboard:\n' + viewOnlyUrl);
    }).catch(() => {
        prompt('View-only link:', viewOnlyUrl);
    });
}

// Reset display
window.resetStatusDisplay = function() {
    if (confirm('Are you sure you want to reset the entire display? This will remove all boats, pods, and status data.')) {
        // Export data first
        const hasData = state.boats.size > 0 || document.getElementById('statusTableBody').innerHTML.trim() !== '';
        if (hasData) {
            if (confirm('Would you like to export the status data before resetting?')) {
                exportToCSV();
            }
        }
        
        // Clear everything
        state.boats.forEach(boat => {
            if (boat.element) boat.element.remove();
        });
        state.boats.clear();
        state.pods.clear();
        state.areaLayouts.clear();
        state.areaBackgrounds.clear();
        state.lastKnownStates.clear();
        state.statusLogHistory.clear();
        state.rowTracking.clear();
        state.troubleStatusMemory.clear();
        state.nextPositions.clear();
        
        // Re-initialize next positions
        ['pier', 'tow', 'transit', 'operational-area'].forEach(area => {
            state.nextPositions.set(area, { x: 20, y: 100, rowCount: 0 });
        });
        
        document.getElementById('statusTableBody').innerHTML = '';
        document.getElementById('mainDisplay').style.backgroundImage = '';
        
        // Clear localStorage
        const keys = Object.keys(localStorage);
        keys.forEach(key => {
            if (key.startsWith('boatDisplay') || key.startsWith('areaLayout') || 
                key.startsWith('background-') || key === 'statusTableData' || 
                key === 'statusTableHTML') {
                localStorage.removeItem(key);
            }
        });
        
        updateBoatCount();
        updatePodCount();
        updateMainDisplay();
        updateSmallBoxes();
        
        alert('Display has been reset.');
    }
}

// Additional CSS for split cells
const styleSheet = document.createElement('style');
styleSheet.textContent = `
    /* Side-by-side split cells */
    .split-cell {
        padding: 0;
        position: relative;
        border: 1px solid #444;
    }
    
    .split-cell-container {
        display: flex;
        width: 100%;
        height: 100%;
        min-height: 40px;
    }
    
    .split-cell-left, .split-cell-right {
        flex: 1;
        padding: 4px;
        border-right: 1px solid #444;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-size: 0.85em;
        line-height: 1.2;
    }
    
    .split-cell-right {
        border-right: none;
    }
    
    /* Triple split cell for Pierside */
    .split-cell-triple {
        padding: 0;
        position: relative;
        border: 1px solid #444;
    }
    
    .split-cell-triple-container {
        display: flex;
        width: 100%;
        height: 100%;
        min-height: 40px;
    }
    
    .split-cell-triple-left,
    .split-cell-triple-middle,
    .split-cell-triple-right {
        flex: 1;
        padding: 4px;
        border-right: 1px solid #444;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-size: 0.85em;
        line-height: 1.2;
    }
    
    .split-cell-triple-right {
        border-right: none;
    }
    
    /* Status cell colors for splits */
    td.status-none { 
        background-color: rgba(255, 0, 0, 0.7);
    }
    
    .split-cell-left.status-platform-start {
        background: repeating-linear-gradient(
            135deg,
            rgba(255, 140, 0, 0.7),
            rgba(255, 140, 0, 0.7) 3px,
            rgba(128, 128, 128, 0.7) 3px,
            rgba(128, 128, 128, 0.7) 6px
        );
    }
    
    .split-cell-right.status-platform {
        background-color: rgba(255, 140, 0, 0.7);
    }
    
    .split-cell-triple-left.status-pierside-start {
        background: repeating-linear-gradient(
            135deg,
            rgba(255, 255, 0, 0.7),
            rgba(255, 255, 0, 0.7) 3px,
            rgba(128, 128, 128, 0.7) 3px,
            rgba(128, 128, 128, 0.7) 6px
        );
    }
    
    .split-cell-triple-middle.status-pierside-hold {
        background: 
            repeating-linear-gradient(
                45deg,
                rgba(255, 255, 0, 0.7),
                rgba(255, 255, 0, 0.7) 3px,
                rgba(128, 128, 128, 0.7) 3px,
                rgba(128, 128, 128, 0.7) 6px
            ),
            repeating-linear-gradient(
                -45deg,
                rgba(255, 255, 0, 0.7),
                rgba(255, 255, 0, 0.7) 3px,
                rgba(128, 128, 128, 0.7) 3px,
                rgba(128, 128, 128, 0.7) 6px
            );
        background-blend-mode: multiply;
    }
    
    .split-cell-triple-right.status-pierside {
        background-color: rgba(255, 255, 0, 0.7);
    }
    
    .split-cell-left.status-pretow-start {
        background: repeating-linear-gradient(
            135deg,
            rgba(255, 255, 255, 0.7),
            rgba(255, 255, 255, 0.7) 3px,
            rgba(128, 128, 128, 0.7) 3px,
            rgba(128, 128, 128, 0.7) 6px
        );
    }
    
    .split-cell-right.status-pretow {
        background: repeating-linear-gradient(
            45deg,
            rgba(255, 255, 255, 0.7),
            rgba(255, 255, 255, 0.7) 5px,
            rgba(0, 255, 0, 0.7) 5px,
            rgba(0, 255, 0, 0.7) 10px
        );
    }
    
    .split-cell-left.status-operational-start {
        background: repeating-linear-gradient(
            135deg,
            rgba(0, 255, 0, 0.7),
            rgba(0, 255, 0, 0.7) 3px,
            rgba(128, 128, 128, 0.7) 3px,
            rgba(128, 128, 128, 0.7) 6px
        );
    }
    
    .split-cell-right.status-operational {
        background-color: rgba(0, 255, 0, 0.7);
    }
    
    /* Movement status cells */
    td.status-tow, 
    td.status-transit, 
    td.status-oparea, 
    td.status-return { 
        border: 2px solid #444;
        font-weight: bold;
    }
    
    /* Table controls */
    .table-controls {
        display: flex;
        gap: 10px;
        margin-top: 10px;
        align-items: center;
    }
    
    .table-controls button {
        padding: 10px 20px;
        background: linear-gradient(45deg, #00bfff, #b19cd9);
        border: none;
        border-radius: 5px;
        color: #fff;
        font-weight: bold;
        cursor: pointer;
        transition: transform 0.2s;
        white-space: nowrap;
    }
    
    .table-controls button:hover {
        transform: scale(1.05);
    }
    
    .google-sheets-info {
        flex: 1;
        padding: 15px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 5px;
        margin-left: 20px;
    }
    
    .google-sheets-info p {
        margin-bottom: 10px;
        color: #00bfff;
        font-weight: bold;
    }
    
    .google-sheets-info input {
        width: 100%;
        padding: 8px;
        margin-bottom: 10px;
        background: #333;
        border: 1px solid #555;
        border-radius: 5px;
        color: #fff;
    }
    
    .controls {
        margin-top: 20px;
        padding: 20px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
    }
    
    .controls button {
        padding: 10px 20px;
        background: linear-gradient(45deg, #00bfff, #b19cd9);
        border: none;
        border-radius: 5px;
        color: #fff;
        font-weight: bold;
        cursor: pointer;
        transition: transform 0.2s;
    }
    
    .controls button:hover {
        transform: scale(1.05);
    }
    
    .boat-count {
        margin-left: auto;
        padding: 10px 20px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 5px;
    }
`;
document.head.appendChild(styleSheet);

// Log initialization complete
console.log('Boat Status Display System v14 - OPTIMIZED');
console.log('Key improvements:');
console.log('✅ Reduced payload size for n8n webhook');
console.log('✅ Separated background storage from state data');
console.log('✅ Optimized status table persistence');
console.log('✅ Improved memory management');
console.log('✅ Maintained all functionality from v13');
console.log('✅ Fixed check status color preservation during movement');

</script>
</body>
</html>
