<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orange USV Status Display System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: #1a1a1a;
        color: #fff;
        overflow-x: auto;
        min-height: 100vh;
    }

    .container {
        max-width: 1600px;
        margin: 0 auto;
        padding: 20px;
    }

    .header {
        text-align: center;
        margin-bottom: 20px;
        padding: 15px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
    }

    .header h1 {
        font-size: 2.5em;
        margin-bottom: 5px;
        background: linear-gradient(45deg, #00bfff, #b19cd9);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
    }

    /* Main Display Controls */
    .display-controls {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 5px;
        align-items: center;
    }

    .display-controls label {
        font-weight: bold;
        color: #00bfff;
    }

    .display-controls select {
        padding: 5px 10px;
        background: #333;
        border: 1px solid #555;
        color: #fff;
        border-radius: 3px;
        cursor: pointer;
    }

    .display-controls button {
        padding: 5px 15px;
        background: linear-gradient(45deg, #00bfff, #b19cd9);
        border: none;
        border-radius: 3px;
        color: #fff;
        font-weight: bold;
        cursor: pointer;
        transition: transform 0.2s;
    }

    .display-controls button:hover {
        transform: scale(1.05);
    }

    /* Main display area */
    .main-display {
        position: relative;
        background: #2a2a2a;
        border: 2px solid #444;
        border-radius: 10px;
        min-height: 600px;
        height: 600px;
        margin-bottom: 20px;
        overflow: hidden;
        background-size: contain;
        background-position: center;
        background-repeat: no-repeat;
        cursor: default;
    }

    .main-display.draggable-area {
        cursor: crosshair;
    }

    /* Small status boxes */
    .status-boxes {
        display: flex;
        gap: 20px;
        flex-wrap: wrap;
        justify-content: center;
        margin-bottom: 20px;
    }

    .status-box {
        background: rgba(255, 255, 255, 0.05);
        border: 2px solid #444;
        border-radius: 10px;
        padding: 10px;
        min-width: 200px;
        max-width: 250px;
        flex: 1;
        position: relative;
    }

    .status-box.drag-over {
        border-color: #00bfff;
        background: rgba(0, 191, 255, 0.1);
    }

    .status-box h3 {
        color: #00bfff;
        font-size: 0.9em;
        margin-bottom: 10px;
        text-align: center;
    }

    .status-box-content {
        min-height: 80px;
        overflow: visible;
        position: relative;
        display: flex;
        flex-wrap: wrap;
        gap: 3px;
        padding: 5px;
    }

    /* Pod styles */
    .pod {
        display: inline-flex;
        flex-wrap: wrap;
        gap: 3px;
        padding: 3px;
        margin: 2px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px dashed #666;
        border-radius: 5px;
        position: relative;
        cursor: move;
    }

    .pod.selected {
        background: rgba(0, 191, 255, 0.2);
        border-color: #00bfff;
    }

    .pod.in-small-box {
        cursor: grab;
    }

    /* Legend */
    .legend {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 15px;
        margin-bottom: 20px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
        font-size: 0.85em;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 6px;
    }

    /* Boat wrapper styles */
    .legend-boat-wrapper {
        width: 16px;
        height: 32px;
        position: relative;
        padding: 2px;
        background: #fff;
        clip-path: polygon(50% 0%, 85% 15%, 95% 35%, 95% 65%, 85% 85%, 75% 100%, 25% 100%, 15% 85%, 5% 65%, 5% 35%, 15% 15%);
        display: inline-block;
    }

    .legend-boat-wrapper.user-leg {
        background: #b19cd9;
    }

    .legend-boat-wrapper.user-lat {
        background: #00bfff;
    }

    .legend-boat {
        width: 12px;
        height: 28px;
        position: relative;
        overflow: visible;
        clip-path: polygon(50% 0%, 85% 15%, 95% 35%, 95% 65%, 85% 85%, 75% 100%, 25% 100%, 15% 85%, 5% 65%, 5% 35%, 15% 15%);
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #ff0000;
    }

    /* Status colors - Complete states */
    .legend-boat.status-none,
    .boat.status-none,
    .status-none { background-color: #ff0000 !important; }
    
    .legend-boat.status-platform,
    .boat.status-platform,
    .status-platform { background-color: #ff8c00 !important; }
    
    .legend-boat.status-pierside,
    .boat.status-pierside,
    .status-pierside { background-color: #ffff00 !important; }
    
    .legend-boat.status-pretow,
    .boat.status-pretow,
    .status-pretow { 
        background: repeating-linear-gradient(
            45deg,
            #ffffff,
            #ffffff 2px,
            #00ff00 2px,
            #00ff00 4px
        ) !important;
    }
    
    .legend-boat.status-operational,
    .boat.status-operational,
    .status-operational { background-color: #00ff00 !important; }
    
    /* Status colors - Start states (with grey hatching) */
    .legend-boat.status-platform-start,
    .boat.status-platform-start,
    .status-platform-start { 
        background: repeating-linear-gradient(
            135deg,
            #ff8c00,
            #ff8c00 3px,
            #808080 3px,
            #808080 6px
        ) !important;
    }
    
    .legend-boat.status-pierside-start,
    .boat.status-pierside-start,
    .status-pierside-start { 
        background: repeating-linear-gradient(
            135deg,
            #ffff00,
            #ffff00 3px,
            #808080 3px,
            #808080 6px
        ) !important;
    }
    
    /* Pierside Hold with X-hatch pattern */
    .legend-boat.status-pierside-hold,
    .boat.status-pierside-hold,
    .status-pierside-hold {
        background: 
            repeating-linear-gradient(
                45deg,
                #ffff00,
                #ffff00 3px,
                #808080 3px,
                #808080 6px
            ),
            repeating-linear-gradient(
                -45deg,
                #ffff00,
                #ffff00 3px,
                #808080 3px,
                #808080 6px
            ) !important;
        background-blend-mode: multiply;
    }
    
    /* Pre-Tow Start - WHITE and GREY hatched */
    .legend-boat.status-pretow-start,
    .boat.status-pretow-start,
    .status-pretow-start { 
        background: repeating-linear-gradient(
            135deg,
            #ffffff,
            #ffffff 3px,
            #808080 3px,
            #808080 6px
        ) !important;
    }
    
    .legend-boat.status-operational-start,
    .boat.status-operational-start,
    .status-operational-start { 
        background: repeating-linear-gradient(
            135deg,
            #00ff00,
            #00ff00 3px,
            #808080 3px,
            #808080 6px
        ) !important;
    }
    
    /* Trouble status */
    .legend-boat.status-trouble,
    .boat.status-trouble,
    .status-trouble { 
        background: repeating-linear-gradient(
            45deg,
            #ff0000,
            #ff0000 3px,
            #ff8c00 3px,
            #ff8c00 6px
        ) !important;
    }

    /* Boat styles */
    .boat {
        position: absolute;
        cursor: grab;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 11px;
        font-weight: bold;
        transition: all 0.3s ease;
        overflow: visible;
        clip-path: polygon(50% 0%, 85% 15%, 95% 35%, 95% 65%, 85% 85%, 75% 100%, 25% 100%, 15% 85%, 5% 65%, 5% 35%, 15% 15%);
        background-color: #ff0000;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .boat:active {
        cursor: grabbing;
    }

    /* Boat wrapper */
    .boat-wrapper {
        position: absolute;
        background: transparent;
        display: inline-block;
        cursor: grab;
    }

    .boat-wrapper:active {
        cursor: grabbing;
    }

    .boat-wrapper.in-small-box {
        position: relative !important;
        display: inline-block;
        margin: 2px;
        cursor: grab;
    }
    
    /* Ghost image for dragging */
    .boat-wrapper.dragging {
        opacity: 0.7;
        cursor: grabbing;
    }

    .boat-outline {
        position: absolute;
        top: -2px;
        left: -2px;
        right: -2px;
        bottom: -2px;
        background: #fff;
        clip-path: polygon(50% 0%, 85% 15%, 95% 35%, 95% 65%, 85% 85%, 75% 100%, 25% 100%, 15% 85%, 5% 65%, 5% 35%, 15% 15%);
        z-index: 0;
    }

    .boat-wrapper.user-leg .boat-outline {
        background: #b19cd9;
    }

    .boat-wrapper.user-lat .boat-outline {
        background: #00bfff;
    }

    /* Context Menu */
    .context-menu {
        position: fixed;
        background: #2a2a2a;
        border: 2px solid #444;
        border-radius: 8px;
        padding: 5px 0;
        display: none;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        max-height: 80vh;
        max-width: 300px;
        overflow-y: auto;
        overflow-x: visible;
    }

    .context-menu-item {
        padding: 8px 20px;
        cursor: pointer;
        color: #fff;
        font-size: 0.9em;
        transition: background 0.2s;
        display: flex;
        align-items: center;
        gap: 8px;
        white-space: nowrap;
        position: relative;
    }

    .context-menu-item:hover {
        background: rgba(0, 191, 255, 0.2);
    }
    
    .context-menu-item.has-submenu {
        padding-right: 30px;
    }
    
    .context-menu-item.has-submenu .submenu {
        position: absolute;
        min-width: 150px;
        max-height: 300px;
        overflow-y: auto;
        z-index: 1001;
        background: #2a2a2a;
        border: 2px solid #444;
        border-radius: 8px;
        display: none;
        left: 100%;
        top: -5px;
        margin-left: 5px;
        padding: 5px 0;
    }
    
    .context-menu-item.has-submenu::after {
        content: '▶';
        position: absolute;
        right: 10px;
        opacity: 0.6;
    }

    /* Make submenu more stable on hover */
    .context-menu-item.has-submenu:hover .submenu,
    .context-menu-item.has-submenu .submenu:hover {
        display: block !important;
        opacity: 1;
        pointer-events: all;
    }

    /* Add a hover bridge to prevent menu from closing */
    .context-menu-item.has-submenu::before {
        content: '';
        position: absolute;
        left: 100%;
        top: 0;
        width: 10px;
        height: 100%;
        z-index: 1000;
    }

    .context-menu-separator {
        height: 1px;
        background: #444;
        margin: 5px 0;
    }

    /* Scrollable section for pod menu */
    .context-menu-scrollable {
        max-height: 60vh;
        overflow-y: auto;
    }
    
    /* Additional boat styles */
    .boat-type-1 {
        width: 30px;
        height: 60px;
    }

    .boat-type-2 {
        width: 26px;
        height: 44px;
    }

    .boat:hover {
        transform: scale(1.1);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    }

    .boat-number {
        background: rgba(255, 255, 255, 0.9);
        color: #000;
        padding: 2px 3px;
        border-radius: 3px;
        font-size: 10px;
        font-weight: bold;
        z-index: 2;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        white-space: nowrap;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
    }

    .user-indicator {
        position: absolute;
        bottom: 3px;
        right: 3px;
        width: 14px;
        height: 14px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 9px;
        font-weight: bold;
        color: #fff;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        z-index: 3;
    }

    .user-leg .user-indicator {
        background-color: #b19cd9;
    }

    .user-lat .user-indicator {
        background-color: #00bfff;
    }

    /* Rotation handle */
    .rotation-handle {
        position: absolute;
        top: -15px;
        left: 50%;
        transform: translateX(-50%);
        width: 12px;
        height: 12px;
        background: rgba(255, 255, 255, 0.9);
        border: 2px solid #333;
        border-radius: 50%;
        cursor: grab;
        opacity: 0;
        transition: opacity 0.3s ease;
        z-index: 10;
        pointer-events: all;
    }

    .boat-wrapper:hover .rotation-handle {
        opacity: 1;
    }

    .rotation-handle:hover {
        background: #fff;
        transform: translateX(-50%) scale(1.2);
    }

    .rotation-handle:active {
        cursor: grabbing;
    }

    .boat-wrapper.in-small-box .rotation-handle {
        display: none;
    }

    /* Additional CSS for status tracking table */
    .manual-override-dialog {
        position: fixed;
        background: #2a2a2a;
        border: 2px solid #444;
        border-radius: 8px;
        padding: 15px;
        z-index: 10000;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    }
    
    .status-tracker {
        margin-top: 30px;
        padding: 20px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
    }

    .status-tracker h2 {
        color: #00bfff;
        margin-bottom: 20px;
        text-align: center;
    }

    .table-container {
        overflow-x: auto;
        margin-bottom: 20px;
        max-height: 400px;
        overflow-y: auto;
        position: relative;
    }

    table {
        width: 100%;
        border-collapse: collapse;
        background: rgba(0, 0, 0, 0.3);
    }

    thead {
        position: sticky;
        top: 0;
        z-index: 10;
        background: #1a1a1a;
    }

    th {
        padding: 8px;
        border: 1px solid #444;
        text-align: center;
        background: rgba(0, 191, 255, 0.2);
        color: #00bfff;
        position: sticky;
        top: 0;
        z-index: 10;
        white-space: nowrap;
    }

    td {
        padding: 8px;
        border: 1px solid #444;
        text-align: center;
        color: #000 !important;
        font-size: 0.85em;
        line-height: 1.2;
        font-weight: bold;
        text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
        vertical-align: middle;
        height: 40px;
    }
    
    /* Movement status cells with check status background */
    td.status-tow, 
    td.status-transit, 
    td.status-oparea, 
    td.status-return { 
        border: 2px solid #444;
        font-weight: bold;
    }
    
    /* Side-by-side split cells */
    .split-cell {
        padding: 0;
        position: relative;
        border: 1px solid #444;
    }
    
    .split-cell-container {
        display: flex;
        width: 100%;
        height: 100%;
        min-height: 40px;
    }
    
    .split-cell-left, .split-cell-right {
        flex: 1;
        padding: 4px;
        border-right: 1px solid #444;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-size: 0.85em;
        line-height: 1.2;
    }
    
    .split-cell-right {
        border-right: none;
    }
    
    /* Triple split cell for Pierside */
    .split-cell-triple {
        padding: 0;
        position: relative;
        border: 1px solid #444;
    }
    
    .split-cell-triple-container {
        display: flex;
        width: 100%;
        height: 100%;
        min-height: 40px;
    }
    
    .split-cell-triple-left,
    .split-cell-triple-middle,
    .split-cell-triple-right {
        flex: 1;
        padding: 4px;
        border-right: 1px solid #444;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-size: 0.85em;
        line-height: 1.2;
    }
    
    .split-cell-triple-right {
        border-right: none;
    }
    
    /* Table controls */
    .table-controls {
        display: flex;
        gap: 10px;
        margin-top: 10px;
        align-items: center;
    }
    
    .table-controls button {
        padding: 10px 20px;
        background: linear-gradient(45deg, #00bfff, #b19cd9);
        border: none;
        border-radius: 5px;
        color: #fff;
        font-weight: bold;
        cursor: pointer;
        transition: transform 0.2s;
        white-space: nowrap;
    }
    
    .table-controls button:hover {
        transform: scale(1.05);
    }
    
    .google-sheets-info {
        flex: 1;
        padding: 15px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 5px;
        margin-left: 20px;
    }
    
    .google-sheets-info p {
        margin-bottom: 10px;
        color: #00bfff;
        font-weight: bold;
    }
    
    .google-sheets-info input {
        width: 100%;
        padding: 8px;
        margin-bottom: 10px;
        background: #333;
        border: 1px solid #555;
        border-radius: 5px;
        color: #fff;
    }
    
    .controls {
        margin-top: 20px;
        padding: 20px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
    }
    
    .controls button {
        padding: 10px 20px;
        background: linear-gradient(45deg, #00bfff, #b19cd9);
        border: none;
        border-radius: 5px;
        color: #fff;
        font-weight: bold;
        cursor: pointer;
        transition: transform 0.2s;
    }
    
    .controls button:hover {
        transform: scale(1.05);
    }
    
    .boat-count {
        margin-left: auto;
        padding: 10px 20px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 5px;
    }
</style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Orange USV Status Display System</h1>
            <p>Capstone Aug 2025</p>
        </div>
    <div class="legend">
        <div class="legend-item">
            <div class="legend-boat-wrapper">
                <div class="legend-boat status-none">
                    <span class="boat-number">C</span>
                </div>
            </div>
            <span>C Boat</span>
        </div>
        <div class="legend-item">
            <div class="legend-boat-wrapper">
                <div class="legend-boat status-none">
                    <span class="boat-number">G</span>
                </div>
            </div>
            <span>G Boat</span>
        </div>
        <div class="legend-item">
            <div class="legend-boat-wrapper">
                <div class="legend-boat status-none"></div>
            </div>
            <span>No Check</span>
        </div>
        <div class="legend-item">
            <div class="legend-boat-wrapper">
                <div class="legend-boat status-platform-start"></div>
            </div>
            <span>Platform Start</span>
        </div>
        <div class="legend-item">
            <div class="legend-boat-wrapper">
                <div class="legend-boat status-platform"></div>
            </div>
            <span>Platform Complete</span>
        </div>
        <div class="legend-item">
            <div class="legend-boat-wrapper">
                <div class="legend-boat status-pierside-start"></div>
            </div>
            <span>Pierside Start</span>
        </div>
        <div class="legend-item">
            <div class="legend-boat-wrapper">
                <div class="legend-boat status-pierside-hold"></div>
            </div>
            <span>Pierside Hold</span>
        </div>
        <div class="legend-item">
            <div class="legend-boat-wrapper">
                <div class="legend-boat status-pierside"></div>
            </div>
            <span>Pierside Complete</span>
        </div>
        <div class="legend-item">
            <div class="legend-boat-wrapper">
                <div class="legend-boat status-pretow-start"></div>
            </div>
            <span>Pre-Tow Start</span>
        </div>
        <div class="legend-item">
            <div class="legend-boat-wrapper">
                <div class="legend-boat status-pretow"></div>
            </div>
            <span>Pre-Tow Complete</span>
        </div>
        <div class="legend-item">
            <div class="legend-boat-wrapper">
                <div class="legend-boat status-operational-start"></div>
            </div>
            <span>Post-Tow Start</span>
        </div>
        <div class="legend-item">
            <div class="legend-boat-wrapper">
                <div class="legend-boat status-operational"></div>
            </div>
            <span>Post-Tow Complete</span>
        </div>
        <div class="legend-item">
            <div class="legend-boat-wrapper">
                <div class="legend-boat status-trouble"></div>
            </div>
            <span>Trouble</span>
        </div>
        <div class="legend-item">
            <div class="legend-boat-wrapper user-leg">
                <div class="legend-boat"></div>
                <div class="user-indicator">Leg</div>
            </div>
            <span>Leg</span>
        </div>
        <div class="legend-item">
            <div class="legend-boat-wrapper user-lat">
                <div class="legend-boat"></div>
                <div class="user-indicator">Lat</div>
            </div>
            <span>Lat</span>
        </div>
        <div class="legend-item">
            <div class="pod" style="position: relative; display: inline-block; padding: 2px;">
                <div style="width: 10px; height: 20px; background: #666; margin: 1px;"></div>
                <div style="width: 10px; height: 20px; background: #666; margin: 1px;"></div>
            </div>
            <span>Pod (grouped boats)</span>
        </div>
    </div>
    
    <!-- Main Display Controls -->
    <div class="display-controls">
        <label>Main Display:</label>
        <select id="mainDisplaySelect">
            <option value="pier">Pier Area</option>
            <option value="tow">Being Towed</option>
            <option value="transit">In Transit</option>
            <option value="operational-area">Operational Area</option>
        </select>
        <input type="file" id="bgImageInput" accept="image/*" style="display: none;">
        <button onclick="document.getElementById('bgImageInput').click()">Set Background for This Display</button>
        <button onclick="clearBackground()">Clear Background</button>
    </div>

    <!-- Main Display Area -->
    <div class="main-display draggable-area" id="mainDisplay">
        <!-- Boats will be dynamically displayed here -->
    </div>

    <!-- Small Status Boxes -->
    <div class="status-boxes">
        <div class="status-box" data-area="pier">
            <h3>At Pier</h3>
            <div class="status-box-content" id="pierSmallBox"></div>
        </div>
        <div class="status-box" data-area="tow">
            <h3>Being Towed</h3>
            <div class="status-box-content" id="towSmallBox"></div>
        </div>
        <div class="status-box" data-area="transit">
            <h3>In Transit</h3>
            <div class="status-box-content" id="transitSmallBox"></div>
        </div>
        <div class="status-box" data-area="operational-area">
            <h3>Operational Area</h3>
            <div class="status-box-content" id="operationalAreaSmallBox"></div>
        </div>
    </div>

    <div class="controls">
        <button onclick="saveAllLayouts()">Save All</button>
        <button onclick="loadAllLayouts()">Load All</button>
        <button onclick="exportToCSV()">Export Status Log</button>
        <button onclick="generateViewOnlyLink()">Generate View-Only Link</button>
        <button onclick="window.resetStatusDisplay()" style="background: linear-gradient(45deg, #ff6b6b, #ff5252);">Reset Display</button>
        <div class="boat-count">
            Total Boats: <span id="boatCount">0</span> | 
            Total Pods: <span id="podCount">0</span>
        </div>
    </div>

    <div class="status-tracker">
        <h2>Status Tracking</h2>
        <div class="table-container">
            <table id="statusTable">
                <thead>
                    <tr>
                        <th rowspan="2">Boat</th>
                        <th rowspan="2">Group</th>
                        <th rowspan="2">No Check</th>
                        <th colspan="2">Platform</th>
                        <th colspan="3">Pierside</th>
                        <th colspan="2">Pre-Tow</th>
                        <th colspan="2">Post-Tow</th>
                        <th rowspan="2">Trouble</th>
                        <th rowspan="2">Towed</th>
                        <th rowspan="2">Transit</th>
                        <th rowspan="2">Op Area</th>
                        <th rowspan="2">Return</th>
                    </tr>
                    <tr>
                        <th>Start</th>
                        <th>Done</th>
                        <th>Start</th>
                        <th>Hold</th>
                        <th>Done</th>
                        <th>Start</th>
                        <th>Done</th>
                        <th>Start</th>
                        <th>Done</th>
                    </tr>
                </thead>
                <tbody id="statusTableBody">
                </tbody>
            </table>
        </div>
        <div class="table-controls">
            <button onclick="exportToCSV()">Export to CSV</button>
            <button onclick="clearStatusTable()">Clear Table</button>
            <div class="google-sheets-info">
                <p>Google Sheets Integration:</p>
                <input type="text" id="webhookUrl" placeholder="Google Sheets webhook URL" />
                <button onclick="saveWebhookUrl()">Save URL</button>
            </div>
        </div>
    </div>
</div>

<!-- Context Menu (hidden by default) -->
<div class="context-menu" id="contextMenu" style="display: none; position: fixed;"></div>
<script>
// Global state management - COMPLETE AND PROPERLY INITIALIZED
const state = {
    boats: new Map(),
    pods: new Map(),
    currentDisplay: 'pier',
    areaLayouts: new Map(),
    areaBackgrounds: new Map(),
    draggedItem: null,
    draggedFromArea: null,
    rotatingBoat: null,
    rotatingPod: null,
    selectedPod: null,
    isBatchUpdate: false,
    batchUpdateKey: null, 
    isViewOnly: false,
    pollTimer: null,
    
    // CRITICAL: Complete tracking systems
    checkStatusHistory: new Map(),     // Track check status updates
    movementHistory: new Map(),        // Track movement updates
    tableEntryHistory: new Map(),      // Track what's in the table
    statusLogHistory: new Map(),       // Track all status updates
    processedUpdates: new Set(),       // Track processed server updates
    
    rowTracking: new Map(),
    troubleStatusMemory: new Map(),
    nextPositions: new Map(),
    boatRowCounts: new Map(),
    isLoadingLayouts: false
};

// Constants
const N8N_CONFIG = {
    assignmentWebhook: 'https://n8n.tacticalleadingedge.com/webhook/boat-assignments',
    statusWebhook: 'https://n8n.tacticalleadingedge.com/webhook/boat-status-update',
    stateWebhook: 'https://n8n.tacticalleadingedge.com/webhook/boat-state'
};

const POLL_INTERVAL = 5000;
const BOAT_SPACING = {
    horizontal: 40,
    vertical: 75,
    podSpacing: 6.5
};

// Initialize system
document.addEventListener('DOMContentLoaded', function() {
    initializeSystem();
});

function initializeSystem() {
    // Check view-only mode
    const urlParams = new URLSearchParams(window.location.search);
    state.isViewOnly = urlParams.get('view') === 'only';
    if (state.isViewOnly) {
        enableViewOnlyMode();
        loadViewOnlyState();
    } else {
        loadSharedState();
    }

    // Initialize displays
    setupMainDisplay();
    setupContextMenu();
    setupEventListeners();
    setupSmallBoxDragDrop();
    setupBackgroundUpload();

    // Initialize next positions for each area
    ['pier', 'tow', 'transit', 'operational-area'].forEach(area => {
        state.nextPositions.set(area, { x: 20, y: 100, rowCount: 0 });
    });

    // Load saved state
    loadSavedState();

    // Always try to fetch boats from server on startup
    setTimeout(() => {
        if (state.boats.size === 0) {
            console.log('No boats found locally, fetching from server...');
            fetchBoatsFromServer();
        }
    }, 1000);
    
    // Start polling
    startPolling();

    console.log('[OK] Orange USV Status Display System initialized - FINAL FIXED VERSION');
}

// CENTRALIZED VISUAL UPDATE FUNCTION
function updateBoatVisuals(boatId, checkStatus) {
    const boatData = state.boats.get(boatId);
    if (!boatData) return;
    
    const statusClass = `boat boat-type-${boatData.type} status-${checkStatus}`;
    
    // Update main boat element
    if (boatData.boat) {
        boatData.boat.className = statusClass;
    }
    
    // Update all boat elements in DOM
    document.querySelectorAll(`#boat-${boatId}`).forEach(el => {
        el.className = statusClass;
    });
    
    // Update wrapper boats
    const wrapper = document.getElementById(`boat-wrapper-${boatId}`);
    if (wrapper) {
        const boatEl = wrapper.querySelector('.boat');
        if (boatEl) {
            boatEl.className = statusClass;
        }
    }
    
    // Update boats in pods and small boxes
    document.querySelectorAll(`.boat-wrapper[id="boat-wrapper-${boatId}"] .boat`).forEach(el => {
        el.className = statusClass;
    });
}

// Update check status (color) without changing location
function updateCheckStatus(boatId, newCheckStatus, operator = 'Unknown') {
    const boatData = state.boats.get(boatId);
    if (!boatData) return;
    
    const timestamp = new Date().toISOString();
    
    // Handle trouble status memory
    if (newCheckStatus === 'trouble' && boatData.checkStatus !== 'trouble') {
        boatData.troublePreviousStatus = boatData.checkStatus;
    }
    
    // Update check status
    const oldCheckStatus = boatData.checkStatus;
    boatData.checkStatus = newCheckStatus;
    boatData.status = newCheckStatus; // Keep both in sync
    boatData.lastCheckUpdate = timestamp;
    boatData.lastCheckOperator = operator;
    
    // Update visuals immediately
    updateBoatVisuals(boatId, newCheckStatus);
    
    // Add to status table
    addStatusToTable(boatId, boatData, newCheckStatus, operator, timestamp);
    
    // Send to server
    sendUpdateToServer(boatId, 'check', newCheckStatus, operator);
    
    // Send to Google Sheets
    sendToGoogleSheets(boatId, boatData, newCheckStatus, operator);
    
    // Save state
    autoSaveState();
    
    // Update displays
    updateMainDisplay();
    updateSmallBoxes();
    
    console.log(`Check status updated: Boat ${boatId} -> ${newCheckStatus} by ${operator}`);
}

// Update movement status (location) without changing color
function updateMovementStatus(boatId, movementType, operator = 'Unknown') {
    const boatData = state.boats.get(boatId);
    if (!boatData) return;
    
    const timestamp = new Date().toISOString();
    
    // Map movement type to location
    const locationMap = {
        'tow': 'tow',
        'transit': 'transit',
        'operational-area': 'operational-area',
        'return-pier': 'pier'
    };
    
    const newLocation = locationMap[movementType] || movementType;
    
    // Update location WITHOUT changing check status
    const oldLocation = boatData.location;
    boatData.location = newLocation;
    boatData.lastMovementUpdate = timestamp;
    boatData.lastMovementOperator = operator;
    
    // Move boat physically
    if (boatData.podId) {
        const pod = state.pods.get(boatData.podId);
        if (pod) {
            pod.location = newLocation;
            // Don't process other boats here, let the caller handle pod movements
        }
    }
    
    // Clear position for new area (only if actually moving areas)
    if (oldLocation !== newLocation) {
        boatData.x = null;
        boatData.y = null;
    }
    
    // Add to table with movement type
    addStatusToTable(boatId, boatData, movementType, operator, timestamp);
    
    // Send to server
    sendUpdateToServer(boatId, 'movement', movementType, operator);
    
    // Send to Google Sheets
    sendToGoogleSheets(boatId, boatData, movementType, operator);
    
    // Save state
    autoSaveState();
    
    // Update displays
    updateMainDisplay();
    updateSmallBoxes();
    
    console.log(`Movement updated: Boat ${boatId} -> ${newLocation} (${movementType}) by ${operator}`);
}

// Send updates to server with proper format
async function sendUpdateToServer(boatId, updateType, status, operator) {
    const boatData = state.boats.get(boatId);
    if (!boatData) return;
const timestamp = new Date().toISOString();

// Update local timestamps
if (updateType === 'check') {
    boatData.lastCheckUpdate = timestamp;
    boatData.lastCheckOperator = operator;
} else if (updateType === 'movement') {
    boatData.lastMovementUpdate = timestamp;
    boatData.lastMovementOperator = operator;
}

try {
    const payload = {
        boatId: boatId,
        type: boatData.type,
        userGroup: boatData.userGroup,
        // CRITICAL: Always send the current check status, not the movement status
        checkStatus: boatData.checkStatus,  
        status: boatData.checkStatus,  // Legacy field - MUST be checkStatus, not the status parameter
        location: boatData.location,
        updateType: updateType,
        updateStatus: status,  // This is what was actually updated (could be movement or check)
        operator: operator,
        lastUpdated: timestamp,
        timestamp: timestamp,
        x: boatData.x || 0,
        y: boatData.y || 0,
        rotation: boatData.rotation || 0
    };
    
    // Also send to Google Sheets webhook if configured
    const webhookUrl = localStorage.getItem('googleSheetsWebhook');
    if (webhookUrl) {
        await fetch(webhookUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(payload)
        });
    }
    
    // Send to N8N
    await fetch(N8N_CONFIG.statusWebhook, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload)
    });
    
    console.log(`Server update sent: Boat ${boatId}, Type: ${updateType}, Status: ${status}, CheckStatus: ${boatData.checkStatus}`);
    
} catch (error) {
    console.error('Error sending update to server:', error);
}
}

// Load shared state for follow-on displays
async function loadSharedState() {
    try {
        const response = await fetch(N8N_CONFIG.stateWebhook);
        if (!response.ok) return;
        
        const text = await response.text();
        if (!text) return;
        
        const serverState = JSON.parse(text);
        if (serverState && serverState.uiState) {
            applyUIState(serverState.uiState);
        }
    } catch (error) {
        console.error('Error loading shared state:', error);
    }
}

// Load view-only state from server
async function loadViewOnlyState() {
    try {
        const response = await fetch(N8N_CONFIG.stateWebhook);
        if (!response.ok) return;
        
        const text = await response.text();
        if (!text) return;
        
        const serverState = JSON.parse(text);
        
        if (serverState && serverState.uiState) {
            applyUIState(serverState.uiState);
        }
        
        updateMainDisplay();
        
    } catch (error) {
        console.error('Error loading view-only state:', error);
    }
}

// Apply UI state from server
function applyUIState(uiState) {
    if (!uiState) return;
    try {
        // Parse and apply layouts
        if (uiState.layouts) {
            let layouts = uiState.layouts;
            if (typeof layouts === 'string') {
                layouts = JSON.parse(layouts);
            }
            Object.entries(layouts).forEach(([area, layout]) => {
                state.areaLayouts.set(area, layout);
                localStorage.setItem(`areaLayout-${area}`, JSON.stringify(layout));
            });
        }
        
        // Parse and apply backgrounds
        if (uiState.backgrounds) {
            let backgrounds = uiState.backgrounds;
            if (typeof backgrounds === 'string') {
                backgrounds = JSON.parse(backgrounds);
            }
            Object.entries(backgrounds).forEach(([area, bgData]) => {
                state.areaBackgrounds.set(area, bgData);
                localStorage.setItem(`background-${area}`, bgData);
            });
        }
        
        // Parse and apply boat states
        if (uiState.boatStates) {
            let boatStates = uiState.boatStates;
            if (typeof boatStates === 'string') {
                boatStates = JSON.parse(boatStates);
            }
            Object.entries(boatStates).forEach(([id, boatState]) => {
                const boat = state.boats.get(parseInt(id));
                if (boat) {
                    boat.x = boatState.x;
                    boat.y = boatState.y;
                    boat.rotation = boatState.rotation;
                    boat.location = boatState.location;
                    boat.checkStatus = boatState.checkStatus;
                    boat.status = boatState.status;
                    boat.podId = boatState.podId;
                }
            });
        }
        
        // Parse and apply pod states
        if (uiState.podStates) {
            let podStates = uiState.podStates;
            if (typeof podStates === 'string') {
                podStates = JSON.parse(podStates);
            }
            if (Array.isArray(podStates)) {
                podStates.forEach(([id, pod]) => {
                    state.pods.set(id, pod);
                });
            }
        }
        
        // Apply current display
        if (uiState.currentDisplay) {
            state.currentDisplay = uiState.currentDisplay;
            document.getElementById('mainDisplaySelect').value = state.currentDisplay;
        }
        
    } catch (error) {
        console.error('Error applying UI state:', error);
    }
}

// Setup background upload
function setupBackgroundUpload() {
    const input = document.getElementById('bgImageInput');
    input.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const bgData = e.target.result;
                state.areaBackgrounds.set(state.currentDisplay, bgData);
                localStorage.setItem(`background-${state.currentDisplay}`, bgData);
                document.getElementById('mainDisplay').style.backgroundImage = `url(${bgData})`;
                autoSaveState();
            };
            reader.readAsDataURL(file);
        }
    });
}

// Clear background for current display
function clearBackground() {
    state.areaBackgrounds.delete(state.currentDisplay);
    localStorage.removeItem(`background-${state.currentDisplay}`);
    document.getElementById('mainDisplay').style.backgroundImage = '';
    autoSaveState();
}

// Get next available position for boat placement
function getNextPosition(area, boatType = 1) {
    const pos = state.nextPositions.get(area) || { x: 20, y: 100, rowCount: 0 };
    const mainDisplay = document.getElementById('mainDisplay');
    const maxWidth = mainDisplay ? mainDisplay.offsetWidth : 1200;
    const boatWidth = (boatType === 1 ? 30 : 26) + BOAT_SPACING.horizontal;

    if (pos.x + boatWidth > maxWidth - 20) {
        pos.x = 20;
        pos.y += BOAT_SPACING.vertical;
        pos.rowCount = 0;
    }

    const returnPos = { x: pos.x, y: pos.y };

    pos.x += boatWidth;
    pos.rowCount++;

    state.nextPositions.set(area, pos);

    return returnPos;
}

// Setup context menu
function setupContextMenu() {
    const menu = document.getElementById('contextMenu');
    menu.style.display = 'none';
    menu.style.position = 'fixed';
}

// Setup event listeners
function setupEventListeners() {
    // Close context menu on click
    document.addEventListener('click', function(e) {
        const menu = document.getElementById('contextMenu');
        if (!menu.contains(e.target)) {
            menu.style.display = 'none';
        }
    });
    
    // Stop polling when page is hidden
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            stopPolling();
        } else {
            startPolling();
        }
    });

    // Auto-save on page unload
    window.addEventListener('beforeunload', (e) => {
        autoSaveState();
    });

    // Auto-save periodically (every 60 seconds)
    setInterval(() => {
        autoSaveState();
        console.log('Auto-saved at', new Date().toLocaleTimeString());
    }, 60000);
}

// Polling functions
function startPolling() {
    updateFromServerState();
    state.pollTimer = setInterval(updateFromServerState, POLL_INTERVAL);
}

function stopPolling() {
    if (state.pollTimer) {
        clearInterval(state.pollTimer);
        state.pollTimer = null;
    }
}

// FIXED: Update from server state - Syncs AND adds operator actions to table
async function updateFromServerState() {
    if (state.isViewOnly) return;
try {
    const response = await fetch(N8N_CONFIG.stateWebhook);
    if (!response.ok) return;
    
    const text = await response.text();
    if (!text) return;
    
    const serverState = JSON.parse(text);
    if (!serverState || !serverState.boats) return;
    
    let hasChanges = false;
    
    serverState.boats.forEach(serverBoat => {
        const boatId = parseInt(serverBoat.id);
        let localBoat = state.boats.get(boatId);
        
        // If boat doesn't exist locally, create it
        if (!localBoat) {
            console.log(`Creating new boat ${boatId} from server`);
            createBoat({
                id: boatId,
                type: parseInt(serverBoat.type) || (boatId <= 70 ? 1 : 2),
                userGroup: serverBoat.userGroup || 'leg',
                checkStatus: serverBoat.checkStatus || serverBoat.status || 'none',
                location: serverBoat.location || 'pier',
                x: parseFloat(serverBoat.x) || null,
                y: parseFloat(serverBoat.y) || null,
                rotation: parseFloat(serverBoat.rotation) || 0,
                fromServer: true
            });
            hasChanges = true;
        } else {
            // Only update if server has newer timestamp
const serverTimestamp = serverBoat.lastUpdated || serverBoat.timestamp;
const localCheckTimestamp = localBoat.lastCheckUpdate;
const localMovementTimestamp = localBoat.lastMovementUpdate;

// Only update if server is actually newer
if (serverTimestamp) {
    const serverTime = new Date(serverTimestamp).getTime();
    const localCheckTime = localCheckTimestamp ? new Date(localCheckTimestamp).getTime() : 0;
    const localMovementTime = localMovementTimestamp ? new Date(localMovementTimestamp).getTime() : 0;
    const localLatestTime = Math.max(localCheckTime, localMovementTime);
    
    // Only update if server is newer than our latest local update
    if (serverTime > localLatestTime + 1000) { // Add 1 second buffer
        // Determine what type of update this is
        const updateType = serverBoat.updateType;
        
        if (updateType === 'movement') {
            // MOVEMENT UPDATE: Only update location
            const serverLocation = serverBoat.location;
            if (serverLocation && serverLocation !== localBoat.location) {
                console.log(`Server movement update: Boat ${boatId} location: ${localBoat.location} -> ${serverLocation}`);
                localBoat.location = serverLocation;
                hasChanges = true;
            }
        } else if (updateType === 'check') {
            // CHECK STATUS UPDATE: Only update checkStatus
            const serverCheckStatus = serverBoat.checkStatus || serverBoat.status;
            if (serverCheckStatus && serverCheckStatus !== localBoat.checkStatus) {
                console.log(`Server check update: Boat ${boatId} check status: ${localBoat.checkStatus} -> ${serverCheckStatus}`);
                localBoat.checkStatus = serverCheckStatus;
                localBoat.status = serverCheckStatus;
                updateBoatVisuals(boatId, serverCheckStatus);
                hasChanges = true;
            }
        } else {
            // FALLBACK for old-style updates without updateType
            const serverCheckStatus = serverBoat.checkStatus || 
                                     (serverBoat.status !== 'none' ? serverBoat.status : localBoat.checkStatus);
            const serverLocation = serverBoat.location || 'pier';
            
            // Update check status if different and not reverting to 'none'
            if (serverCheckStatus && serverCheckStatus !== 'none' && serverCheckStatus !== localBoat.checkStatus) {
                console.log(`Server update: Boat ${boatId} check status: ${localBoat.checkStatus} -> ${serverCheckStatus}`);
                localBoat.checkStatus = serverCheckStatus;
                localBoat.status = serverCheckStatus;
                updateBoatVisuals(boatId, serverCheckStatus);
                hasChanges = true;
            }
            
            // Update location if different
            if (serverLocation && serverLocation !== localBoat.location) {
                console.log(`Server update: Boat ${boatId} location: ${localBoat.location} -> ${serverLocation}`);
                localBoat.location = serverLocation;
                hasChanges = true;
            }
        }

                    // CRITICAL: Prefer checkStatus over status field
                    const serverCheckStatus = serverBoat.checkStatus || 
                                             (serverBoat.status !== 'none' ? serverBoat.status : localBoat.checkStatus);
                    const serverLocation = serverBoat.location || 'pier';
                    
                    // Update check status if different and not reverting to 'none'
                    if (serverCheckStatus && serverCheckStatus !== 'none' && serverCheckStatus !== localBoat.checkStatus) {
                        console.log(`Server update: Boat ${boatId} check status: ${localBoat.checkStatus} -> ${serverCheckStatus}`);
                        localBoat.checkStatus = serverCheckStatus;
                        localBoat.status = serverCheckStatus;
                        updateBoatVisuals(boatId, serverCheckStatus);
                        hasChanges = true;
                    }
                    
                    // Update location if different
                    if (serverLocation && serverLocation !== localBoat.location) {
                        console.log(`Server update: Boat ${boatId} location: ${localBoat.location} -> ${serverLocation}`);
                        localBoat.location = serverLocation;
                        hasChanges = true;
                    }
                    
                    // Add to table if this is a real operator action
const hasRealOperator = serverBoat.operator && 
                       !['System', 'Initial', 'Auto', 'Assignment System'].includes(serverBoat.operator);

if (hasRealOperator) {
    // CRITICAL: Use updateStatus to determine what was actually updated
    const statusToLog = serverBoat.updateStatus || serverBoat.status;
    const updateKey = `${boatId}-${statusToLog}-${serverBoat.operator}-${serverTimestamp}`;
    
    if (!state.processedUpdates.has(updateKey)) {
        console.log(`New operator action from server: Boat ${boatId}, Type: ${serverBoat.updateType}, Status: ${statusToLog}, Operator: ${serverBoat.operator}`);
        
        // CRITICAL: Pass the status that was actually updated, not the boat's current status
        // This ensures movements get logged as 'tow', 'transit', etc. not as color statuses
        addStatusToTable(boatId, localBoat, statusToLog, serverBoat.operator, serverTimestamp);
        state.processedUpdates.add(updateKey);
    }
}
                }
            } else {
                // No timestamp from server, be very careful about updates
                console.log(`No timestamp from server for boat ${boatId}, skipping update`);
            }
        }
    });
    
    if (hasChanges) {
        updateMainDisplay();
        updateSmallBoxes();
    }
    
} catch (error) {
    console.error('Error syncing with server:', error);
}
}

// Enable view-only mode
function enableViewOnlyMode() {
    document.querySelector('.controls').style.display = 'none';
    const indicator = document.createElement('div');
    indicator.className = 'view-only-indicator';
    indicator.textContent = 'VIEW ONLY MODE';
    indicator.style.cssText = `
        background: rgba(255, 165, 0, 0.2);
        border: 2px solid orange;
        padding: 10px;
        margin-top: 10px;
        border-radius: 5px;
        text-align: center;
        font-weight: bold;
    `;
    document.querySelector('.header').appendChild(indicator);

    document.addEventListener('contextmenu', e => e.preventDefault());
}

// Utility Functions
function updateBoatCount() {
    document.getElementById('boatCount').textContent = state.boats.size;
}

function updatePodCount() {
    document.getElementById('podCount').textContent = state.pods.size;
}

// Generate unique cell ID
function generateCellId(cell) {
    const row = cell.closest('tr');
    const boatId = row.dataset.boatId || row.dataset.rowId;
    const status = cell.dataset.status || cell.parentElement.dataset.status;
    return `cell-${boatId}-${status}-${Date.now()}`;
}

// Helper function to extract text from cell
function extractCellText(cell) {
    if (!cell) return '';
    const html = cell.innerHTML;
    const match = html.match(/([0-9]{2}:[0-9]{2})<br><small>([^<]+)<\/small>/);
    if (match) {
        return `${match[1]} - ${match[2]}`;
    }
    return cell.textContent.replace(/\n/g, ' ').trim();
}

// Setup drag and drop for small boxes
function setupSmallBoxDragDrop() {
    const statusBoxes = document.querySelectorAll('.status-box');
    statusBoxes.forEach(box => {
        const content = box.querySelector('.status-box-content');
        
        content.addEventListener('dragover', (e) => {
            e.preventDefault();
            box.classList.add('drag-over');
        });
        
        content.addEventListener('dragleave', () => {
            box.classList.remove('drag-over');
        });
        
        content.addEventListener('drop', (e) => {
            e.preventDefault();
            box.classList.remove('drag-over');
            
            const targetArea = box.dataset.area;
            handleSmallBoxDrop(e, targetArea);
        });
    });
}

// Handle drop in small box
function handleSmallBoxDrop(e, targetArea) {
    if (!state.draggedItem) return;
    
    if (state.draggedItem.classList.contains('boat-wrapper')) {
        const boatId = parseInt(state.draggedItem.id.replace('boat-wrapper-', ''));
        const boat = state.boats.get(boatId);
        
        if (boat && state.draggedFromArea !== targetArea) {
            // Map area to movement type
            const movementMap = {
                'tow': 'tow',
                'transit': 'transit',
                'operational-area': 'operational-area',
                'pier': 'return-pier'
            };
            
            const movementType = movementMap[targetArea];
            if (movementType) {
                // Get operator name
                const operator = prompt('Enter your name for this movement:', 
                                       localStorage.getItem('lastOperator') || 'Manual Drag');
                if (operator) {
                    localStorage.setItem('lastOperator', operator);
                    updateMovementStatus(boatId, movementType, operator);
                }
            }
        }
    } else if (state.draggedItem.classList.contains('pod')) {
        const podId = state.draggedItem.dataset.podId;
        const pod = state.pods.get(podId);
        
        if (pod && state.draggedFromArea !== targetArea) {
            const movementMap = {
                'tow': 'tow',
                'transit': 'transit',
                'operational-area': 'operational-area',
                'pier': 'return-pier'
            };
            
            const movementType = movementMap[targetArea];
            if (movementType) {
                // Get operator name
                const operator = prompt('Enter your name for this pod movement:', 
                                       localStorage.getItem('lastOperator') || 'Manual Drag');
                if (operator) {
                    localStorage.setItem('lastOperator', operator);
                    // Move all boats in pod
                    pod.boats.forEach(boatId => {
                        updateMovementStatus(boatId, movementType, operator);
                    });
                }
            }
        }
    }
}

// Main display management
function setupMainDisplay() {
    const mainDisplay = document.getElementById('mainDisplay');
    const displaySelect = document.getElementById('mainDisplaySelect');
    
    displaySelect.addEventListener('change', function() {
        saveAreaLayout(state.currentDisplay);
        state.currentDisplay = this.value;
        updateMainDisplay();
    });

    mainDisplay.addEventListener('dragover', handleDragOver);
    mainDisplay.addEventListener('drop', handleDrop);

    mainDisplay.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) {
            e.preventDefault();
            
            const boatWrapper = e.target.closest('.boat-wrapper');
            const podElement = e.target.closest('.pod');
            
            if (boatWrapper && podElement) {
                const boatId = parseInt(boatWrapper.id.replace('boat-wrapper-', ''));
                showBoatInPodContextMenu(e, boatId, podElement.dataset.podId);
            } else if (podElement) {
                showPodContextMenu(e, podElement.dataset.podId);
            } else if (boatWrapper) {
                const boatId = parseInt(boatWrapper.id.replace('boat-wrapper-', ''));
                showBoatContextMenu(e, boatId);
            } else {
                showAreaContextMenu(e, state.currentDisplay);
            }
        }
    });
}

// Save layout for specific area
function saveAreaLayout(area) {
    const layout = {
        boats: [],
        pods: []
    };
    
    state.boats.forEach((boat, id) => {
        if (boat.location === area && !boat.podId) {
            layout.boats.push({
                id: id,
                x: boat.x || 0,
                y: boat.y || 0,
                rotation: boat.rotation || 0
            });
        }
    });

    state.pods.forEach((pod, id) => {
        if (pod.location === area) {
            layout.pods.push({
                id: id,
                x: pod.x || 0,
                y: pod.y || 0,
                rotation: pod.rotation || 0
            });
        }
    });

    state.areaLayouts.set(area, layout);
    localStorage.setItem(`areaLayout-${area}`, JSON.stringify(layout));
}

// Update main display
function updateMainDisplay() {
    const mainDisplay = document.getElementById('mainDisplay');
    mainDisplay.innerHTML = '';
    mainDisplay.classList.add('draggable-area');

    const areaBackground = state.areaBackgrounds.get(state.currentDisplay) || 
                          localStorage.getItem(`background-${state.currentDisplay}`);

    if (areaBackground) {
        mainDisplay.style.backgroundImage = `url(${areaBackground})`;
        state.areaBackgrounds.set(state.currentDisplay, areaBackground);
    } else {
        mainDisplay.style.backgroundImage = '';
    }

    displayAreaContent(state.currentDisplay);
}

// Display content for an area with proper layout loading
function displayAreaContent(area) {
    const mainDisplay = document.getElementById('mainDisplay');
    const savedLayout = state.areaLayouts.get(area) || 
                       JSON.parse(localStorage.getItem(`areaLayout-${area}`) || 'null');

    const boatsInArea = [];
    const podsInArea = [];

    state.boats.forEach((boat, id) => {
        if (boat.location === area && !boat.podId) {
            boatsInArea.push(boat);
        }
    });

    state.pods.forEach((pod, id) => {
        if (pod.location === area) {
            podsInArea.push(pod);
        }
    });

    boatsInArea.sort((a, b) => {
        if (a.userGroup !== b.userGroup) {
            return a.userGroup === 'lat' ? -1 : 1;
        }
        if (a.type !== b.type) return a.type - b.type;
        return a.id - b.id;
    });

    // Display pods first
    podsInArea.forEach(pod => {
        const podElement = createPodElement(pod);
        podElement.style.position = 'absolute';
        
        if (savedLayout && savedLayout.pods) {
            const savedPod = savedLayout.pods.find(p => p.id === pod.id);
            if (savedPod) {
                pod.x = savedPod.x;
                pod.y = savedPod.y;
                pod.rotation = savedPod.rotation || 0;
            }
        }
        
        if (pod.x === undefined || pod.x === null) {
            const pos = getNextPosition(area);
            pod.x = pos.x;
            pod.y = pos.y;
        }
        
        podElement.style.left = pod.x + 'px';
        podElement.style.top = pod.y + 'px';
        podElement.style.transform = `rotate(${pod.rotation || 0}deg)`;
        
        mainDisplay.appendChild(podElement);
    });

    // Display individual boats
    boatsInArea.forEach(boat => {
        const boatElement = boat.element;
        if (!boatElement) {
            console.warn(`Boat ${boat.id} has no element`);
            return;
        }
        
        boatElement.classList.remove('in-small-box');
        boatElement.style.position = 'absolute';
        
        let positioned = false;
        
        if (savedLayout && savedLayout.boats) {
            const savedBoat = savedLayout.boats.find(b => b.id === boat.id);
        if (savedBoat && savedBoat.x !== undefined && savedBoat.y !== undefined) {
                boat.x = savedBoat.x;
                boat.y = savedBoat.y;
                boat.rotation = savedBoat.rotation || 0;
                boatElement.style.left = savedBoat.x + 'px';
                boatElement.style.top = savedBoat.y + 'px';
                boatElement.style.transform = `rotate(${savedBoat.rotation || 0}deg)`;
                positioned = true;
            }
        }
        
        if (!positioned && (boat.x === undefined || boat.x === null)) {
            const pos = getNextPosition(area, boat.type);
            boat.x = pos.x;
            boat.y = pos.y;
            boat.rotation = 0;
        }
        
        if (!positioned) {
            boatElement.style.left = (boat.x || 20) + 'px';
            boatElement.style.top = (boat.y || 100) + 'px';
            boatElement.style.transform = `rotate(${boat.rotation || 0}deg)`;
        }
        
        // ENSURE CORRECT COLOR IS DISPLAYED
        const checkStatus = boat.checkStatus || boat.status || 'none';
        updateBoatVisuals(boat.id, checkStatus);
        
        mainDisplay.appendChild(boatElement);
    });
}

// Move boat to area - Physical movement only
function moveBoatToArea(boatId, area) {
    const boatData = state.boats.get(boatId);
    if (!boatData) return;
    
    // Update location WITHOUT changing check status
    boatData.location = area;
    
    // Remove from current display if needed
    if (boatData.element && boatData.element.parentNode) {
        boatData.element.parentNode.removeChild(boatData.element);
    }
    
    // Clear position for new area
    boatData.x = null;
    boatData.y = null;
    
    // Refresh displays
    updateMainDisplay();
    updateSmallBoxes();
}

// Update small boxes - FIXED to show correct colors
function updateSmallBoxes() {
    const areas = ['pier', 'tow', 'transit', 'operational-area'];
    areas.forEach(area => {
        let smallBoxId;
        if (area === 'operational-area') {
            smallBoxId = 'operationalAreaSmallBox';
        } else {
            smallBoxId = area + 'SmallBox';
        }
        
        const smallBox = document.getElementById(smallBoxId);
        if (!smallBox) {
            console.warn(`Small box not found for area: ${area} (looked for ${smallBoxId})`);
            return;
        }
        
        smallBox.innerHTML = '';
        
        const podsInArea = [];
        const boatsInArea = [];
        
        state.pods.forEach(pod => {
            if (pod.location === area) {
                podsInArea.push(pod);
            }
        });
        
        state.boats.forEach((boat, id) => {
            if (boat.location === area && !boat.podId) {
                boatsInArea.push({ id, boat });
            }
        });
        
        boatsInArea.sort((a, b) => {
            if (a.boat.userGroup !== b.boat.userGroup) {
                return a.boat.userGroup === 'lat' ? -1 : 1;
            }
            if (a.boat.type !== b.boat.type) {
                return a.boat.type - b.boat.type;
            }
            return a.id - b.id;
        });
        
        podsInArea.forEach(pod => {
            const podElement = createPodElement(pod, true);
            smallBox.appendChild(podElement);
        });
        
        boatsInArea.forEach(({ id, boat }) => {
            const boatElement = boat.element.cloneNode(true);
            boatElement.classList.add('in-small-box');
            boatElement.style.position = 'relative';
            boatElement.style.left = '';
            boatElement.style.top = '';
            boatElement.style.transform = '';
            
            // CRITICAL: Use checkStatus for color, not location
            const checkStatus = boat.checkStatus || boat.status || 'none';
            const boatInner = boatElement.querySelector('.boat');
            if (boatInner) {
                boatInner.className = `boat boat-type-${boat.type} status-${checkStatus}`;
            }
            
            boatElement.draggable = true;
            boatElement.addEventListener('dragstart', handleDragStart);
            
            boatElement.addEventListener('contextmenu', function(e) {
                if (!state.isViewOnly) {
                    e.preventDefault();
                    showBoatContextMenu(e, id);
                }
            });
            
            smallBox.appendChild(boatElement);
        });
    });
}

// Create boat - Properly initialized (FIXED to not create duplicate initial entries)
function createBoat(config) {
    // Create boat data with proper structure
    const boatData = {
        id: config.id,
        type: config.type || (config.id <= 70 ? 1 : 2),
        userGroup: config.userGroup || 'leg',
        
        // CRITICAL SEPARATION:
        checkStatus: config.checkStatus || 'none',  // Color status ONLY
        location: config.location || 'pier',        // Physical location ONLY
        
        // Tracking for updates
        lastCheckUpdate: config.lastCheckUpdate || null,
        lastCheckOperator: config.lastCheckOperator || null,
        lastMovementUpdate: config.lastMovementUpdate || null,
        lastMovementOperator: config.lastMovementOperator || null,
        
        // Visual properties
        x: config.x || null,
        y: config.y || null,
        rotation: config.rotation || 0,
        
        // References
        element: null,
        boat: null,
        podId: null,
        
        // Special states
        troublePreviousStatus: null,
        
        // Legacy field for compatibility
        status: config.checkStatus || 'none'
    };
    
    // Create visual element
    const wrapper = createBoatElement(boatData);
    boatData.element = wrapper;
    boatData.boat = wrapper.querySelector('.boat');
    
    // Store in state
    state.boats.set(config.id, boatData);
    
    // Update visual with check status
    updateBoatVisuals(config.id, boatData.checkStatus);
    
    // FIXED: Only add initial status if not loading AND not from server
    if (!state.isLoadingLayouts && !config.fromServer) {
        // Check if boat already has table entries
        const tbody = document.getElementById('statusTableBody');
        const existingRow = tbody?.querySelector(`tr[data-boat-id="${config.id}"]`);
        
        if (!existingRow) {
            addStatusToTable(config.id, boatData, 'none', 'Initial', new Date().toISOString());
        }
    }
    
    updateBoatCount();
    
    if (!state.isLoadingLayouts) {
        updateSmallBoxes();
    }
    
    return boatData;
}

// Create boat element - Visual component only
function createBoatElement(boatData) {
    const wrapper = document.createElement('div');
    wrapper.className = `boat-wrapper user-${boatData.userGroup}`;
    wrapper.style.position = 'absolute';
    wrapper.style.left = (boatData.x || 0) + 'px';
    wrapper.style.top = (boatData.y || 0) + 'px';
    wrapper.style.transform = `rotate(${boatData.rotation || 0}deg)`;
    wrapper.style.width = boatData.type === 1 ? '34px' : '30px';
    wrapper.style.height = boatData.type === 1 ? '64px' : '48px';
    wrapper.id = `boat-wrapper-${boatData.id}`;
    wrapper.draggable = !state.isViewOnly;
    
    const outline = document.createElement('div');
    outline.className = 'boat-outline';

    const boat = document.createElement('div');
    boat.className = `boat boat-type-${boatData.type} status-${boatData.checkStatus}`;
    boat.id = `boat-${boatData.id}`;
    boat.style.position = 'relative';
    boat.style.width = boatData.type === 1 ? '30px' : '26px';
    boat.style.height = boatData.type === 1 ? '60px' : '44px';
    boat.style.top = '2px';
    boat.style.left = '2px';
    boat.style.zIndex = '1';

    const prefix = boatData.type === 1 ? 'C' : 'G';
    const paddedNumber = boatData.id.toString().padStart(2, '0');

    const boatNumber = document.createElement('span');
    boatNumber.className = 'boat-number';
    boatNumber.textContent = `${prefix}${paddedNumber}`;
    boat.appendChild(boatNumber);

    const userIndicator = document.createElement('div');
    userIndicator.className = 'user-indicator';
    userIndicator.textContent = boatData.userGroup === 'leg' ? 'Leg' : 'Lat';
    userIndicator.style.zIndex = '3';

    const rotationHandle = document.createElement('div');
    rotationHandle.className = 'rotation-handle';
    rotationHandle.style.zIndex = '4';
    rotationHandle.title = 'Click and drag to rotate';

    if (state.isViewOnly) {
        rotationHandle.style.display = 'none';
    }

    wrapper.appendChild(outline);
    wrapper.appendChild(boat);
    wrapper.appendChild(userIndicator);
    wrapper.appendChild(rotationHandle);

    // Add event listeners if not view-only
    if (!state.isViewOnly) {
        wrapper.addEventListener('dragstart', handleDragStart);
        wrapper.addEventListener('dragend', handleDragEnd);
        
        rotationHandle.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            handleRotationStart(e, wrapper);
        });
        
        wrapper.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            showBoatContextMenu(e, boatData.id);
        });
    }

    return wrapper;
}

// Create pod element with proper rotation support
function createPodElement(pod, isSmallBox = false) {
    const podDiv = document.createElement('div');
    podDiv.className = isSmallBox ? 'pod in-small-box' : 'pod';
    podDiv.dataset.podId = pod.id;
    
    if (!isSmallBox) {
        podDiv.style.position = 'absolute';
        podDiv.style.transform = `rotate(${pod.rotation || 0}deg)`;
        
        if (!state.isViewOnly) {
            podDiv.draggable = true;
            podDiv.addEventListener('dragstart', handlePodDragStart);
            podDiv.addEventListener('dragend', handleDragEnd);
            
            const rotationHandle = document.createElement('div');
            rotationHandle.className = 'rotation-handle';
            rotationHandle.style.position = 'absolute';
            rotationHandle.style.top = '-15px';
            rotationHandle.style.left = '50%';
            rotationHandle.style.transform = 'translateX(-50%)';
            rotationHandle.style.opacity = '1';
            rotationHandle.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
            rotationHandle.style.width = '12px';
            rotationHandle.style.height = '12px';
            rotationHandle.style.borderRadius = '50%';
            rotationHandle.style.border = '2px solid #333';
            rotationHandle.style.cursor = 'grab';
            rotationHandle.style.zIndex = '100';
            rotationHandle.title = 'Click and drag to rotate pod';
            podDiv.appendChild(rotationHandle);
            
            rotationHandle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                handlePodRotationStart(e, podDiv, pod.id);
            });
            
            podDiv.addEventListener('contextmenu', function(e) {
                if (!e.target.closest('.boat-wrapper')) {
                    e.preventDefault();
                    showPodContextMenu(e, pod.id);
                }
            });
        }
    } else {
        podDiv.draggable = true;
        podDiv.addEventListener('dragstart', handlePodDragStart);
    }

    const sortedBoats = [...pod.boats].sort((a, b) => {
        const boatA = state.boats.get(a);
        const boatB = state.boats.get(b);
        if (!boatA || !boatB) return 0;
        
        if (boatA.userGroup !== boatB.userGroup) {
            return boatA.userGroup === 'lat' ? -1 : 1;
        }
        if (boatA.type !== boatB.type) return boatA.type - boatB.type;
        return a - b;
    });

    sortedBoats.forEach(boatId => {
        const boat = state.boats.get(boatId);
        if (boat) {
            const boatElement = boat.element.cloneNode(true);
            boatElement.style.position = 'relative';
            boatElement.style.left = '';
            boatElement.style.top = '';
            boatElement.classList.add('in-small-box');
            
            // CRITICAL: Maintain check status color in pods
            const checkStatus = boat.checkStatus || boat.status || 'none';
            const boatInner = boatElement.querySelector('.boat');
            if (boatInner) {
                boatInner.className = `boat boat-type-${boat.type} status-${checkStatus}`;
            }
            
            boatElement.style.transform = '';
            
            const handle = boatElement.querySelector('.rotation-handle');
            if (handle) handle.style.display = 'none';
            
            // Add context menu for boat in pod
            boatElement.addEventListener('contextmenu', function(e) {
                if (!state.isViewOnly) {
                    e.preventDefault();
                    e.stopPropagation();
                    showBoatInPodContextMenu(e, boatId, pod.id);
                }
            });
            
            podDiv.appendChild(boatElement);
        }
    });

    return podDiv;
}

// Add status to table - Smart table entry addition with proper new row logic
function addStatusToTable(boatId, boatData, status, operator, timestamp) {
    // Skip if this is part of a batch update (except first one)
    if (state.isBatchUpdate && state.batchUpdateKey) {
        const currentKey = `${boatId}-${status}-${operator}`;
        // Only log the status change, not table entry
        console.log(`Batch update (skipping table): ${currentKey}`);
        return;  // Skip table entry for batch updates
    }

    const tbody = document.getElementById('statusTableBody');
    const prefix = boatData.type === 1 ? 'C' : 'G';
    const paddedNumber = boatId.toString().padStart(2, '0');
    const boatName = `${prefix}${paddedNumber}`;

// Normalize the status
const movementStatuses = ['tow', 'transit', 'operational-area', 'return-pier'];
const normalizedStatus = status === 'pierside-complete' ? 'pierside' :
                       status === 'platform-complete' ? 'platform' :
                       status === 'pretow-complete' ? 'pretow' :
                       status === 'operational-complete' ? 'operational' :
                       status;

// Determine update type
const isMovement = movementStatuses.includes(normalizedStatus);

// Create unique key for this update
const updateKey = `${boatId}-${normalizedStatus}-${operator}-${timestamp}`;

// Check if this exact update was already added (with a time window)
const recentKeys = Array.from(state.tableEntryHistory.keys()).filter(key => {
    if (key.startsWith(`${boatId}-${normalizedStatus}-${operator}-`)) {
        const keyTime = key.split('-').pop();
        const keyTimestamp = new Date(keyTime).getTime();
        const currentTimestamp = new Date(timestamp).getTime();
        // If within 3 seconds, consider it a duplicate
        return Math.abs(currentTimestamp - keyTimestamp) < 3000;
    }
    return false;
});

if (recentKeys.length > 0) {
    console.log(`Duplicate table entry prevented (recent similar): ${updateKey}`);
    return;
}
    
    // Get or create row
    let targetRow = null;
    const existingRows = tbody.querySelectorAll(`tr[data-boat-id="${boatId}"]`);
    
    if (existingRows.length > 0) {
        const lastRow = existingRows[existingRows.length - 1];
        
        // Determine if we need a new row
        const needNewRow = shouldCreateNewRow(lastRow, normalizedStatus, isMovement);
        
        if (needNewRow) {
            // Create new row
            const rowCount = (state.boatRowCounts.get(boatId) || 1) + 1;
            state.boatRowCounts.set(boatId, rowCount);
            targetRow = createNewRow(boatId, `${boatName} (${rowCount})`, boatData);
            lastRow.parentNode.insertBefore(targetRow, lastRow.nextSibling);
        } else {
            targetRow = lastRow;
        }
    } else {
        // Create first row
        targetRow = createNewRow(boatId, boatName, boatData);
        insertRowInOrder(tbody, targetRow, boatId, boatData);
        state.boatRowCounts.set(boatId, 1);
    }
    
    // Update the cell
    updateTableCell(targetRow, normalizedStatus, operator, timestamp, isMovement, boatData);
    
    // Mark as added
    state.tableEntryHistory.set(updateKey, true);
    
    // Save state
    saveStatusTableState();
    
    console.log(`Status recorded: ${boatName} - ${normalizedStatus} at ${timestamp} by ${operator}`);
}

// Intelligent row creation decision - Always create new row for repeated checks
function shouldCreateNewRow(lastRow, status, isMovement) {
    // Get the row's creation timestamp if it exists
    const rowCreationTime = lastRow.dataset.creationTime;
    const currentTime = Date.now();
// If row was just created (within 2 seconds), don't create another
if (rowCreationTime && (currentTime - parseInt(rowCreationTime)) < 2000) {
    console.log('Preventing duplicate row - too soon after last creation');
    return false;
}

if (isMovement) {
    // For movements, check if this movement column is already filled
    const movementColumn = getMovementColumn(status);
    const cell = lastRow.querySelector(`[data-status="${movementColumn}"]`);
    
    // Only create new row if cell exists AND has content
    if (cell && cell.innerHTML && cell.innerHTML.trim() !== '') {
        // Check if it's the same operator and within 5 seconds (duplicate prevention)
        const cellOperator = cell.dataset.operator;
        const cellTimestamp = cell.dataset.timestamp;
        if (cellOperator && cellTimestamp) {
            const cellTime = new Date(cellTimestamp).getTime();
            if ((currentTime - cellTime) < 5000) {
                console.log('Preventing duplicate movement entry');
                return false;
            }
        }
        return true;
    }
    return false;
} else {
    // For check status, check if this exact check phase is already filled
    const statusMap = {
        'none': 'none',
        'platform-start': 'platform-start',
        'platform': 'platform-complete',
        'pierside-start': 'pierside-start', 
        'pierside-hold': 'pierside-hold',
        'pierside': 'pierside-complete',
        'pretow-start': 'pretow-start',
        'pretow': 'pretow-complete',
        'operational-start': 'operational-start',
        'operational': 'operational-complete',
        'trouble': 'trouble'
    };
    
    const targetStatus = statusMap[status] || status;
    const cell = lastRow.querySelector(`[data-status="${targetStatus}"]`);
    
    // Only create new row if cell has content
    if (cell && cell.innerHTML && cell.innerHTML.trim() !== '') {
        // Check for recent duplicate
        const cellOperator = cell.dataset.operator;
        const cellTimestamp = cell.dataset.timestamp;
        if (cellOperator && cellTimestamp) {
            const cellTime = new Date(cellTimestamp).getTime();
            if ((currentTime - cellTime) < 5000) {
                console.log('Preventing duplicate check entry');
                return false;
            }
        }
        return true;
    }
    return false;
}
}

// Helper function to get movement column
function getMovementColumn(movementType) {
    const map = {
        'tow': 'tow',
        'transit': 'transit',
        'operational-area': 'oparea',
        'return-pier': 'return'
    };
    return map[movementType] || movementType;
}

// Update table cell
function updateTableCell(row, status, operator, timestamp, isMovement, boatData) {
    // Map status to column
    const columnMap = {
        'none': 'none',
        'platform-start': 'platform-start',
        'platform': 'platform-complete',
        'pierside-start': 'pierside-start',
        'pierside-hold': 'pierside-hold',
        'pierside': 'pierside-complete',
        'pretow-start': 'pretow-start',
        'pretow': 'pretow-complete',
        'operational-start': 'operational-start',
        'operational': 'operational-complete',
        'trouble': 'trouble',
        'tow': 'tow',
        'transit': 'transit',
        'operational-area': 'oparea',
        'return-pier': 'return'
    };
    
    const columnStatus = columnMap[status] || status;
    
    // Find the cell
    let cell = row.querySelector(`[data-status="${columnStatus}"]`);
    if (!cell) {
        console.warn(`Cell not found for status: ${columnStatus}`);
        return;
    }
    
    // Format time
    const time = new Date(timestamp);
    const timeStr = time.toLocaleTimeString('en-US', { 
        hour: '2-digit', 
        minute: '2-digit',
        hour12: false 
    });
    const dateStr = time.toLocaleDateString('en-US', { 
        month: '2-digit',
        day: '2-digit',
        year: 'numeric'
    });
    
    // Store original data in dataset
    cell.dataset.time = timeStr;
    cell.dataset.date = dateStr;
    cell.dataset.operator = operator;
    cell.dataset.timestamp = timestamp;
    
    // Set content
    cell.innerHTML = `${timeStr}<br><small>${operator}</small>`;
    cell.title = `${dateStr} ${timeStr} - ${operator}`;
    
    // Apply correct styling
    cell.className = cell.className.split(' ').filter(c => !c.startsWith('status-')).join(' ');
    
    if (isMovement) {
        // CRITICAL: For movement cells, use the boat's CURRENT check status for color
        const currentCheckStatus = boatData.checkStatus || 'none';
        cell.className += ` status-${currentCheckStatus}`;
        console.log(`Movement cell colored with check status: ${currentCheckStatus}`);
    } else {
        // For check status cells, use the status itself
        if (status.includes('-start') || status.includes('-hold')) {
            cell.className += ` status-${status}`;
        } else {
            cell.className += ` status-${status}`;
        }
    }
    
    // Add context menu if not present
    if (!cell.hasAttribute('data-has-context-menu')) {
        cell.setAttribute('data-has-context-menu', 'true');
        cell.addEventListener('contextmenu', function(e) {
            if (!state.isViewOnly) {
                showCellContextMenu(e, cell);
            }
        });
    }
}

// Create new row with side-by-side split cells
function createNewRow(boatId, boatName, boatData) {
    const newRow = document.createElement('tr');
    newRow.setAttribute('data-boat-id', boatId);
    newRow.dataset.creationTime = Date.now();
    
    // Boat
    const boatCell = document.createElement('td');
    boatCell.textContent = boatName;
    newRow.appendChild(boatCell);
    
    // Group
    const groupCell = document.createElement('td');
    groupCell.textContent = boatData.userGroup === 'leg' ? 'Leg' : 'Lat';
    groupCell.style.color = boatData.userGroup === 'leg' ? '#b19cd9' : '#00bfff';
    newRow.appendChild(groupCell);
    
    // No Check - single cell
    const noneCell = document.createElement('td');
    noneCell.setAttribute('data-status', 'none');
    noneCell.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) {
            showCellContextMenu(e, noneCell);
        }
    });
    newRow.appendChild(noneCell);
    
    // Platform (side-by-side split) - Start | Complete
    const platformCell = document.createElement('td');
    platformCell.className = 'split-cell';
    platformCell.setAttribute('colspan', '2');
    platformCell.innerHTML = `
        <div class="split-cell-container">
            <div class="split-cell-left" data-status="platform-start"></div>
            <div class="split-cell-right" data-status="platform-complete"></div>
        </div>
    `;
    newRow.appendChild(platformCell);
    
    const platformLeft = platformCell.querySelector('.split-cell-left');
    const platformRight = platformCell.querySelector('.split-cell-right');
    platformLeft.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, platformLeft);
    });
    platformRight.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, platformRight);
    });
    
    // Pierside (triple split) - Start | Hold | Complete
    const piersideCell = document.createElement('td');
    piersideCell.className = 'split-cell-triple';
    piersideCell.setAttribute('colspan', '3');
    piersideCell.innerHTML = `
        <div class="split-cell-triple-container">
            <div class="split-cell-triple-left" data-status="pierside-start"></div>
            <div class="split-cell-triple-middle" data-status="pierside-hold"></div>
            <div class="split-cell-triple-right" data-status="pierside-complete"></div>
        </div>
    `;
    newRow.appendChild(piersideCell);
    
    const piersideLeft = piersideCell.querySelector('.split-cell-triple-left');
    const piersideMiddle = piersideCell.querySelector('.split-cell-triple-middle');
    const piersideRight = piersideCell.querySelector('.split-cell-triple-right');
    piersideLeft.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, piersideLeft);
    });
    piersideMiddle.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, piersideMiddle);
    });
    piersideRight.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, piersideRight);
    });
    
    // Pre-Tow (side-by-side split) - Start | Complete
    const pretowCell = document.createElement('td');
    pretowCell.className = 'split-cell';
    pretowCell.setAttribute('colspan', '2');
    pretowCell.innerHTML = `
        <div class="split-cell-container">
            <div class="split-cell-left" data-status="pretow-start"></div>
            <div class="split-cell-right" data-status="pretow-complete"></div>
        </div>
    `;
    newRow.appendChild(pretowCell);
    
    const pretowLeft = pretowCell.querySelector('.split-cell-left');
    const pretowRight = pretowCell.querySelector('.split-cell-right');
    pretowLeft.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, pretowLeft);
    });
    pretowRight.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, pretowRight);
    });
    
    // Post-Tow (side-by-side split) - Start | Complete
    const operationalCell = document.createElement('td');
    operationalCell.className = 'split-cell';
    operationalCell.setAttribute('colspan', '2');
    operationalCell.innerHTML = `
        <div class="split-cell-container">
            <div class="split-cell-left" data-status="operational-start"></div>
            <div class="split-cell-right" data-status="operational-complete"></div>
        </div>
    `;
    newRow.appendChild(operationalCell);
    
    const operationalLeft = operationalCell.querySelector('.split-cell-left');
    const operationalRight = operationalCell.querySelector('.split-cell-right');
    operationalLeft.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, operationalLeft);
    });
    operationalRight.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, operationalRight);
    });
    
    // Trouble - single cell
    const troubleCell = document.createElement('td');
    troubleCell.setAttribute('data-status', 'trouble');
    troubleCell.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, troubleCell);
    });
    newRow.appendChild(troubleCell);
    
    // Movement statuses - single cells
    const towCell = document.createElement('td');
    towCell.setAttribute('data-status', 'tow');
    towCell.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, towCell);
    });
    newRow.appendChild(towCell);
    
    const transitCell = document.createElement('td');
    transitCell.setAttribute('data-status', 'transit');
    transitCell.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, transitCell);
    });
    newRow.appendChild(transitCell);
    
    const opareaCell = document.createElement('td');
    opareaCell.setAttribute('data-status', 'oparea');
    opareaCell.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, opareaCell);
    });
    newRow.appendChild(opareaCell);
    
    const returnCell = document.createElement('td');
    returnCell.setAttribute('data-status', 'return');
    returnCell.addEventListener('contextmenu', function(e) {
        if (!state.isViewOnly) showCellContextMenu(e, returnCell);
    });
    newRow.appendChild(returnCell);
    
    return newRow;
}

// Helper function to insert row in sorted order
function insertRowInOrder(tbody, newRow, boatId, boatData) {
    const allRows = Array.from(tbody.querySelectorAll('tr'));
    let insertBefore = null;
    
    for (const row of allRows) {
        const rowBoatId = parseInt(row.dataset.boatId);
        const rowBoat = state.boats.get(rowBoatId);
        if (rowBoat) {
            if (boatData.userGroup === 'lat' && rowBoat.userGroup === 'leg') {
                insertBefore = row;
                break;
            } else if (boatData.userGroup === rowBoat.userGroup) {
                if (boatData.type < rowBoat.type || 
                    (boatData.type === rowBoat.type && boatId < rowBoatId)) {
                    insertBefore = row;
                    break;
                }
            }
        }
    }
    
    if (insertBefore) {
        tbody.insertBefore(newRow, insertBefore);
    } else {
        tbody.appendChild(newRow);
    }
}

// Save status table state
function saveStatusTableState() {
    const tbody = document.getElementById('statusTableBody');
    const rows = tbody.querySelectorAll('tr');
    const tableData = [];
    
    rows.forEach(row => {
        const boatId = row.dataset.boatId;
        const cells = {};
        
        // Store all cells with content
        row.querySelectorAll('[data-status]').forEach(cell => {
            if (cell.innerHTML.trim()) {
                cells[cell.dataset.status] = {
                    t: cell.dataset.time,
                    d: cell.dataset.date,
                    o: cell.dataset.operator,
                    timestamp: cell.dataset.timestamp,
                    html: cell.innerHTML
                };
            }
        });
        
        if (Object.keys(cells).length > 0) {
            tableData.push({ 
                boatId: boatId, 
                cells: cells 
            });
        }
    });
    
    localStorage.setItem('statusTableData', JSON.stringify(tableData));
}

// Load status table data - Preserve timestamps
function loadStatusTableData(tableData) {
    const tbody = document.getElementById('statusTableBody');
    tbody.innerHTML = '';
    
    if (!tableData || !Array.isArray(tableData)) return;
    
    // Clear history to allow loading
    state.tableEntryHistory.clear();
    
    // Sort and recreate rows
    tableData.sort((a, b) => {
        const boatIdA = parseInt(a.boatId || a.id);
        const boatIdB = parseInt(b.boatId || b.id);
        const boatA = state.boats.get(boatIdA);
        const boatB = state.boats.get(boatIdB);
        
        if (boatA && boatB) {
            if (boatA.userGroup !== boatB.userGroup) {
                return boatA.userGroup === 'lat' ? -1 : 1;
            }
            if (boatA.type !== boatB.type) return boatA.type - boatB.type;
            return boatIdA - boatIdB;
        }
        return 0;
    });
    
    tableData.forEach(rowData => {
        const boatId = parseInt(rowData.boatId || rowData.id);
        const boat = state.boats.get(boatId);
        if (!boat) return;
        
        const prefix = boat.type === 1 ? 'C' : 'G';
        const paddedNumber = boatId.toString().padStart(2, '0');
        const boatName = `${prefix}${paddedNumber}`;
        
        // Check for duplicate naming
        const existingRows = tbody.querySelectorAll(`tr[data-boat-id="${boatId}"]`);
        const displayName = existingRows.length > 0 ? 
            `${boatName} (${existingRows.length + 1})` : boatName;
        
        const newRow = createNewRow(boatId, displayName, boat);
        tbody.appendChild(newRow);
        
        // Restore cells with ORIGINAL timestamps
        const cells = rowData.cells || rowData.c;
        Object.entries(cells).forEach(([status, cellData]) => {
            let cell = newRow.querySelector(`[data-status="${status}"]`);
            if (!cell) {
                cell = newRow.querySelector(`td[data-status="${status}"]`);
            }
            
            if (cell && cellData) {
                // Restore exact content
                if (cellData.html) {
                    cell.innerHTML = cellData.html;
                } else {
                    const time = cellData.t || cellData.time || '';
                    const operator = cellData.o || cellData.operator || '';
                    if (time && operator) {
                        cell.innerHTML = `${time}<br><small>${operator}</small>`;
                    }
                }
                
                // Restore dataset attributes
                if (cellData.t || cellData.time) {
                    cell.dataset.time = cellData.t || cellData.time;
                }
                if (cellData.d || cellData.date) {
                    cell.dataset.date = cellData.d || cellData.date;
                }
                if (cellData.o || cellData.operator) {
                    cell.dataset.operator = cellData.o || cellData.operator;
                }
                if (cellData.timestamp) {
                    cell.dataset.timestamp = cellData.timestamp;
                }
                
                // Reconstruct title
                if (cell.dataset.date && cell.dataset.time && cell.dataset.operator) {
                    cell.title = `${cell.dataset.date} ${cell.dataset.time} - ${cell.dataset.operator}`;
                }
                
                // Apply status styling
                cell.className = cell.className.split(' ').filter(c => !c.startsWith('status-')).join(' ');
                
                // Determine correct class
                if (status.includes('-start')) {
                    cell.className += ` status-${status}`;
                } else if (status.includes('-hold')) {
                    cell.className += ` status-${status}`;
                } else {
                    const baseStatus = status.replace('-complete', '');
                    cell.className += ` status-${baseStatus}`;
                }
                
                // Mark as loaded
                cell.setAttribute('data-loaded-from-save', 'true');
                
                // Add to history to prevent re-processing
                if (cellData.timestamp || (cellData.date && cellData.time)) {
                    const timestamp = cellData.timestamp || 
                                    `${cellData.date || cellData.d} ${cellData.time || cellData.t}`;
                    const operator = cellData.operator || cellData.o || 'Unknown';
                    const updateKey = `${boatId}-unknown-${status}-${operator}-${timestamp}`;
                    state.tableEntryHistory.set(updateKey, true);
                }
                
                // Add context menu
                if (!cell.hasAttribute('data-has-context-menu')) {
                    cell.setAttribute('data-has-context-menu', 'true');
                    cell.addEventListener('contextmenu', function(e) {
                        if (!state.isViewOnly) {
                            showCellContextMenu(e, cell);
                        }
                    });
                }
            }
        });
    });
    
    console.log('Status table loaded with preserved timestamps');
}

// Send to Google Sheets
function sendToGoogleSheets(boatId, boatData, status, operator) {
    const webhookUrl = localStorage.getItem('googleSheetsWebhook');
    if (!webhookUrl) return;
    
    const prefix = boatData.type === 1 ? 'C' : 'G';
    const boatName = `${prefix}${boatId.toString().padStart(2, '0')}`;
    const timestamp = new Date().toISOString();
    
    const payload = {
        boat: boatName,
        boatId: boatId,
        type: boatData.type,
        userGroup: boatData.userGroup,
        status: status,
        operator: operator,
        timestamp: timestamp,
        checkStatus: boatData.checkStatus,
        location: boatData.location
    };
    
    fetch(webhookUrl, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload)
    }).then(response => {
        console.log('Google Sheets update sent');
    }).catch(err => {
        console.error('Google Sheets update failed:', err);
    });
}

// Save webhook URL
window.saveWebhookUrl = function() {
    const url = document.getElementById('webhookUrl').value;
    if (url) {
        localStorage.setItem('googleSheetsWebhook', url);
        alert('Google Sheets webhook URL saved!');
    }
}

// Clear status table
window.clearStatusTable = function() {
    if (confirm('Are you sure you want to clear the status tracking table?')) {
        document.getElementById('statusTableBody').innerHTML = '';
        state.checkStatusHistory.clear();
        state.movementHistory.clear();
        state.tableEntryHistory.clear();
        state.statusLogHistory.clear();
        state.rowTracking.clear();
        localStorage.removeItem('statusTableData');
    }
}

// Export to CSV
window.exportToCSV = function() {
    const table = document.getElementById('statusTable');
    let csv = [];
    
    // Headers
    const header1 = [];
    const header2 = [];
    const headerRows = table.querySelectorAll('thead tr');
    
    // First header row
    headerRows[0].querySelectorAll('th').forEach(th => {
        const colspan = parseInt(th.getAttribute('colspan')) || 1;
        const text = th.textContent.trim();
        header1.push(text);
        for (let i = 1; i < colspan; i++) {
            header1.push('');
        }
    });
    
    // Second header row
    if (headerRows[1]) {
        header2.push('', '', ''); // Empty for rowspan headers
        headerRows[1].querySelectorAll('th').forEach(th => {
            header2.push(th.textContent.trim());
        });
        header2.push('', '', '', '', ''); // Empty for remaining rowspan headers
    }
    
    csv.push(header1.join(','));
    if (header2.length > 0) {
        csv.push(header2.join(','));
    }
    
    // Data rows
    const tbody = table.querySelector('tbody');
    tbody.querySelectorAll('tr').forEach(row => {
        const rowData = [];
        row.querySelectorAll('td').forEach(cell => {
            if (cell.classList.contains('split-cell')) {
                const left = cell.querySelector('.split-cell-left');
                const right = cell.querySelector('.split-cell-right');
                rowData.push(extractCellText(left));
                rowData.push(extractCellText(right));
            } else if (cell.classList.contains('split-cell-triple')) {
                const left = cell.querySelector('.split-cell-triple-left');
                const middle = cell.querySelector('.split-cell-triple-middle');
                const right = cell.querySelector('.split-cell-triple-right');
                rowData.push(extractCellText(left));
                rowData.push(extractCellText(middle));
                rowData.push(extractCellText(right));
            } else {
                const text = extractCellText(cell);
                rowData.push(text.includes(',') ? `"${text}"` : text);
            }
        });
        csv.push(rowData.join(','));
    });
    
    // Download
    const blob = new Blob([csv.join('\n')], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `boat_status_tracking_${new Date().toISOString().split('T')[0]}.csv`;
    a.click();
    URL.revokeObjectURL(url);
}

// Auto-save state
function autoSaveState() {
    // Save current area layout
    saveAreaLayout(state.currentDisplay);
    
    const stateData = {
        boats: Array.from(state.boats.entries()).map(([id, boat]) => ({
            id: id,
            type: boat.type,
            userGroup: boat.userGroup,
            checkStatus: boat.checkStatus,
            location: boat.location,
            x: boat.x,
            y: boat.y,
            rotation: boat.rotation,
            podId: boat.podId,
            troublePreviousStatus: boat.troublePreviousStatus,
            lastCheckUpdate: boat.lastCheckUpdate,
            lastCheckOperator: boat.lastCheckOperator,
            lastMovementUpdate: boat.lastMovementUpdate,
            lastMovementOperator: boat.lastMovementOperator
        })),
        pods: Array.from(state.pods.entries()).map(([id, pod]) => ({
            id: id,
            boats: pod.boats,
            location: pod.location,
            x: pod.x,
            y: pod.y,
            rotation: pod.rotation
        })),
        layouts: Object.fromEntries(state.areaLayouts),
        currentDisplay: state.currentDisplay,
        lastSaved: new Date().toISOString()
    };
    
    localStorage.setItem('boatDisplayAutoSave', JSON.stringify(stateData));
    
    // Save backgrounds separately due to size
    state.areaBackgrounds.forEach((bgData, area) => {
        localStorage.setItem(`background-${area}`, bgData);
    });
}

// Save all layouts
window.saveAllLayouts = function() {
    // Save current area first
    saveAreaLayout(state.currentDisplay);
    
    const data = {
        boats: Array.from(state.boats.entries()).map(([id, boat]) => ({
            id: id,
            type: boat.type,
            userGroup: boat.userGroup,
            checkStatus: boat.checkStatus,
            location: boat.location,
            x: boat.x,
            y: boat.y,
            rotation: boat.rotation,
            podId: boat.podId,
            troublePreviousStatus: boat.troublePreviousStatus
        })),
        pods: Array.from(state.pods.entries()).map(([id, pod]) => ({
            id: id,
            boats: pod.boats,
            location: pod.location,
            x: pod.x,
            y: pod.y,
            rotation: pod.rotation
        })),
        layouts: Object.fromEntries(state.areaLayouts),
        currentDisplay: state.currentDisplay,
        statusTableData: getStatusTableData()
    };
    
    // Save locally
    localStorage.setItem('boatDisplayV16Complete', JSON.stringify(data));
    
    // Save backgrounds separately
    state.areaBackgrounds.forEach((bgData, area) => {
        localStorage.setItem(`background-${area}`, bgData);
    });
    
    alert('All layouts saved!');
}

// Get status table data (for saving)
function getStatusTableData() {
    const tbody = document.getElementById('statusTableBody');
    const rows = tbody.querySelectorAll('tr');
    const tableData = [];
    
    rows.forEach(row => {
        const boatId = row.dataset.boatId;
        const cells = {};
        
        row.querySelectorAll('[data-status]').forEach(cell => {
            if (cell.innerHTML.trim()) {
                cells[cell.dataset.status] = {
                    time: cell.dataset.time,
                    operator: cell.dataset.operator,
                    date: cell.dataset.date,
                    timestamp: cell.dataset.timestamp,
                    html: cell.innerHTML
                };
            }
        });
        
        if (Object.keys(cells).length > 0) {
            tableData.push({ boatId: boatId, cells: cells });
        }
    });
    
    return tableData;
}

// Load all layouts
window.loadAllLayouts = function() {
    // Try to load from manual save
    let saved = localStorage.getItem('boatDisplayV16Complete');
    
    // If no manual save, try auto-save
    if (!saved) {
        saved = localStorage.getItem('boatDisplayAutoSave');
    }
    
    if (saved) {
        try {
            const data = JSON.parse(saved);
            
            // Clear existing
            state.boats.clear();
            state.pods.clear();
            state.rowTracking.clear();
            state.areaLayouts.clear();
            state.areaBackgrounds.clear();
            state.troubleStatusMemory.clear();
            state.tableEntryHistory.clear();
            
            // SET A FLAG TO PREVENT TABLE UPDATES DURING LOAD
            state.isLoadingLayouts = true;
            
            // Load boats
            if (data.boats) {
                data.boats.forEach(boatData => {
                    createBoat({
                        id: boatData.id,
                        type: boatData.type,
                        userGroup: boatData.userGroup,
                        checkStatus: boatData.checkStatus || boatData.status || 'none',
                        location: boatData.location || 'pier',
                        x: boatData.x,
                        y: boatData.y,
                        rotation: boatData.rotation || 0,
                        fromServer: true // Prevent initial table entry
                    });
                });
            }
            
            // Load pods
            if (data.pods) {
                data.pods.forEach(podData => {
                    state.pods.set(podData.id, podData);
                });
            }
            
            // Load layouts
            if (data.layouts) {
                Object.entries(data.layouts).forEach(([area, layout]) => {
                    state.areaLayouts.set(area, layout);
                    localStorage.setItem(`areaLayout-${area}`, JSON.stringify(layout));
                });
            }
            
            // Load backgrounds
            ['pier', 'tow', 'transit', 'operational-area'].forEach(area => {
                const bgData = localStorage.getItem(`background-${area}`);
                if (bgData) {
                    state.areaBackgrounds.set(area, bgData);
                }
            });
            
            // CLEAR THE FLAG BEFORE LOADING TABLE DATA
            state.isLoadingLayouts = false;
            
            // Load status table
            if (data.statusTableData) {
                loadStatusTableData(data.statusTableData);
            } else {
                const savedTableData = localStorage.getItem('statusTableData');
                if (savedTableData) {
                    loadStatusTableData(JSON.parse(savedTableData));
                }
            }
            
            // Set current display
            if (data.currentDisplay) {
                state.currentDisplay = data.currentDisplay;
                document.getElementById('mainDisplaySelect').value = data.currentDisplay;
            }
            
            updateBoatCount();
            updatePodCount();
            updateMainDisplay();
            updateSmallBoxes();
            
            alert('All layouts loaded successfully!');
        } catch (error) {
            state.isLoadingLayouts = false;
            console.error('Error loading layouts:', error);
            alert('Error loading layouts: ' + error.message);
        }
    } else {
        alert('No saved layouts found');
    }
}

// Load saved state
function loadSavedState() {
    // Try auto-save first
    const autoSaved = localStorage.getItem('boatDisplayAutoSave');
    if (autoSaved) {
        try {
            const stateData = JSON.parse(autoSaved);
            console.log('Loading auto-saved state from', stateData.lastSaved);
            
            // Set loading flag
            state.isLoadingLayouts = true;
            
            // Clear any existing boats first
            state.boats.clear();
            state.pods.clear();
            
            // Load boats
            if (stateData.boats) {
                stateData.boats.forEach(boatData => {
                    // Create boat with preserved pod association
                    const boat = createBoat({
                        ...boatData,
                        fromServer: true // Prevent initial table entry
                    });
                    
                    // Preserve pod association
                    if (boatData.podId) {
                        const boatObj = state.boats.get(boatData.id);
                        if (boatObj) {
                            boatObj.podId = boatData.podId;
                        }
                    }
                });
            }
            
            // Load pods AFTER boats are created
            if (stateData.pods) {
                stateData.pods.forEach(podData => {
                    // Only add pod if it has valid boats
                    const validBoats = podData.boats.filter(boatId => state.boats.has(boatId));
                    if (validBoats.length > 0) {
                        const pod = {
                            ...podData,
                            boats: validBoats
                        };
                        state.pods.set(podData.id, pod);
                        
                        // Ensure boats know they're in this pod
                        validBoats.forEach(boatId => {
                            const boat = state.boats.get(boatId);
                            if (boat) {
                                boat.podId = podData.id;
                            }
                        });
                    }
                });
            }
            
            // Load layouts
            if (stateData.layouts) {
                Object.entries(stateData.layouts).forEach(([area, layout]) => {
                    state.areaLayouts.set(area, layout);
                });
            }
            
            // Load backgrounds
            ['pier', 'tow', 'transit', 'operational-area'].forEach(area => {
                const bgData = localStorage.getItem(`background-${area}`);
                if (bgData) {
                    state.areaBackgrounds.set(area, bgData);
                }
            });
            
            // Clear loading flag
            state.isLoadingLayouts = false;
            
            // Load status table
            const savedTableData = localStorage.getItem('statusTableData');
            if (savedTableData) {
                loadStatusTableData(JSON.parse(savedTableData));
            }
            
            // Set current display
            if (stateData.currentDisplay) {
                state.currentDisplay = stateData.currentDisplay;
                document.getElementById('mainDisplaySelect').value = state.currentDisplay;
            }
            
        } catch (error) {
            console.error('Error loading saved state:', error);
            state.isLoadingLayouts = false;
        }
    }
    
    // Load webhook URL
    const webhookUrl = localStorage.getItem('googleSheetsWebhook');
    if (webhookUrl) {
        const webhookInput = document.getElementById('webhookUrl');
        if (webhookInput) {
            webhookInput.value = webhookUrl;
        }
    }

    // Only fetch from server if we have no boats
    if (state.boats.size === 0) {
        console.log('No local boats, fetching from server...');
        fetchBoatsFromServer();
    }
    
    updateBoatCount();
    updatePodCount();
    updateMainDisplay();
    updateSmallBoxes();
}

// Fetch boats from server
async function fetchBoatsFromServer() {
    try {
        const response = await fetch(N8N_CONFIG.stateWebhook);
        if (!response.ok) {
            console.error('Failed to fetch boats:', response.status);
            return;
        }
        
        const data = await response.json();
        if (data.boats && Array.isArray(data.boats)) {
            console.log(`Fetching ${data.boats.length} boats from server`);
            
            // Set loading flag to prevent table updates
            state.isLoadingLayouts = true;
            
            data.boats.forEach(boatData => {
                const boatId = parseInt(boatData.id);
                if (!state.boats.has(boatId)) {
                    createBoat({
                        id: boatId,
                        type: parseInt(boatData.type) || (boatId <= 70 ? 1 : 2),
                        userGroup: boatData.userGroup || 'leg',
                        checkStatus: boatData.status || boatData.checkStatus || 'none',
                        location: boatData.location || 'pier',
                        x: parseFloat(boatData.x) || null,
                        y: parseFloat(boatData.y) || null,
                        rotation: parseFloat(boatData.rotation) || 0,
                        fromServer: true // Prevent initial table entry
                    });
                }
            });
            
            // Clear loading flag
            state.isLoadingLayouts = false;
            
            updateBoatCount();
            updateMainDisplay();
            updateSmallBoxes();
            
            console.log('Boats loaded from server successfully');
        }
    } catch (error) {
        console.error('Error fetching boats from server:', error);
        state.isLoadingLayouts = false;
    }
}
    
// Generate view-only link
window.generateViewOnlyLink = function() {
    const currentUrl = window.location.origin + window.location.pathname;
    const viewOnlyUrl = currentUrl + '?view=only';
    
    navigator.clipboard.writeText(viewOnlyUrl).then(() => {
        alert('View-only link copied to clipboard:\n' + viewOnlyUrl);
    }).catch(() => {
        prompt('View-only link:', viewOnlyUrl);
    });
}

// Reset display
window.resetStatusDisplay = function() {
    if (confirm('Are you sure you want to reset the entire display? This will remove all boats, pods, and status data.')) {
        // Export data first
        const hasData = state.boats.size > 0 || document.getElementById('statusTableBody').innerHTML.trim() !== '';
        if (hasData) {
            if (confirm('Would you like to export the status data before resetting?')) {
                exportToCSV();
            }
        }
        
        // Clear everything
        state.boats.forEach(boat => {
            if (boat.element) boat.element.remove();
        });
        state.boats.clear();
        state.pods.clear();
        state.areaLayouts.clear();
        state.areaBackgrounds.clear();
        state.checkStatusHistory.clear();
        state.movementHistory.clear();
        state.tableEntryHistory.clear();
        state.statusLogHistory.clear();
        state.rowTracking.clear();
        state.troubleStatusMemory.clear();
        state.nextPositions.clear();
        state.boatRowCounts.clear();
        
        // Re-initialize next positions
        ['pier', 'tow', 'transit', 'operational-area'].forEach(area => {
            state.nextPositions.set(area, { x: 20, y: 100, rowCount: 0 });
        });
        
        document.getElementById('statusTableBody').innerHTML = '';
        document.getElementById('mainDisplay').style.backgroundImage = '';
        
        // Clear localStorage
        const keys = Object.keys(localStorage);
        keys.forEach(key => {
            if (key.startsWith('boatDisplay') || key.startsWith('areaLayout') || 
                key.startsWith('background-') || key === 'statusTableData' || 
                key === 'statusTableHTML') {
                localStorage.removeItem(key);
            }
        });
        
        updateBoatCount();
        updatePodCount();
        updateMainDisplay();
        updateSmallBoxes();
        
        alert('Display has been reset.');
    }
}

// FIXED DRAG AND DROP HANDLERS
function handleDragStart(e) {
    if (state.isViewOnly) return;
    
    state.draggedItem = e.target.closest('.boat-wrapper');
    if (!state.draggedItem) return;

    const parent = state.draggedItem.parentElement;
    if (parent.classList.contains('status-box-content')) {
        state.draggedFromArea = parent.closest('.status-box').dataset.area;
    } else if (parent.classList.contains('pod')) {
        const podElement = parent.closest('.pod');
        if (podElement.parentElement.classList.contains('status-box-content')) {
            state.draggedFromArea = podElement.parentElement.closest('.status-box').dataset.area;
        } else {
            state.draggedFromArea = state.currentDisplay;
        }
    } else {
        state.draggedFromArea = state.currentDisplay;
    }

    state.draggedItem.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
}

function handlePodDragStart(e) {
    if (state.isViewOnly) return;
    
    state.draggedItem = e.target.closest('.pod');
    if (!state.draggedItem) return;

    const parent = state.draggedItem.parentElement;
    if (parent.classList.contains('status-box-content')) {
        state.draggedFromArea = parent.closest('.status-box').dataset.area;
    } else {
        state.draggedFromArea = state.currentDisplay;
    }

    state.draggedItem.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
}

function handleDragEnd(e) {
    if (state.draggedItem) {
        state.draggedItem.classList.remove('dragging');
        state.draggedItem = null;
        state.draggedFromArea = null;
    }
}

function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
}

function handleDrop(e) {
    e.preventDefault();
    if (!state.draggedItem) return;
    
    const mainDisplay = document.getElementById('mainDisplay');
    const rect = mainDisplay.getBoundingClientRect();

    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (state.draggedItem.classList.contains('pod')) {
        const podId = state.draggedItem.dataset.podId;
        const pod = state.pods.get(podId);
        if (pod) {
            pod.x = x;
            pod.y = y;
            state.draggedItem.style.left = x + 'px';
            state.draggedItem.style.top = y + 'px';
            
            saveAreaLayout(state.currentDisplay);
            autoSaveState();
        }
    } else {
        const boatId = parseInt(state.draggedItem.id.replace('boat-wrapper-', ''));
        const boatData = state.boats.get(boatId);
        if (boatData) {
            boatData.x = x;
            boatData.y = y;
            state.draggedItem.style.left = x + 'px';
            state.draggedItem.style.top = y + 'px';
            
            saveAreaLayout(state.currentDisplay);
            autoSaveState();
        }
    }
}

// Rotation handling
function handleRotationStart(e, element) {
    e.preventDefault();
    state.rotatingBoat = element;
    
    const rect = element.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;

    const currentRotation = element.style.transform.match(/rotate\((-?\d+(?:\.\d+)?)deg\)/);
    const startAngle = currentRotation ? parseFloat(currentRotation[1]) : 0;

    const mouseAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;

    element.dataset.rotationStart = startAngle;
    element.dataset.mouseStart = mouseAngle;

    document.addEventListener('mousemove', handleRotation);
    document.addEventListener('mouseup', handleRotationEnd);
}

function handleRotation(e) {
    if (!state.rotatingBoat) return;
    
    const rect = state.rotatingBoat.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;

    const currentMouseAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;
    const mouseStart = parseFloat(state.rotatingBoat.dataset.mouseStart);
    const rotationStart = parseFloat(state.rotatingBoat.dataset.rotationStart);

    const angleDiff = currentMouseAngle - mouseStart;
    const newRotation = rotationStart + angleDiff;

    state.rotatingBoat.style.transform = `rotate(${newRotation}deg)`;

    const boatId = parseInt(state.rotatingBoat.id.replace('boat-wrapper-', ''));
    const boatData = state.boats.get(boatId);
    if (boatData) {
        boatData.rotation = newRotation;
    }
}

function handleRotationEnd(e) {
    document.removeEventListener('mousemove', handleRotation);
    document.removeEventListener('mouseup', handleRotationEnd);
    
    if (state.rotatingBoat) {
        saveAreaLayout(state.currentDisplay);
        autoSaveState();
    }

    state.rotatingBoat = null;
}

// Handle pod rotation
function handlePodRotationStart(e, podElement, podId) {
    e.preventDefault();
    state.rotatingPod = { element: podElement, id: podId };
    
    const rect = podElement.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;

    const pod = state.pods.get(podId);
    const startAngle = pod?.rotation || 0;

    const mouseAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;

    podElement.dataset.rotationStart = startAngle;
    podElement.dataset.mouseStart = mouseAngle;

    document.addEventListener('mousemove', handlePodRotation);
    document.addEventListener('mouseup', handlePodRotationEnd);
}

function handlePodRotation(e) {
    if (!state.rotatingPod) return;
    
    const { element, id } = state.rotatingPod;
    const rect = element.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
   const centerY = rect.top + rect.height / 2;

   const currentMouseAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;
   const mouseStart = parseFloat(element.dataset.mouseStart);
   const rotationStart = parseFloat(element.dataset.rotationStart);

   const angleDiff = currentMouseAngle - mouseStart;
   const newRotation = rotationStart + angleDiff;

   element.style.transform = `rotate(${newRotation}deg)`;

   const pod = state.pods.get(id);
   if (pod) {
       pod.rotation = newRotation;
   }
}

function handlePodRotationEnd(e) {
   document.removeEventListener('mousemove', handlePodRotation);
   document.removeEventListener('mouseup', handlePodRotationEnd);
   
   if (state.rotatingPod) {
       saveAreaLayout(state.currentDisplay);
       autoSaveState();
   }

   state.rotatingPod = null;
}

// Pod management functions
function createPod(boatIds, location) {
   const podId = 'pod_' + Date.now();
   const pod = {
       id: podId,
       boats: boatIds,
       location: location,
       rotation: 0,
       x: 20,
       y: 20
   };
   
   state.pods.set(podId, pod);

   boatIds.forEach(boatId => {
       const boat = state.boats.get(boatId);
       if (boat) {
           boat.podId = podId;
       }
   });

   updatePodCount();
   updateMainDisplay();
   updateSmallBoxes();

   return pod;
}

// Break up pod
function breakUpPod(podId) {
   const pod = state.pods.get(podId);
   if (!pod) return;
   
   pod.boats.forEach(boatId => {
       const boat = state.boats.get(boatId);
       if (boat) {
           boat.podId = null;
           const pos = getNextPosition(boat.location, boat.type);
           boat.x = pos.x;
           boat.y = pos.y;
       }
   });

   state.pods.delete(podId);

   updatePodCount();
   updateMainDisplay();
   updateSmallBoxes();

   document.getElementById('contextMenu').style.display = 'none';
}

// Toggle pod boat selection
function togglePodBoat(boatId, event) {
   event.stopPropagation();
   const checkbox = document.getElementById(`pod-boat-${boatId}`);
   if (checkbox) {
       checkbox.checked = !checkbox.checked;
   }
}

// Create pod from selected boats
function createPodFromSelection(area) {
   const menu = document.getElementById('contextMenu');
   const checkboxes = menu.querySelectorAll('input[type="checkbox"]:checked');
   
   if (checkboxes.length < 2) {
       alert('Please select at least 2 boats to create a pod');
       return;
   }

   const boatIds = Array.from(checkboxes).map(cb => parseInt(cb.value));
   createPod(boatIds, area);

   menu.style.display = 'none';
}

// Global function references for onclick handlers
window.togglePodBoat = togglePodBoat;
window.createPodFromSelection = createPodFromSelection;
window.breakUpPod = breakUpPod;

// FIXED CONTEXT MENU FUNCTIONS

// Show boat context menu (FIXED to handle operator properly)
function showBoatContextMenu(e, boatId) {
   const menu = document.getElementById('contextMenu');
   const boatData = state.boats.get(boatId);
   if (!boatData) return;

   const prefix = boatData.type === 1 ? 'C' : 'G';
   const paddedNumber = boatId.toString().padStart(2, '0');

   menu.innerHTML = `
       <div class="context-menu-item" style="font-weight: bold; color: #00bfff;">
           ${prefix}${paddedNumber} - Status Update
       </div>
       <div class="context-menu-separator"></div>
       <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'none')">
           <span class="status-indicator-menu status-none" style="width: 10px; height: 10px; border-radius: 2px; display: inline-block;"></span>
           No Check
       </div>
       <div class="context-menu-item has-submenu">
           <span class="status-indicator-menu status-platform" style="width: 10px; height: 10px; border-radius: 2px; display: inline-block; background: #ff8c00;"></span>
           Platform Check
           <div class="submenu">
               <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'platform-start')">Start</div>
               <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'platform')">Complete</div>
           </div>
       </div>
       <div class="context-menu-item has-submenu">
           <span class="status-indicator-menu status-pierside" style="width: 10px; height: 10px; border-radius: 2px; display: inline-block; background: #ffff00;"></span>
           Pierside Check
           <div class="submenu">
               <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pierside-start')">Start</div>
               <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pierside-hold')">Hold</div>
               <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pierside')">Complete</div>
           </div>
       </div>
       <div class="context-menu-item has-submenu">
           <span class="status-indicator-menu status-pretow" style="width: 10px; height: 10px; border-radius: 2px; display: inline-block; background: linear-gradient(45deg, #fff 50%, #0f0 50%);"></span>
           Pre-Tow Check
           <div class="submenu">
               <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pretow-start')">Start</div>
               <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pretow')">Complete</div>
           </div>
       </div>
       <div class="context-menu-item has-submenu">
           <span class="status-indicator-menu status-operational" style="width: 10px; height: 10px; border-radius: 2px; display: inline-block; background: #00ff00;"></span>
           Post-Tow Check
           <div class="submenu">
               <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'operational-start')">Start</div>
               <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'operational')">Complete</div>
           </div>
       </div>
       <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'trouble')">
           <span class="status-indicator-menu status-trouble" style="width: 10px; height: 10px; border-radius: 2px; display: inline-block; background: repeating-linear-gradient(45deg, #f00, #f00 3px, #f80 3px, #f80 6px);"></span>
           Trouble
       </div>
       ${boatData.troublePreviousStatus ? `
       <div class="context-menu-item" onclick="clearTroubleStatus(${boatId})">
           ✓ Clear Trouble (Restore ${boatData.troublePreviousStatus})
       </div>
       ` : ''}
       <div class="context-menu-separator"></div>
       <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'tow')">
           Being Towed
       </div>
       <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'transit')">
           In Transit
       </div>
       <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'operational-area')">
           Operational Area
       </div>
       <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'return-pier')">
           Return to Pier
       </div>
   `;

   positionContextMenu(menu, e.pageX, e.pageY);
   setupSubmenuHover(menu);
}

// Show context menu for boat within a pod
function showBoatInPodContextMenu(e, boatId, podId) {
   const menu = document.getElementById('contextMenu');
   const boatData = state.boats.get(boatId);
   const pod = state.pods.get(podId);
   if (!boatData) return;

   const prefix = boatData.type === 1 ? 'C' : 'G';
   const paddedNumber = boatId.toString().padStart(2, '0');

   menu.innerHTML = `
       <div class="context-menu-item" style="font-weight: bold; color: #00bfff;">
           ${prefix}${paddedNumber} - In Pod
       </div>
       <div class="context-menu-separator"></div>
       <div class="context-menu-item" style="font-weight: bold;">Check Status (This Boat)</div>
       <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'none')">No Check</div>
       <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'platform-start')">Platform Start</div>
       <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'platform')">Platform Complete</div>
       <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pierside-start')">Pierside Start</div>
       <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pierside-hold')">Pierside Hold</div>
       <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pierside')">Pierside Complete</div>
       <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pretow-start')">Pre-Tow Start</div>
       <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'pretow')">Pre-Tow Complete</div>
       <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'operational-start')">Post-Tow Start</div>
       <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'operational')">Post-Tow Complete</div>
       <div class="context-menu-item" onclick="updateBoatStatusFromMenu(${boatId}, 'trouble')">Trouble</div>
       <div class="context-menu-separator"></div>
       <div class="context-menu-item" style="font-weight: bold;">Check Status (Entire Pod)</div>
       <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'none')">All No Check</div>
       <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'platform-start')">All Platform Start</div>
       <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'platform')">All Platform Complete</div>
       <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'pierside-start')">All Pierside Start</div>
       <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'pierside-hold')">All Pierside Hold</div>
       <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'pierside')">All Pierside Complete</div>
       <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'pretow-start')">All Pre-Tow Start</div>
       <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'pretow')">All Pre-Tow Complete</div>
       <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'operational-start')">All Post-Tow Start</div>
       <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'operational')">All Post-Tow Complete</div>
       <div class="context-menu-separator"></div>
       <div class="context-menu-item" style="font-weight: bold;">Movement (Entire Pod)</div>
       <div class="context-menu-item" onclick="updatePodMovementFromMenu('${podId}', 'tow')">All Being Towed</div>
       <div class="context-menu-item" onclick="updatePodMovementFromMenu('${podId}', 'transit')">All In Transit</div>
       <div class="context-menu-item" onclick="updatePodMovementFromMenu('${podId}', 'operational-area')">All Operational Area</div>
       <div class="context-menu-item" onclick="updatePodMovementFromMenu('${podId}', 'return-pier')">All Return to Pier</div>
       <div class="context-menu-separator"></div>
       <div class="context-menu-item" onclick="breakUpPod('${podId}')">🔗 Break Up Pod</div>
   `;

   positionContextMenu(menu, e.clientX, e.clientY);
}

// Show pod context menu
function showPodContextMenu(e, podId) {
   const menu = document.getElementById('contextMenu');
   const pod = state.pods.get(podId);
   if (!pod) return;

   menu.innerHTML = `
       <div class="context-menu-item" style="font-weight: bold; color: #00bfff;">
           Pod Options
       </div>
       <div class="context-menu-separator"></div>
       <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'none')">All No Check</div>
       <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'platform-start')">All Platform Start</div>
       <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'platform')">All Platform Complete</div>
       <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'pierside-start')">All Pierside Start</div>
       <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'pierside-hold')">All Pierside Hold</div>
       <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'pierside')">All Pierside Complete</div>
       <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'pretow-start')">All Pre-Tow Start</div>
       <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'pretow')">All Pre-Tow Complete</div>
       <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'operational-start')">All Post-Tow Start</div>
       <div class="context-menu-item" onclick="updatePodCheckStatusFromMenu('${podId}', 'operational')">All Post-Tow Complete</div>
       <div class="context-menu-separator"></div>
       <div class="context-menu-item" style="font-weight: bold;">Movement (Entire Pod)</div>
       <div class="context-menu-item" onclick="updatePodMovementFromMenu('${podId}', 'tow')">All Being Towed</div>
       <div class="context-menu-item" onclick="updatePodMovementFromMenu('${podId}', 'transit')">All In Transit</div>
       <div class="context-menu-item" onclick="updatePodMovementFromMenu('${podId}', 'operational-area')">All Operational Area</div>
       <div class="context-menu-item" onclick="updatePodMovementFromMenu('${podId}', 'return-pier')">All Return to Pier</div>
       <div class="context-menu-separator"></div>
       <div class="context-menu-item" onclick="breakUpPod('${podId}')">🔗 Break Up Pod</div>
   `;

   positionContextMenu(menu, e.pageX, e.pageY);
}

// Show area context menu for creating pods
function showAreaContextMenu(e, area) {
   const menu = document.getElementById('contextMenu');
   const areaBoats = [];
   
   state.boats.forEach((boat, id) => {
       if (boat.location === area && !boat.podId) {
           areaBoats.push({ id, boat });
       }
   });

   areaBoats.sort((a, b) => {
       if (a.boat.userGroup !== b.boat.userGroup) {
           return a.boat.userGroup === 'lat' ? -1 : 1;
       }
       if (a.boat.type !== b.boat.type) {
           return a.boat.type - b.boat.type;
       }
       return a.id - b.id;
   });

   let menuHTML = `
       <div class="context-menu-item" style="font-weight: bold; color: #00bfff;">
           Create Pod
       </div>
       <div class="context-menu-separator"></div>
   `;

   if (areaBoats.length === 0) {
       menuHTML += `<div class="context-menu-item" style="color: #666;">No boats available</div>`;
   } else {
       areaBoats.forEach(({ id, boat }) => {
           const prefix = boat.type === 1 ? 'C' : 'G';
           const paddedNumber = id.toString().padStart(2, '0');
           menuHTML += `
               <div class="context-menu-item" onclick="togglePodBoat(${id}, event)">
                   <input type="checkbox" id="pod-boat-${id}" value="${id}" style="margin-right: 5px; pointer-events: none;">
                   <label for="pod-boat-${id}" style="cursor: pointer; pointer-events: none;">
                       ${prefix}${paddedNumber} (${boat.userGroup === 'leg' ? 'Leg' : 'Lat'})
                   </label>
               </div>
           `;
       });
       
       menuHTML += `
           <div class="context-menu-separator"></div>
           <div class="context-menu-item" onclick="createPodFromSelection('${area}')" style="background: linear-gradient(45deg, #00bfff, #b19cd9); color: #fff;">
               Create Pod
           </div>
       `;
   }

   menu.innerHTML = menuHTML;
   positionContextMenu(menu, e.pageX, e.pageY);
}

// Show context menu for manual cell override
function showCellContextMenu(e, cell) {
   e.preventDefault();
   const cellId = cell.id || generateCellId(cell);
   if (!cell.id) {
       cell.id = cellId;
   }

   const dialog = document.createElement('div');
   dialog.className = 'manual-override-dialog';
   dialog.style.cssText = `
       position: fixed;
       left: ${e.clientX}px;
       top: ${e.clientY}px;
       background: #2a2a2a;
       border: 2px solid #444;
       border-radius: 8px;
       padding: 15px;
       z-index: 10000;
       box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
       color: #fff;
   `;

   dialog.innerHTML = `
       <div style="color: #00bfff; margin-bottom: 10px; font-weight: bold;">Manual Override</div>
       <input type="text" id="override-time" placeholder="HH:MM (or leave blank for now)" 
              style="width: 100%; margin-bottom: 5px; padding: 5px; background: #333; border: 1px solid #555; color: #fff; border-radius: 3px;">
       <input type="text" id="override-operator" placeholder="Operator name" 
              value="${localStorage.getItem('lastOperator') || ''}"
              style="width: 100%; margin-bottom: 10px; padding: 5px; background: #333; border: 1px solid #555; color: #fff; border-radius: 3px;">
       <div style="display: flex; gap: 5px;">
           <button onclick="applyManualOverride('${cellId}')" 
                   style="flex: 1; padding: 5px 10px; background: #00bfff; border: none; border-radius: 3px; color: #000; cursor: pointer; font-weight: bold;">
               Apply
           </button>
           <button onclick="clearCell('${cellId}')" 
                   style="flex: 1; padding: 5px 10px; background: #ff6b6b; border: none; border-radius: 3px; color: #fff; cursor: pointer; font-weight: bold;">
               Clear
           </button>
           <button onclick="this.parentElement.parentElement.remove()" 
                   style="flex: 1; padding: 5px 10px; background: #666; border: none; border-radius: 3px; color: #fff; cursor: pointer;">
               Cancel
           </button>
       </div>
   `;

   document.querySelectorAll('.manual-override-dialog').forEach(d => d.remove());
   document.body.appendChild(dialog);

   const rect = dialog.getBoundingClientRect();
   if (rect.right > window.innerWidth) {
       dialog.style.left = (window.innerWidth - rect.width - 10) + 'px';
   }
   if (rect.bottom > window.innerHeight) {
       dialog.style.top = (window.innerHeight - rect.height - 10) + 'px';
   }

   document.getElementById('override-time').focus();
}

// Position context menu properly near cursor
function positionContextMenu(menu, x, y) {
   menu.style.display = 'block';
   menu.style.visibility = 'hidden';
   
   const menuRect = menu.getBoundingClientRect();
   const menuWidth = menuRect.width;
   const menuHeight = menuRect.height;
   
   const viewportWidth = window.innerWidth;
   const viewportHeight = window.innerHeight;
   const scrollY = window.scrollY;
   const scrollX = window.scrollX;
   
   let adjustedX = x - scrollX;
   let adjustedY = y - scrollY;
   
   if (adjustedX + menuWidth > viewportWidth - 10) {
       adjustedX = x - scrollX - menuWidth - 10;
   }
   
   if (adjustedY + menuHeight > viewportHeight - 10) {
       adjustedY = viewportHeight - menuHeight - 10;
   }
   
   adjustedX = Math.max(10, adjustedX);
   adjustedY = Math.max(10, adjustedY);
   
   menu.style.left = adjustedX + 'px';
   menu.style.top = adjustedY + 'px';
   menu.style.visibility = 'visible';
}

// Setup submenu hover
function setupSubmenuHover(menu) {
   const itemsWithSubmenu = menu.querySelectorAll('.has-submenu');
   
   itemsWithSubmenu.forEach(item => {
       const submenu = item.querySelector('.submenu');
       if (submenu) {
           let hoverTimer = null;
           
           item.addEventListener('mouseenter', () => {
               hoverTimer = setTimeout(() => {
                   submenu.style.display = 'block';
                   
                   const itemRect = item.getBoundingClientRect();
                   const submenuRect = submenu.getBoundingClientRect();
                   
                   if (itemRect.right + submenuRect.width > window.innerWidth) {
                       submenu.style.left = 'auto';
                       submenu.style.right = '100%';
                       submenu.style.marginLeft = '0';
                       submenu.style.marginRight = '5px';
                   }
                   
                   if (itemRect.top + submenuRect.height > window.innerHeight) {
                       const overflow = (itemRect.top + submenuRect.height) - window.innerHeight;
                       submenu.style.top = `${-overflow - 10}px`;
                   }
               }, 100);
           });
           
           item.addEventListener('mouseleave', (e) => {
               clearTimeout(hoverTimer);
               
               const toElement = e.relatedTarget;
               if (toElement && submenu.contains(toElement)) {
                   return;
               }
               
               setTimeout(() => {
                   if (!item.matches(':hover') && !submenu.matches(':hover')) {
                       submenu.style.display = 'none';
                   }
               }, 100);
           });
           
           submenu.addEventListener('mouseenter', () => {
               clearTimeout(hoverTimer);
               submenu.style.display = 'block';
           });
           
           submenu.addEventListener('mouseleave', (e) => {
               const toElement = e.relatedTarget;
               if (toElement && item.contains(toElement)) {
                   return;
               }
               submenu.style.display = 'none';
           });
       }
   });
}

// STATUS UPDATE FUNCTIONS

// Update boat status from menu (properly handle operator)
window.updateBoatStatusFromMenu = function(boatId, status) {
   // Close menu first
   document.getElementById('contextMenu').style.display = 'none';
   
   // Then prompt for operator
   setTimeout(() => {
       const operator = prompt('Enter your name:', localStorage.getItem('lastOperator') || 'Manual');
       if (operator) {
           localStorage.setItem('lastOperator', operator);
           
           // Determine if check or movement
           const movementStatuses = ['tow', 'transit', 'operational-area', 'return-pier'];
           if (movementStatuses.includes(status)) {
               updateMovementStatus(boatId, status, operator);
           } else {
               updateCheckStatus(boatId, status, operator);
           }
       }
   }, 100); // Small delay to ensure menu is closed
}

// Update entire pod check status from menu
window.updatePodCheckStatusFromMenu = function(podId, status) {
    document.getElementById('contextMenu').style.display = 'none';
    
    setTimeout(() => {
        const operator = prompt('Enter your name:', localStorage.getItem('lastOperator') || 'Manual');
        if (operator) {
            localStorage.setItem('lastOperator', operator);
            const pod = state.pods.get(podId);
            if (pod) {
                // SET BATCH FLAG
                state.isBatchUpdate = true;
                state.batchUpdateKey = `${podId}-${status}-${operator}-${Date.now()}`;
                
                pod.boats.forEach((boatId, index) => {
                    // Only create one table row for the first boat
                    if (index === 0) {
                        state.isBatchUpdate = false;  // Allow first one
                    }
                    updateCheckStatus(boatId, status, operator);
                    if (index === 0) {
                        state.isBatchUpdate = true;  // Block rest
                    }
                });
                
                // CLEAR BATCH FLAG
                state.isBatchUpdate = false;
                state.batchUpdateKey = null;
            }
        }
    }, 100);
}

// Update entire pod movement from menu (FIXED)
window.updatePodMovementFromMenu = function(podId, status) {
   document.getElementById('contextMenu').style.display = 'none';
   
   setTimeout(() => {
       const operator = prompt('Enter your name:', localStorage.getItem('lastOperator') || 'Manual');
       if (operator) {
           localStorage.setItem('lastOperator', operator);
           const pod = state.pods.get(podId);
           if (pod) {
               // Move entire pod together
               pod.boats.forEach(boatId => {
                   updateMovementStatus(boatId, status, operator);
               });
           }
       }
   }, 100);
}

// Clear trouble status and restore previous
window.clearTroubleStatus = function(boatId) {
   const boatData = state.boats.get(boatId);
   if (!boatData || !boatData.troublePreviousStatus) return;
   
   document.getElementById('contextMenu').style.display = 'none';
   
   setTimeout(() => {
       const operator = prompt('Enter your name:', localStorage.getItem('lastOperator') || 'Manual');
       if (operator) {
           localStorage.setItem('lastOperator', operator);
           
           const previousStatus = boatData.troublePreviousStatus;
           boatData.troublePreviousStatus = null;
           
           updateCheckStatus(boatId, previousStatus, operator + ' (Trouble Cleared)');
       }
   }, 100);
}

// Manual override for status cell
window.applyManualOverride = function(cellId) {
   const cell = document.getElementById(cellId);
   if (!cell) {
       console.error('Cell not found:', cellId);
       return;
   }
   
   const timeInput = document.getElementById('override-time').value;
   const operatorInput = document.getElementById('override-operator').value;
   
   if (!operatorInput) {
       alert('Please enter an operator name');
       return;
   }
   
   localStorage.setItem('lastOperator', operatorInput);
   
   let timestamp = new Date();
   if (timeInput) {
       const [hours, minutes] = timeInput.split(':').map(n => parseInt(n) || 0);
       timestamp.setHours(hours, minutes, 0);
   }
   
   const timeStr = timestamp.toLocaleTimeString('en-US', { 
       hour: '2-digit', 
       minute: '2-digit',
       hour12: false 
   });
   
   cell.innerHTML = `${timeStr}<br><small>${operatorInput}</small>`;
   cell.title = `${timestamp.toLocaleString()} - ${operatorInput} (Manual Override)`;
   
   // Apply correct styling
   const statusType = cell.dataset.status;
   if (statusType) {
       cell.className = cell.className.split(' ').filter(c => !c.startsWith('status-')).join(' ');
       cell.className += ` status-${statusType.replace('-complete', '').replace('-start', '').replace('-hold', '')}`;
       
       if (statusType.includes('-start') || statusType.includes('-hold')) {
           cell.className = cell.className.split(' ').filter(c => !c.startsWith('status-')).join(' ');
           cell.className += ` status-${statusType}`;
       }
   }
   
   // Save state
   saveStatusTableState();
   
   const row = cell.closest('tr');
   const boatId = parseInt(row.dataset.boatId);
   const boat = state.boats.get(boatId);
   if (boat) {
       sendToGoogleSheets(boatId, boat, statusType, operatorInput);
   }
   
   document.querySelectorAll('.manual-override-dialog').forEach(d => d.remove());
}

// Clear cell
window.clearCell = function(cellId) {
   const cell = document.getElementById(cellId);
   
   if (cell && confirm('Clear this status entry?')) {
       cell.innerHTML = '';
       cell.className = cell.className.split(' ').filter(c => !c.startsWith('status-')).join(' ');
       cell.removeAttribute('title');
       
       saveStatusTableState();
   }
   
   document.querySelectorAll('.manual-override-dialog').forEach(d => d.remove());
}

// Log initialization complete
console.log('Boat Status Display System - FINAL FIXED VERSION');
console.log('All issues resolved:');
console.log('[✓] Check status and movement properly separated');
console.log('[✓] Operator prompt working correctly');
console.log('[✓] Pod movements handled properly');
console.log('[✓] Manual drag/drop logging fixed');
console.log('[✓] Table updates working correctly');
console.log('[✓] Colors preserved during movement');
console.log('[✓] Timestamps preserved when loading');
console.log('[✓] Duplicate entries prevented');
console.log('[✓] New row creation logic fixed');

</script>
</body>
</html>

